연락처 제공자는 사람에 대한 중앙 데이터 저장소를 관리하는 강력하고 유연한 Android 구성요소입니다. 연락처 제공자는 기기의 연락처 애플리케이션에서 볼 수 있는 데이터의 소스이며, 개발자는 자신의 애플리케이션에서 연락처 제공자의 데이터에 액세스하고 기기와 온라인 서비스 간에 데이터를 전송할 수도 있습니다. 이 제공업체는 광범위한 데이터 소스를 수용하고 각 개인에 대해 가능한 한 많은 데이터를 관리하려고 하므로 조직이 복잡합니다. 따라서 이 제공업체의 API에는 데이터 검색과 수정을 모두 용이하게 하는 광범위한 계약 클래스와 인터페이스 세트가 포함되어 있습니다.



연락처 제공자의 구성	
연락처 제공자는 Android 콘텐츠 제공자 구성요소입니다. 사용자에 관한 세 가지 유형의 데이터를 유지합니다. 각 유형은 그림 1에서와 같이 제공자가 제공하는 테이블에 대응합니다. 이 세 개의 테이블은 일반적으로 해당 계약 클래스 이름으로 불립니다. 이 클래스는 테이블에서 사용하는 콘텐츠 URI, 열 이름, 열 값의 상수를 정의합니다.

테이블 ContactsContract.Contacts
원시 연락처 행들을 종합하여 얻은 서로 다른 사람을 나타내는 행입니다.
테이블 ContactsContract.RawContacts
사용자 계정 및 유형에 따라 개인의 데이터 요약이 포함된 행입니다.
테이블 ContactsContract.Data
이메일 주소나 전화번호와 같은 원시 연락처의 세부정보가 포함된 행입니다.

ContactsContract의 계약 클래스에서의 이 외의 다른 테이블은 연락처 제공자가 작업을 관리하거나 기기의 연락처 또는 전화 통신 애플리케이션에서 특정 기능을 지원하는 데 사용하는 보조 테이블입니다.



원시 연락처
원시 연락처는 특정 계정 유형과 계정 이름에서 가져온 한 사람의 데이터를 의미한다. 이때 계정 유형은Google, Naver 같이 연락처를 제공하는 서비스의 종류를 의미하고 계정 이름은 계정을 식별하는 고유 문자열을 의미한다. 보통 계정의 로그인 ID나 이메일 주소를 뜻한다. Contacts Provider는 한 사람의 데이터 출처로 여러 온라인 서비스를 허용하기 때문에, 동일한 사람에 대해 여러 개의 raw contact를 가질 수 있다. 또한, 동일한 계정 유형 안에서 서로 다른 계정을 통해 한 사람의 데이터를 결합하는 것도 가능하다.

Raw contact의 대부분의 데이터는 ContactsContract.RawContacts 테이블에 저장되지 않는다. 대신, 하나 이상의 행으로 ContactsContract.Data 테이블에 저장된다. 각 데이터 행에는 Data.RAW_CONTACT_ID 컬럼이 있으며, 이는 해당 데이터 행이 속한 ContactsContract.RawContacts 행의 _ID 값을 가진다.

주요 원시 연락처 열
ContactsContract.RawContacts 테이블의 중요 열은 다음과 같습니다.
ACCOUNT_NAME	
이 원시 연락처의 소스인 계정 유형의 계정 이름입니다. 예를 들어 Google 계정의 계정 이름은 기기 소유자의 Gmail 주소 중 하나입니다. 
이 이름의 형식은 각 계정 유형별로 다릅니다. 반드시 이메일 주소일 필요는 없습니다.
ACCOUNT_TYPE	
이 원시 연락처의 소스인 계정 유형입니다. 예를 들어 Google 계정의 계정 유형은 com.google입니다.  도메인 식별자를 사용하여 항상 소유하거나 제어하는 도메인의 계정 유형을 지정하세요. 이렇게 하면 계정 유형이 고유하게 유지됩니다.
연락처 데이터를 제공하는 계정 유형에는 일반적으로 연락처 제공자와 동기화되는 동기화 어댑터가 연결되어 있습니다.
DELETED	
원시 연락처에 대한 '삭제됨' 플래그입니다.	
이 플래그를 사용하면 연락처 제공자가 동기화 어댑터가 서버에서 행을 삭제한 다음 최종적으로 저장소에서 해당 행을 삭제할 수 있을 때까지 내부적으로 행을 유지할 수 있습니다.

다음은 ContactsContract.RawContacts 테이블에 관한 중요한 참고사항입니다.
- 원시 연락처의 이름은 ContactsContract.RawContacts의 행에 저장되지 않습니다. 대신 ContactsContract.Data 테이블의 ContactsContract.CommonDataKinds.StructuredName 행에 저장됩니다. 하나의 원시 연락처에는 ContactsContract.Data 테이블에서 이 유형의 행이 하나만 있습니다. StructuredName은 이름 관련 필드를 담는 데이터 타입으로 하나의 raw contact는 이름이 하나만 있으므로, 이 타입의 row는 1개만 존재
- 원시 연락처 행에서 본인 소유의 계정 데이터를 사용하려면 이를 먼저 AccountManager에 등록해야 합니다. 이렇게 하려면 사용자에게 계정 유형과 계정 이름을 계정 목록에 추가하라는 메시지를 표시합니다. 이렇게 하지 않으면 연락처 제공자가 원시 연락처 행을 자동으로 삭제합니다. 즉, Contacts Provider는 해당 계정이 AccountManager에 등록되어 있어야 유효하다고 판단하기 때문에 유효한 계정의 대한 row만 유지. 예를 들어 앱에서 com.example.dataservice 도메인을 사용하는 웹 기반 서비스의 연락처 데이터를 유지하고 서비스의 사용자 계정이 becky.sharp@dataservice.example.com인 경우 사용자가 먼저 계정 '유형' (com.example.dataservice)과 계정 '이름'(becky.smart@dataservice.example.com)을 추가해야 앱에서 원시 연락처 행을 추가할 수 있습니다. 이 요구사항을 사용자에게 문서로 설명하거나 사용자에게 유형과 이름을 추가하라는 메시지를 표시하거나 두 가지를 모두 수행할 수 있습니다. 


원시 연락처 데이터 소스 예시
원시 연락처의 작동 방식을 이해하려면 기기에 다음 세 개의 사용자 계정이 정의된 사용자 'Emily Dickinson'이 있다고 가정해 보겠습니다.
- emily.dickinson@gmail.com
- emilyd@gmail.com
- Twitter 계정인 'belle_of_amherst'
이 사용자는 계정 설정에서 세 계정 모두의 연락처 동기화를 사용 설정했습니다. Emily Dickinson이 브라우저 창을 열고 emily.dickinson@gmail.com으로 Gmail에 로그인한 다음 연락처를 열고 'Thomas Higginson'을 추가한다고 가정해 보겠습니다. 나중에 그녀는 emilyd@gmail.com으로 Gmail에 로그인하고 'Thomas Higginson'에게 이메일을 보냅니다. 그러면 자동으로 연락처에 추가됩니다. 또한 트위터에서 'colonel_tom' (Thomas Higginson의 Twitter ID)도 팔로우합니다.

연락처 제공자는 이 작업의 결과로 원시 연락처를 세 개 생성합니다.
- 'Thomas Higginson'에 대해 생성된 첫번째 원시 연락처는 emily.dickinson@gmail.com 입니다. 사용자 계정 유형은 Google입니다.
- Thomas Higginson'에 대해 생성된 두 번째 원시 연락처는 emilyd@gmail.com입니다. 사용자 계정 유형은 마찬가지로 Google입니다. 이전과 같은 이름을 가진 동일 인물이라도 다른 계정을 추가하였기 때문에 두 번째 원시 연락처가 생성 되었습니다.
- Thomas Higginson'에 대해 생성된 세 번째 원시 연락처는'belle_of_amherst'입니다. 사용자 계정 유형은 Twitter입니다.



Data
개념
앞서 언급했듯이 원시 연락처의 데이터는 원시 연락처의 _ID 값과 연결된 ContactsContract.Data 행에 저장됩니다. 이렇게 하면 하나의 원시 연락처에 같은 유형의 데이터를 여러 개의 인스턴스로 생성할 수 있습니다. 예를 들어 Thomas Higginson는 Google 계정으로 emilyd@gmail.com의 원시 연락처를 가집니다. 해당 연락처 행의 집 이메일 주소가 thigg@gmail.com이고 직장 이메일 주소가 thomas.higginson@gmail.com이면, 연락처 제공자는 두 이메일 주소 행을 저장하고 두 가지를 원시 연락처에 연결합니다. 즉, 1개의 원시 연락처에 대해 2개의 Data 테이블이 참조합니다. 이때 원시 연락처의 _ID값을 통해 연결됩니다.

이 테이블 하나에 여러 가지 유형의 데이터가 저장될 수 있습니다. 표시 이름, 전화번호, 이메일, 우편 주소, 사진, 웹사이트 세부정보 행은 모두 ContactsContract.Data 테이블에 있습니다. 이를 관리하는 데 도움이 되도록 ContactsContract.Data 테이블에는 이름에 명이 포함된 열 몇 개와 일반적인 이름이 포함된 열이 몇 개 있습니다. 설명이 포함된 이름 열의 콘텐츠는 행의 데이터 유형과 관계없이 동일한 의미를 지니며, 일반 이름 열의 콘텐츠는 데이터 유형에 따라 의미가 달라집니다.


Descriptive column 이름
다음은 설명이 포함된 열 이름의 몇 가지 예입니다.

RAW_CONTACT_ID
이 데이터에 관한 원시 연락처의 _ID 열 값입니다.

MIMETYPE
이 행에 저장되는 데이터 유형으로, 맞춤 MIME 유형으로 표현됩니다. 연락처 제공자는 ContactsContract.CommonDataKinds의 서브클래스에 정의된 MIME 유형을 사용합니다. 이러한 MIME 유형은 오픈소스이며 연락처 제공자와 호환되는 모든 애플리케이션 또는 동기화 어댑터에서 사용할 수 있습니다.

IS_PRIMARY
하나의 원시 연락처에 대해 해당 데이터 유형이 2개 이상있는 경우, IS_PRIMARY 컬럼은 그 유형에서 기본데이터가 무엇인지 표시한다. 를 들어, 사용자가 연락처의 전화번호를 길게 눌러 기본값으로 설정하면, 해당 전화번호를 담고 있는 ContactsContract.Data row의 IS_PRIMARY 컬럼 값이 0이 아닌 값으로 설정된다


Generic column 이름
일반적으로 사용 가능한 DATA1~DATA15라는 일반 열 15개와 동기화 어댑터에서만 사용해야 하는 추가 일반 열 SYNC1~SYNC4 4개가 있습니다. 일반 열 이름 상수는 행에 포함된 데이터 유형과 관계없이 항상 작동합니다. DATA1 열은 인덱스로 사용됩니다. 연락처 제공자는 제공자가 가장 자주 쿼리의 대상이 될 것으로 예상하는 데이터에 항상 DATA1 열을 사용합니다. 예를 들어 이메일 행의 경우 이 열에 실제 이메일 주소가 저장됩니다. 쿼리 대상이 주로 휴대전화면 실제 전화번호 값이 저장됩니다. 그렇기 때문에 위에서 데이터 유형에 따라 의미가 달라진다고 하는 겁니다. 규칙에 따라 DATA15 열은 썸네일 사진과 같은 BLOB(Binary Large Object) 데이터 저장에 사용됩니다.


유형별 열 이름
특정 유형의 행에 관한 열 작업을 용이하게 하기 위해 연락처 제공자는 ContactsContract.CommonDataKinds의 서브클래스에 정의된 유형별 열 이름 상수도 제공합니다. 동일한 열 이름에 쉽게 구분하여 사용할 수 있는 여러 개의 상수 이름을 부여하므로 특정 유형의 행에 있는 데이터에 액세스하는 데 도움이 됩니다. 예를 들어 ContactsContract.CommonDataKinds.Email 클래스는 ContactsContract.Data 행에서 MIME 유형이 Email.CONTENT_ITEM_TYPE인 유형별 열 이름 상수를 정의합니다. 이 클래스에는 이메일 주소 열에 대해 ADDRESS 상수를 제공됩니다. ADDRESS의 실제 값은 Generic column과 동일한 'data1'입니다. data1을 유형에 따라 상수로 쉽게 구분할 수 있는 겁니다.

제공업체에서 사전 정의된 MIME 유형을 지정한 ContactsContract.Data 테이블에  자체 맞춤 데이터를 추가하지 마세요. 그렇게 하면 데이터가 손실되거나 제공자가 오작동을 일으킬 수 있습니다. 예를 들어 DATA1 열에 이메일 타입으로 지정했으면 이메일 주소를 입력해야하지 사용자 이름이 포함된 MIME 유형 Email.CONTENT_ITEM_TYPE의 행을 추가하면 안 됩니다. 행에 사용자 맞춤 MIME 유형을 사용해야 고유한 유형별 열 이름을 자유롭게 정의하고 원하는 대로 열을 사용할 수 있습니다.

그림 2는 descriptive열과 data열이 ContactsContract.Data 행에 표시되는 방식과 유형별 열 이름이 generic 열 이름에 '오버레이'되는 방식을 보여줍니다.


유형별 열 이름 클래스
표 2는 가장 보편적으로 사용되는 유형별 열 이름 클래스를 나열한 것입니다.

ContactsContract.CommonDataKinds.StructuredName	
이 데이터 행과 연결된 원시 연락처의 이름 데이터입니다.	
하나의 원시 연락처에는 이러한 행이 딱 하나만 있습니다.

ContactsContract.CommonDataKinds.Photo	
이 데이터 행과 연결된 원시 연락처의 기본 사진입니다.	
하나의 원시 연락처에는 이러한 행이 딱 하나만 있습니다.

ContactsContract.CommonDataKinds.Email	
이 데이터 행과 연결된 원시 연락처의 이메일 주소입니다.	
하나의 원시 연락처에는 여러 개의 이메일 주소가 있을 수 있습니다.

ContactsContract.CommonDataKinds.StructuredPostal	
이 데이터 행과 연결된 원시 연락처의 우편 주소입니다.	
하나의 원시 연락처에는 여러 개의 우편 주소가 있을 수 있습니다.

ContactsContract.CommonDataKinds.GroupMembership	
원시 연락처를 연락처 제공자의 그룹 중 하나와 연결하는 식별자입니다.	
그룹은 계정 유형과 계정 이름의 선택적 기능입니다.


연락처
연락처 제공자는 계정 유형과 이름으로 이루어진 모든 원시 연락처 행들을 합치고 동일 인물일 경우 합쳐서 연락처를 형성합니다. 이렇게 하면 사용자가 한 사람에 관해 수집한 모든 데이터를 쉽게 표시하고 수정할 수 있습니다. 연락처 제공자는 새로운 연락처 행의 생성과 원시 연락처를 기존 연락처 행과 합치는 작업을 관리합니다. 애플리케이션과 동기화 어댑터는 모두 연락처를 추가할 수 없으며 연락처 행의 일부 열은 읽기만 가능합니다. 이때 '읽기 전용'으로 표시된 열을 업데이트하려고 하면 업데이트가 무시됩니다. insert()를 사용하여 연락처 제공자에 연락처를 추가하려고 하면 UnsupportedOperationException 예외가 발생합니다. 

연락처 제공자는 기존 연락처와 일치하지 않는 새로운 원시 연락처가 추가되면 새 연락처를 생성합니다. 제공자는 기존 원시 연락처의 데이터가 변경되어 이전에 연결된 연락처와 더 이상 일치하지 않는 경우에도 이 작업을 실행합니다. 애플리케이션이나 동기화 어댑터가 기존 연락처와 일치하는 새로운 원시 연락처를 만들면 새로운 원시 연락처가 기존 연락처에 합쳐집니다. 

연락처 제공자는 Contacts 테이블에 있는 연락처 행의 _ID 열을 사용하여 연락처 행과 원시 연락처 행을 연결합니다. 원시 연락처 테이블 ContactsContract.RawContacts의 CONTACT_ID 열에는 각 원시 연락처 행과 연결된 연락처 행의 _ID 값이 포함됩니다.ContactsContract.Contacts 테이블에는 연락처 행에 대한 '영구' 링크인 LOOKUP_KEY 열도 있습니다. 연락처 제공자는 연락처를 자동으로 유지하므로, 집계 또는 동기화에 응답하여 연락처 행의 _ID 값을 변경할 수도 있습니다. 이 경우에도 연락처의 LOOKUP_KEY와 결합된 콘텐츠 URI인 CONTENT_LOOKUP_URI는 여전히 연락처 행을 가리키므로 LOOKUP_KEY를 사용하여 '즐겨찾기' 연락처 등에 대한 링크를 유지할 수 있습니다. 이 열에는 _ID 열의 형식과 관련이 없는 자체 형식이 있습니다. 그림 3은 세 가지 기본 테이블이 서로 연결되는 방식을 나타낸 것입니다.

 Google Play 스토어에 앱을 게시하거나 Android 10 (API 수준 29) 이상을 실행하는 기기에 앱이 있는 경우 일부 연락처 데이터 필드와 메서드들은 더 이상 사용되지 않습니다. 시스템은 아래의 데이터 필드에 작성된 값을 주기적으로 지웁니다.
ContactsContract.ContactOptionsColumns.LAST_TIME_CONTACTED
ContactsContract.ContactOptionsColumns.TIMES_CONTACTED
ContactsContract.DataUsageStatColumns.LAST_TIME_USED
ContactsContract.DataUsageStatColumns.TIMES_USED

위의 데이터 필드를 설정하는 데 사용하는 API도 사용이 중단되었습니다.
ContactsContract.Contacts.markAsContacted()
ContactsContract.DataUsageFeedback

또한 다음 필드에서는 이제 자주 사용하는 연락처를 반환하지 않습니다. 이러한 필드 중 일부는 연락처가 특정 데이터 종류의 일부인 경우에만 연락처 순위에 영향을 줍니다.
ContactsContract.Contacts.CONTENT_FREQUENT_URI
ContactsContract.Contacts.CONTENT_STREQUENT_URI
ContactsContract.Contacts.CONTENT_STREQUENT_FILTER_URI
CONTENT_FILTER_URI (Email, Phone, Callable, Contactables 데이터 종류에만 영향을 미침)
ENTERPRISE_CONTENT_FILTER_URI (Email, Phone 및 Callable 데이터 종류에만 영향을 미침)

앱에서 이러한 필드 또는 API에 액세스하거나 이를 업데이트하는 경우 다른 방법을 사용해야 합니다. 예를 들어 private 콘텐츠 제공업체 또는 앱이나 백엔드 시스템 내에 저장된 기타 데이터를 사용하여 대체하여 처리할 수 있습니다. 이 변경사항으로 인해 앱 기능이 영향을 받지 않는지 확인하려면 이러한 데이터 필드를 수동으로 지우면 됩니다. 이렇게 하려면 Android 4.1 (API 수준 16) 이상을 실행하는 기기에서 다음 ADB 명령어를 실행하세요.
adb shell content delete \
--uri content://com.android.contacts/contacts/delete_usage



동기화 어댑터의 데이터
사용자는 연락처 데이터를 기기에 직접 입력하지만 데이터는 동기화 어댑터를 통해 웹 서비스에서 연락처 제공자로 전송되어 기기와 서비스 간에 데이터 전송을 자동화합니다. 동기화 어댑터는 시스템의 제어하에 백그라운드에서 실행되며 ContentResolver 메서드를 호출하여 데이터를 관리합니다. Android에서 동기화 어댑터와 함께 작업하는 웹 서비스는 계정 유형으로 식별됩니다. 각 동기화 어댑터는 하나의 계정 유형에서 작동하지만 이러한 유형에는 여러 계정 이름을 지원할 수 있습니다. 

계정 유형
사용자가 데이터를 저장한 서비스를 식별합니다. 대부분의 경우 사용자는 서비스에 인증해야 합니다. 예를 들어 Google 주소록은 google.com 코드로 식별되는 계정 유형입니다. 이 값은 AccountManager에서 사용하는 계정 유형에 해당합니다.

계정 이름
계정 유형에 대한 특정 계정 또는 로그인을 식별합니다. Google 연락처 계정은 Google 계정과 동일합니다. 이때 Google 계정은 계정 이름으로 이메일 주소를 사용합니다. 다른 서비스에서는 단일 단어 사용자 이름 또는 숫자 ID를 사용할 수도 있습니다.

계정 유형은 고유하지 않아도 됩니다. 사용자는 여러 Google 주소록 계정을 구성하고 연락처 제공자에 데이터를 다운로드할 수 있습니다. 이는 사용자에게 개인 계정 이름으로 개인 연락처 목록이 있고 업무용으로 다른 연락처 목록이 있는 경우에 발생할 수 있습니다. 계정 이름은 일반적으로 고유합니다. 이 둘은 함께 사용되어 연락처 제공자와 외부 서비스 간의 특정 데이터 흐름을 식별합니다. 

서비스의 데이터를 연락처 제공자로 전송하려면 자체 동기화 어댑터를 작성해야 합니다. 그림 4는 연락처 제공자가 사람에 관한 데이터 흐름 속에서 어떤 위치와 역할을 하는지를 보여줍니다. "동기화 어댑터"라고 표시된 상자에서 각 어댑터는 계정 유형에 따라 이름이 지정됩니다.



필수 권한
연락처 제공자에 액세스하려는 애플리케이션은 다음 권한을 요청해야 합니다.

하나 이상의 테이블에 대한 읽기 권한
READ_CONTACTS, AndroidManifest.xml에 <uses-permission> 요소와 <uses-permission android:name="android.permission.READ_CONTACTS">로 지정됨.

하나 이상의 테이블에 대한 쓰기 권한
WRITE_CONTACTS, AndroidManifest.xml에 <uses-permission> 요소와 <uses-permission android:name="android.permission.WRITE_CONTACTS">로 지정됨.

이들 권한은 사용자 프로필 데이터와는 별개입니다. 사용자의 연락처 데이터는 개인 정보이며 민감한 정보라는 점을 기억해야 합니다. 사용자는 자신의 개인정보 보호를 중요하게 생각하므로 애플리케이션이 본인 또는 연락처에 관한 데이터를 수집하는 것을 원하지 않습니다. 사용자의 연락처 데이터에 액세스할 권한이 필요한 이유가 분명하지 않으면 애플리케이션에 낮은 평점을 매기거나 설치를 거부할 수도 있습니다.



사용자 프로필
ContactsContract.Contacts 테이블에는 기기 사용자의 프로필 데이터가 포함된 단일 행이 있습니다. 이 데이터는 사용자의 연락처 중 하나가 아니라 기기의 user를 설명합니다. 프로필 연락처 행은 프로필을 사용하는 각 시스템의 원시 연락처 행에 연결됩니다. 각 프로필 원시 연락처 행에는 여러 개의 데이터 행이 있을 수 있습니다. 사용자 프로필에 액세스하기 위한 상수는 ContactsContract.Profile 클래스에서 사용할 수 있습니다.

사용자 프로필에 액세스하려면 특수 권한이 필요합니다. 읽기와 쓰기에 필요한 READ_CONTACTS 및 WRITE_CONTACTS 권한 외에 사용자 프로필에 액세스하려면 읽기 및 쓰기 액세스에 관한 android.Manifest.permission#READ_PROFILE과 android.Manifest.permission#WRITE_PROFILE 권한이 각각 필요합니다. 사용자의 프로필은 민감한 정보로 간주해야 합니다. android.Manifest.permission#READ_PROFILE 권한을 사용하면 개발자가 기기 사용자의 개인 식별 데이터에 액세스할 수 있게 해줍니다. 애플리케이션 설명에서 사용자에게 사용자 프로필 액세스 권한이 필요한 이유를 알려야 합니다.

사용자 프로필이 포함된 연락처 행을 검색하려면 ContentResolver.query()를 호출합니다. 콘텐츠 URI를 CONTENT_URI로 설정하고 선택 기준은 제공하지 않습니다. 이 콘텐츠 URI는 원시 연락처 또는 프로필의 데이터를 검색하기 위한 기본 URI로 사용할 수도 있습니다. 예를 들어, 해당 코드는 프로필에 대한 데이터를 검색합니다.

//java
// 사용자 프로필 검색을 위한 열 설정
projection = new String[]
    {
        Profile._ID,
        Profile.DISPLAY_NAME_PRIMARY,
        Profile.LOOKUP_KEY,
        Profile.PHOTO_THUMBNAIL_URI
    };
//연락처 제공자로부터 프로필 검색
profileCursor =
        getContentResolver().query(
                Profile.CONTENT_URI,
                projection ,
                null,
                null,
                null);
//kotlin
// 사용자 프로필 검색을 위한 열 설정
projection = arrayOf(
        ContactsContract.Profile._ID,
        ContactsContract.Profile.DISPLAY_NAME_PRIMARY,
        ContactsContract.Profile.LOOKUP_KEY,
        ContactsContract.Profile.PHOTO_THUMBNAIL_URI
)

//연락처 제공자로부터 프로필 검색
profileCursor = contentResolver.query(
        ContactsContract.Profile.CONTENT_URI,
        projection,
        null,
        null,
        null
)

여러 연락처 행을 검색하고 그중 하나가 사용자 프로필인지 확인하려면 행의 IS_USER_PROFILE 열을 검사하면 됩니다. 이 열은 연락처가 사용자 프로필인 경우 '1'로 설정됩니다.



연락처 제공자 메타데이터
연락처 제공자는 저장소에 있는 연락처 데이터의 상태를 추적하는 데이터를 관리합니다. 저장소에 대한 이 메타데이터는 원시 연락처, 데이터, 연락처 테이블 행, ContactsContract.Settings 테이블, ContactsContract.SyncState 테이블 등의 다양한 위치에 저장됩니다. 다음 표는 이러한 메타데이터 각각이 미치는 영향을 보여준다

ContactsContract.RawContacts	
DIRTY	
"0" - 마지막 동기화 이후 변경되지 않습니다.
"1" - 마지막 동기화 후 변경되었으며 서버에 다시 동기화해야 합니다.
기기에서 변경되었으며 서버에 다시 동기화해야 하는 원시 연락처를 표시합니다. 이 값은 Android 애플리케이션이 행을 업데이트할 때 연락처 제공자에 의해 자동으로 설정됩니다.
원시 연락처 또는 데이터 테이블을 수정하는 동기화 어댑터는 항상 사용되는 콘텐츠 URI에 CALLER_IS_SYNCADAPTER 문자열을 추가해야 합니다. 그럼 Contacts Provider가 해당 변경을 서버에서 온 변경으로 인식하여 DIRTY 컬럼을 변경하지 않습니다. 그렇지 않으면 동기화 어댑터 수정이 로컬에서 수정된 것으로 인식하여 해당 row의 DIRTY 컬럼을 1로 설정합니다. 서버에서 수정된 거지만 다음 동기화 때 서버로 다시 전송됨. 불필요한 중복 전송 발생

ContactsContract.RawContacts	
VERSION	
이 행의 버전 번호.	
연락처 제공자는 해당 행이나 관련 데이터가 변경될 때마다 이 값을 자동으로 증가시킵니다.

ContactsContract.Data	
DATA_VERSION	
이 행의 버전 번호.	
연락처 제공자는 데이터 행이 변경될 때마다 이 값을 자동으로 증가시킵니다.

ContactsContract.RawContacts	
SOURCE_ID
해당 원시 연락처를 자신이 생성된 계정에 고유하게 식별하는 문자열 값입니다.	
동기화 어댑터가 새로운 원시 연락처를 생성하면, 이 열이 원시 연락처에 관한 서버의 고유 ID로 설정되어야 합니다. Android 애플리케이션이 새로운 원시 연락처를 만들 때 애플리케이션은 이 열을 비워 두어야 합니다. 이는 동기화 어댑터에 서버에 새로운 원시 연락처를 만들고 SOURCE_ID 값을 가져와야 한다는 신호를 보냅니다. 특히 소스 ID는 계정 유형마다 고유해야 하며 동기화 전체에서 안정적이어야 합니다.
고유: 계정의 각 원시 연락처에는 고유한 소스 ID가 있어야 합니다. 개발자가 이것을 강제 적용하지 않으면 연락처 애플리케이션에 문제를 일으킵니다. 동일한 계정 유형의 두 원시 연락처는 소스 ID가 같을 수 있습니다. 예를 들어 emily.dickinson@gmail.com 계정의 원시 연락처 'Thomas Higginson'은 emilyd@gmail.com 계정의 원시 연락처 'Thomas Higginson'과 소스 ID가 같을 수 있습니다.
안정화: 소스 ID는 원시 연락처에 관한 온라인 서비스 데이터의 영구적인 부분입니다. 예를 들어 사용자가 앱 설정에서 연락처 저장소를 삭제하고 다시 동기화하는 경우 복원된 원시 연락처의 소스 ID는 이전과 동일해야 합니다. 이를 적용하지 않으면 바로가기가 더 이상 작동하지 않습니다.

ContactsContract.Groups	
GROUP_VISIBLE	
"0" - 이 그룹의 연락처가 Android 애플리케이션 UI에 표시되면 안 됩니다.	
'1' - 이 그룹의 연락처가 애플리케이션 UI에 표시될 수 있습니다.
이 열은 사용자가 특정 그룹에 연락처를 숨길 수 있는 서버와의 호환성을 위한 것입니다.

ContactsContract.Settings	
UNGROUPED_VISIBLE	
'0' - 이 계정 유형과 계정에 대해서, 그룹에 속하지 않은 연락처는 Android 애플리케이션 UI에서 보이지 않는다.	
'1' - 이 계정 유형과 계정에 대해서, 그룹에 속하지 않은 연락처는 Android 애플리케이션 UI에서 표시됩니다.
기본적으로, 해당 연락처의 어떤 raw contact도 그룹에 속해 있지 않으면 그 연락처는 표시되지 않는다. 원시 연락처의 그룹 소속 여부는 ContactsContract.Data 테이블 안의 하나 이상의 ContactsContract.CommonDataKinds.GroupMembership row로 표시된다. ContactsContract.Settings 테이블에서 특정 계정 유형과 계정에 대한 row에 이 플래그를 설정하면, 그룹에 속하지 않은 연락처도 강제로 보이게 할 수 있다. 이 플래그의 한 가지 용도는 그룹 기능을 사용하지 않는 서버의 연락처를 표시하는 것이다.

ContactsContract.SyncState	
(모두)
이 테이블을 사용하여 동기화 어댑터의 메타데이터를 저장합니다.	
이 테이블을 사용하면 동기화 상태와 기타 동기화 관련 데이터를 기기에 영구적으로 저장할 수 있습니다.



연락처 제공자 액세스
엔터티 쿼리
Contacts Provider의 테이블들은 계층 구조로 구성되어 있기 때문에, 특정 행과 그것에 연결된 모든 "자식" 행들을 함께 가져오는 것이 유용할 때가 많습니다. 예를 들어, 어떤 사람의 모든 정보를 표시하려면 하나의 ContactsContract.Contacts 행에 해당하는 모든 ContactsContract.RawContacts 행을 가져오거나, 하나의 ContactsContract.RawContacts 행에 해당하는 모든 ContactsContract.CommonDataKinds.Email 행을 가져와야 할 수 있습니다. 이를 가능하게 하기 위해 Contacts Provider는 엔티티라는 구조를 제공하며, 이는 테이블 간의 데이터베이스 조인처럼 동작합니다.
엔티티는 부모 테이블과 자식 테이블에서 선택된 컬럼으로 구성된 테이블과 같습니다. 엔티티를 쿼리할 때는, 엔티티에서 제공하는 컬럼을 기준으로 projection과 검색 조건을 지정합니다. 결과는 Cursor로 반환되며, 여기에는 검색된 각 자식 테이블 행마다 한 줄이 포함됩니다. 예를 들어, ContactsContract.Contacts.Entity를 쿼리하여 특정 연락처 이름과 그 이름에 연결된 모든 raw contact의 ContactsContract.CommonDataKinds.Email 행을 요청하면, Cursor에는 각 이메일 행마다 하나의 row가 반환됩니다.

엔티티를 사용하면 쿼리가 단순해집니다. 엔티티를 이용하면 하나의 contact이나 raw contact에 대한 모든 연락처 데이터를 한 번에 가져올 수 있으며, 먼저 부모 테이블을 조회해 ID를 얻고, 그 ID로 다시 자식 테이블을 조회해야 하는 번거로움을 피할 수 있습니다. 또한, Contacts Provider는 엔티티에 대한 쿼리를 단일 트랜잭션으로 처리하므로, 가져온 데이터가 내부적으로 일관성을 유지합니다. 엔티티는 보통 부모와 자식 테이블의 모든 컬럼을 포함하지 않습니다. 엔티티의 컬럼 이름 상수 목록에 없는 컬럼명을 사용하려 하면 Exception이 발생합니다.

아래 코드는 하나의 contact에 대해 모든 raw contact 행을 가져오는 방법을 보여줍니다. "main"과 "detail" 두 개의 액티비티로 구성된 애플리케이션의 일부입니다. 메인 액티비티는 연락처 목록을 보여주고, 사용자가 하나를 선택하면 해당 contact의 ID를 detail 액티비티로 전달합니다. detail 액티비티는 ContactsContract.Contacts.Entity를 사용해 선택된 contact에 연결된 모든 raw contact의 데이터 행을 표시합니다. 아래 코드는 details의 activity코드입니다.

//java
...
    /*
     * URI에 엔티티 경로를 추가합니다. Contacts Provider의 경우,
     * 예상되는 URI는 content://com.google.contacts/#/entity 입니다. (#는 ID 값)
     */
    contactUri = Uri.withAppendedPath(
            contactUri,
            ContactsContract.Contacts.Entity.CONTENT_DIRECTORY);

    // LOADER_ID로 식별되는 로더 초기화
    getLoaderManager().initLoader(
            LOADER_ID,  // 초기화할 로더의 식별자
            null,       // 로더에 전달할 인자(해당 코드에는 없음)
            this);      // activity의 context

   // 리스트 뷰에 연결할 새 커서 어댑터를 생성
    cursorAdapter = new SimpleCursorAdapter(
            this,                        // activity의 context
            R.layout.detail_list_item,   // detail위젯을 포함하는 뷰 아이템
            mCursor,                     // 데이터를 제공하는 커서
            fromColumns,                //데이터를 제공하는 커서의 컬럼
            toViews,                    // 데이터를 표시할 뷰 아이템의 뷰들
            0);                          // 플래그

   // ListView의 백업 어댑터 설정
    rawContactList.setAdapter(cursorAdapter);
...
@Override
public Loader<Cursor> onCreateLoader(int id, Bundle args) {

    /*
     * 가져올 컬럼을 설정합니다.
     * RAW_CONTACT_ID는 데이터 행과 연결된 raw contact을 식별하기 위해 포함됩니다.
     * DATA1은 데이터 행의 첫 번째 컬럼을 포함하며(보통 가장 중요한 값).
     * MIMETYPE은 데이터 행의 데이터 타입을 나타냅니다.
     */
    String[] projection =
        {
            ContactsContract.Contacts.Entity.RAW_CONTACT_ID,
            ContactsContract.Contacts.Entity.DATA1,
            ContactsContract.Contacts.Entity.MIMETYPE
        };

/*
     * 조회된 커서를 raw contact id 기준으로 정렬하여,
     * 하나의 raw contact에 대한 모든 데이터 행을 모아둡니다.
     */
    String sortOrder =
            ContactsContract.Contacts.Entity.RAW_CONTACT_ID +
            " ASC";

       /*
     * 새로운 CursorLoader를 반환합니다. 인자는
     * ContentResolver.query()와 비슷하지만, Context 인자를 통해
     * 사용할 ContentResolver의 위치를 제공합니다.
     */
    return new CursorLoader(
            getApplicationContext(),  //  activity의 context
            contactUri,              // 단일 contact에 대한 엔티티 콘텐츠 URI
            projection,               // 가져올 컬럼
            null,                     // 모든 raw contact과 그 데이터 행을 가져옵니다.(selection)
            null,                     //가져올 행의 조건 바인딩의 실제 값(selectionArgs)
            sortOrder);               // raw contact ID 기준으로 정렬
}

//kotlin
/*
     * URI에 엔티티 경로를 추가합니다. Contacts Provider의 경우,
     * 예상되는 URI는 content://com.google.contacts/#/entity 입니다. (#는 ID 값)
     */
    contactUri = Uri.withAppendedPath(
            contactUri,
            ContactsContract.Contacts.Entity.CONTENT_DIRECTORY
    )

   // LOADER_ID로 식별되는 로더를 초기화합니다.
    loaderManager.initLoader(
            LOADER_ID,  // 초기화할 로더의 식별자
            null,       /// 로더에 전달할 인자(해당 코드에는 없음)
            this        //  activity의 context
    )

    // 리스트 뷰에 연결할 새 커서 어댑터를 생성
    cursorAdapter = SimpleCursorAdapter(
            this,                       //  activity의 context
            R.layout.detail_list_item,  // detail 위젯을 포함하는 뷰 아이템
            mCursor,                   // 데이터를 제공하는 커서
            fromColumns,               // 데이터를 제공하는 커서의 컬럼
            toViews,                  // 데이터를 표시할 뷰 아이템의 뷰들
            0)                          // 플래그

      // ListView의 백업 어댑터를 설정
    rawContactList.adapter = cursorAdapter
...
override fun onCreateLoader(id: Int, args: Bundle?): Loader<Cursor> {
    /*
     * 가져올 컬럼을 설정합니다.
     * RAW_CONTACT_ID는 데이터 행과 연결된 raw contact을 식별하기 위해 포함됩니다.
     * DATA1은 데이터 행의 첫 번째 컬럼을 포함하며(보통 가장 중요한 값).
     * MIMETYPE은 데이터 행의 데이터 타입을 나타냅니다.
     */
    val projection: Array<String> = arrayOf(
            ContactsContract.Contacts.Entity.RAW_CONTACT_ID,
            ContactsContract.Contacts.Entity.DATA1,
            ContactsContract.Contacts.Entity.MIMETYPE
    )

    /*
     * 조회된 커서를 raw contact id 기준으로 정렬하여,
     * 하나의 raw contact에 대한 모든 데이터 행을 모아둡니다.
     */
    val sortOrder = "${ContactsContract.Contacts.Entity.RAW_CONTACT_ID} ASC"

   /*
     * 새로운 CursorLoader를 반환합니다. 인자는
     * ContentResolver.query()와 비슷하지만, Context 인자를 통해
     * 사용할 ContentResolver의 위치를 제공합니다.
     */
    return CursorLoader(
            applicationContext, // activity의 context
            contactUri,        // 단일 contact에 대한 엔티티 콘텐츠 URI
            projection,         // 가져올 컬럼
            null,               // 모든 raw contact과 그 데이터 행을 가져옵니다.(selection)
            null,               //가져올 행의 조건 바인딩의 실제 값(selectionArgs)
            sortOrder          // raw contact ID 기준으로 정렬
    )
}

로드가 완료되면 LoaderManager에서 onLoadFinished() 콜백을 호출합니다. 이 메서드로 수신되는 인수 중 하나는 쿼리 결과가 포함된 Cursor입니다. 자체 앱에서는 이 Cursor에서 데이터를 가져와 표시하거나 추가로 작업할 수 있습니다.


배치 수정
개념
가능하면 ContentProviderOperation 객체 타입의 ArrayList를 생성하고 applyBatch()를 호출하여 연락처 제공자의 데이터를 '배치 모드'로 삽입, 업데이트 및 삭제해야 합니다. 연락처 제공자가 applyBatch()의 모든 작업을 단일 트랜잭션으로 실행하므로 수정사항으로 인해 연락처 저장소가 일관되지 않은 상태로 남아 있지 않습니다. 배치 수정을 사용하면 원시 연락처와 그 세부 데이터를 동시에 삽입하는 것도 용이합니다. 만약 단일 원시 연락처를 수정하려면 앱에서 수정을 직접 처리하는 대신 기기의 연락처 애플리케이션으로 인텐트를 전송하는 것이 좋습니다.

Yield 지점
많은 수의 작업이 포함된 일괄 수정은 다른 프로세스를 차단하여 전반적인 사용자 환경을 저하할 수 있습니다. 실행하고자 하는 모든 수정사항을 가능한 한 적은 수의 별도 목록에 정리하고 이와 동시에 시스템이 차단되지 않도록 하려면 하나 이상의 작업에 yield 지점를 설정해야 합니다. Yield 지점은 isYieldAllowed() 값이 true로 설정된 ContentProviderOperation 객체입니다. 연락처 제공자가 Yield 지점을 만나면 다른 프로세스가 실행되도록 작업을 일시 중지하고 현재 트랜잭션을 닫습니다. 제공자가 다시 시작되면 ArrayList에서 다음 작업을 계속 진행하고 새 트랜잭션을 시작합니다.
Yield 포인트를 설정하면 applyBatch() 한 번 호출 시에도 여러 트랜잭션이 발생할 수 있다.
따라서 관련된 row 집합의 마지막 작업에 yield 포인트를 설정하는 것이 좋다.
예를 들어, 하나의 raw contact와 그에 연결된 데이터(row)들을 추가하는 작업 집합에서는 마지막 작업에 yield 포인트를 설정하거나, 단일 contact와 관련된 row 집합의 마지막 작업에 yield 포인트를 설정해야 한다.
Yield 포인트는 또한 원자적 연산 단위이기도 하다. 두 yield 포인트 사이의 모든 접근은 하나의 단위로서 성공하거나 실패한다. yield 포인트를 전혀 설정하지 않으면, 연산 단위는 배치 전체가 된다. 연산 단위는 가장 작은 원자적 단위로 의미가 없게 된다. yield 포인트를 사용하면, 연산이 시스템 성능을 저하시키는 것을 방지하면서도 연산의 일부 집합이 원자적으로 처리되도록 할 수 있다.

수정 역참조
새로운 raw contact row와 그에 연결된 데이터(row)들을 ContentProviderOperation 객체 집합으로 삽입할 때, 데이터 row를 raw contact row에 연결하려면 raw contact의 _ID 값을 RAW_CONTACT_ID 칼럼에 넣어야 한다. 그러나 데이터 row를 위한 ContentProviderOperation을 만들 때는, 아직 raw contact row를 실행하기 전이기 때문에 ID 값이 생성되지 않아서 사용할 수 없다. 이를 해결하기 위해 ContentProviderOperation.Builder 클래스에는 withValueBackReference() 메서드가 있다. 이 메서드를 사용하면 같은 배치 작업에 포함된 이전 작업의 실행 값을 사용할 수 있기 때문에 해당 결과 값의 ID를 참조하여  컬럼을 삽입하거나 수정할 수 있다.
withValueBackReference() 메서드에는 두 가지 인수가 있습니다.
key
키-값 쌍의 키입니다. 이 인수의 값은 수정 중인 테이블의 열 이름이어야 합니다.
previousResult
applyBatch()의 ContentProviderResult 객체 배열에 있는 값의 0 기반 인덱스입니다. 배치 작업이 적용되면 각 작업의 결과가 임시 배열에 저장됩니다. previousResult은 이러한 결과 중 어느 인덱스의 값이며 key 값을 사용하여 검색 및 저장됩니다. 이렇게 하면 새 원시 연락처행을 삽입하고 _ID 값을 반환하여 다음 ContactsContract.Data 행을 추가할 때 해당 값을 '역참조'할 수 있습니다. applyBatch()를 처음 호출하면 사용자가 제공하는 ContentProviderOperation 객체의 ArrayList 크기와 같은 크기로 전체 결과 배열이 생성됩니다. 그러나 결과 배열의 모든 요소는 null로 설정되며, 아직 적용되지 않은 작업의 결과를 역참조하려고 하면 withValueBackReference()에서 예외가 발생합니다.
다음 예제는 새로운 원시 연락처와 데이터를 일괄 삽입하는 방법을 보여줍니다. 양보 지점을 설정하고 역참조를 사용하는 코드가 포함되어 있습니다. 
첫 번째 코드는 UI에서 연락처 데이터를 검색합니다. 이 시점에서 사용자는 이미 새 원시 연락처를 추가할 계정을 선택했습니다.
// 현재 선택한 계정을 사용하여 현재 UI 값에서 연락처 항목 생성
protected void createContactEntry() {
    /*
     * UI에서 값 얻기
     */
    String name = contactNameEditText.getText().toString();
    String phone = contactPhoneEditText.getText().toString();
    String email = contactEmailEditText.getText().toString();

    int phoneType = contactPhoneTypes.get(
            contactPhoneTypeSpinner.getSelectedItemPosition());

    int emailType = contactEmailTypes.get(
            contactEmailTypeSpinner.getSelectedItemPosition());
// 현재 선택한 계정을 사용하여 현재 UI 값에서 연락처 항목 생성
private fun createContactEntry() {
    /*
     * UI에서 값 얻기
     */
    val name = contactNameEditText.text.toString()
    val phone = contactPhoneEditText.text.toString()
    val email = contactEmailEditText.text.toString()

    val phoneType: String = contactPhoneTypes[mContactPhoneTypeSpinner.selectedItemPosition]

    val emailType: String = contactEmailTypes[mContactEmailTypeSpinner.selectedItemPosition]
다음 코드는 ContactsContract.RawContacts 테이블에 원시 연락처 행의 삽입 연산을 만듭니다.
    /*
     * 새로운 raw contact와 그에 연결된 데이터를 삽입하기 위한 배치 작업을 준비
     * 이 사람에 대한 데이터가 Contacts Provider에 전혀 없더라도, 직접 추가할 수 있는 것은 
     * Contact이 아니라 raw contact뿐 이후 Contacts Provider가 자동으로 Contact을 추가
     */
     // ContentProviderOperation 객체 타입의 새 배열 생성
    ArrayList<ContentProviderOperation> ops =
            new ArrayList<ContentProviderOperation>();
    /*
     * 계정 유형(서버 유형)과 계정 이름(사용자 계정)으로 새로운 원시 연락처 생성
    * 표시 이름은 이 행에 저장되지 않고 StructuredName 데이터 행에 저장
    * 다른 데이터는 필요하지 않음
     */
    ContentProviderOperation.Builder op =
            ContentProviderOperation.newInsert(ContactsContract.RawContacts.CONTENT_URI)
            .withValue(ContactsContract.RawContacts.ACCOUNT_TYPE, selectedAccount.getType())
            .withValue(ContactsContract.RawContacts.ACCOUNT_NAME, selectedAccount.getName());

    // 연산 구축 후 연산 배열에 추가
    ops.add(op.build());
    /*
     * 새로운 raw contact와 그에 연결된 데이터를 삽입하기 위한 배치 작업을 준비
     * 이 사람에 대한 데이터가 Contacts Provider에 전혀 없더라도, 직접 추가할 수 있는 것은 
     * Contact이 아니라 raw contact뿐 이후 Contacts Provider가 자동으로 Contact을 추가
     */
    // ContentProviderOperation 객체 타입의 새 배열 생성
    val ops = arrayListOf<ContentProviderOperation>()

   /*
     * 계정 유형(서버 유형)과 계정 이름(사용자 계정)으로 새로운 원시 연락처 생성
    * 표시 이름은 이 행에 저장되지 않고 StructuredName 데이터 행에 저장
    * 다른 데이터는 필요하지 않음
     */
    var op: ContentProviderOperation.Builder =
            ContentProviderOperation.newInsert(ContactsContract.RawContacts.CONTENT_URI)
                    .withValue(ContactsContract.RawContacts.ACCOUNT_TYPE, selectedAccount.name)
                    .withValue(ContactsContract.RawContacts.ACCOUNT_NAME, selectedAccount.type)

   // 연산 구축 후 연산 배열에 추가
    ops.add(op.build())
그런 다음 코드에 표시 이름, 전화 및 이메일 행에 대한 데이터 행을 생성합니다.
각 연산 빌더 객체는 withValueBackReference()를 사용하여 RAW_CONTACT_ID를 가져옵니다. 원시 연락처 행을 추가하면 새 _ID는 값을 생성하는 첫 번째 연산에서 얻는 ContentProviderResult 객체는 ID값을 참조합니다. 따라서 각 데이터 행은 RAW_CONTACT_ID에 의해 자신이 속한 새로운 ContactsContract.RawContacts 행에 자동으로 연결됩니다. 이메일 행을 추가하는 ContentProviderOperation.Builder 객체는 withYieldAllowed()를 통해 yield 지점을 설정합니다.
    // StructuredName data으로 새로 삽입하는 원시 연락처 행의 표시 이름 설정
    op =
            ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI)
            /*
             * withValueBackReference는 두번째 인자로 ContentProviderResult 인덱스 값을 받아 
             * 해당 값을 첫번째 인자에 부여
             *  해당 코드에서 StructuredName 데이터의 원시 연락처 ID 열은
             *  원시 연락처 행을 추가하는 첫 번째 연산에서 반환된 결과 값으로 설정.
             */
            .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, 0)

            // data열의 MIME 타입에 StructuredName으로 설정
            .withValue(ContactsContract.Data.MIMETYPE,
                    ContactsContract.CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE)

            //data 열의 표시 이름에 UI에 있는 이름으로 설정
            .withValue(ContactsContract.CommonDataKinds.StructuredName.DISPLAY_NAME, name);

    //연산 구축 후 연산 배열에 추가
    ops.add(op.build());

    // 특정 휴대폰 번호와 Phone data 행에서의 유형 삽입
    op =
            ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI)
             //배치의 첫번째 연산에서 얻은 새로운 원시 연락처 ID을 원시 연락처 id열에 설정         
            .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, 0)
            // data행의 MIME유형을 Phone으로 설정
            .withValue(ContactsContract.Data.MIMETYPE,
                    ContactsContract.CommonDataKinds.Phone.CONTENT_ITEM_TYPE)
            //휴대폰 번호와 유형 설정
            .withValue(ContactsContract.CommonDataKinds.Phone.NUMBER, phone)
            .withValue(ContactsContract.CommonDataKinds.Phone.TYPE, phoneType);

    //연산 구축 후 연산 배열에 추가
    ops.add(op.build());

    // 특정 이메일과 Phone data 행에서의 유형 삽입
    op =
            ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI)
            //배치의 첫번째 연산에서 얻은 새로운 원시 연락처 ID을 원시 연락처 id열에 설정 
            .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, 0)

            // data행의 MIME유형을 Email으로 설정
            .withValue(ContactsContract.Data.MIMETYPE,
                    ContactsContract.CommonDataKinds.Email.CONTENT_ITEM_TYPE)

            //이메일 주소와 유형 설정
            .withValue(ContactsContract.CommonDataKinds.Email.ADDRESS, email)
            .withValue(ContactsContract.CommonDataKinds.Email.TYPE, emailType);

    /*
     * 양보 지점 설정. 해당 삽입이 끝나면 
     * 배치 작업의 스레드가 다른 스레드보다 우선순위를 갖게 됨.  
     * 하나의 연락처에 영향을 주는 일련의 작업 집합을 처리한 뒤에는 
     * 항상 이 메소드를 사용하여 성능 저하 방지.
     */
    op.withYieldAllowed(true);
    //연산 구축 후 연산 배열에 추가
    ops.add(op.build());

마지막 코드는 새로운 원시 연락처와 데이터 행을 삽입하는 applyBatch() 호출을 보여줍니다.

//java
    // 연락처 제공자에게 새로운 연락처 생성 요청
    Log.d(TAG,"Selected account: " + selectedAccount.getName() + " (" +
            selectedAccount.getType() + ")");
    Log.d(TAG,"Creating contact: " + name);

    /*
     * 배치에서 ContentProviderOperation 객체 타입의 배열 적용. 
     * 해당 결과 값 사용X
     */
    try {
            getContentResolver().applyBatch(ContactsContract.AUTHORITY, ops);
    } catch (Exception e) {

            // 경고 표시
            Context ctx = getApplicationContext();

            CharSequence txt = getString(R.string.contactCreationFailure);
            int duration = Toast.LENGTH_SHORT;
            Toast toast = Toast.makeText(ctx, txt, duration);
            toast.show();

            // 예외 로그출력
            Log.e(TAG, "Exception encountered while inserting contact: " + e);
    }
}
//kotlin
    // 연락처 제공자에게 새로운 연락처 생성 요청
    Log.d(TAG, "Selected account: ${mSelectedAccount.name} (${mSelectedAccount.type})")
    Log.d(TAG, "Creating contact: $name")

    /*
     * 배치에서 ContentProviderOperation 객체 타입의 배열 적용. 
     * 해당 결과 값 사용X
     */
    try {
        contentResolver.applyBatch(ContactsContract.AUTHORITY, ops)
    } catch (e: Exception) {
        // 경고 표시
        val txt: String = getString(R.string.contactCreationFailure)
        Toast.makeText(applicationContext, txt, Toast.LENGTH_SHORT).show()

        // 예외 로그출력
        Log.e(TAG, "Exception encountered while inserting contact: $e")
    }
}

낙관적 동시 실행 제어
일괄 연산을 사용하면 기본 저장소를 잠그지 않은 채 수정 트랜잭션을 적용하는 방법인 낙관적 동시 실행 제어를 구현할 수 있습니다. 한 사용자가 데이터를 읽을 때 lock을 걸어 동시 수정을 막는 비관적 동시성 제어와 달리 낙관적 동시성 제어는 lock 설정을 하지 않아 데이터를 수정할 때 다른 사용자에 의해 변경되었는지 검사하는 방식입니다. 그렇기 때문에 해당 기능을 사용하려면 트랜잭션을 적용한 다음 동시 적용에 의한 다른 수정이 있는지 확인해야 합니다. 일관되지 않은 수정이 발견하면 트랜잭션을 롤백하고 다시 시도합니다. 낙관적 동시 실행 제어는 한 번에 한 명의 사용자만 존재하고 데이터 저장소에 대한 동시 접근이 거의 없는 휴대기기에 유용합니다. 잠금을 사용하지 않으므로 잠금을 설정하거나 다른 트랜잭션이 잠금을 해제하기를 기다리면서 시간을 낭비하지 않아도 됩니다.
단일 ContactsContract.RawContacts 행을 업데이트하는 동안 낙관적 동시 실행 제어를 사용하려면 다음 단계를 따라야 합니다.
1.검색하려는 데이터와 해당 원시 연락처의 VERSION 열을 검색합니다.
2.newAssertQuery(Uri) 메서드를 사용하여 제약 조건을 적용하는 데 적합한 ContentProviderOperation.Builder 객체를 만듭니다. 콘텐츠 URI는 RawContacts.CONTENT_UR에 원시 연락처의 _ID를 추가하여 사용합니다.
3.ContentProviderOperation.Builder 객체에 withValue()를 호출하여 VERSION 열과 방금 검색한 버전 번호를 비교합니다.
4. newAssertQuery로 생성한 ContentProviderOperation.Builder에 withExpectedCount()를 호출하여 이 assertion에서 쿼리의 결과로 하나의 행만 반환하는 걸 검사합니다. 잘못된 쿼리나 상황으로 여러 개의 열이 반환되면 동기화 충돌 위험이 있기에 해당 조건을 걸어 OperationApplicationException을 발생시킵니다.
5.build()를 호출하여 ContentProviderOperation 객체를 만든 다음 이 객체를 applyBatch()에 전달하는 ArrayList의 첫 번째 객체로 추가합니다.
6.일괄 트랜잭션을 적용합니다.
행을 읽은 시점과 행을 수정하려고 시도하는 시점 사이에 원시 연락처 행을 업데이트하는 다른 연산이 발생하면, 'assert' ContentProviderOperation가 실패하고 전체 배치 작업이 취소됩니다. 그러면 일괄 작업을 다시 시도하거나 다른 조치를 취할 수 있습니다.
다음 코드에서는 CursorLoader를 사용하여 단일 원시 연락처를 쿼리한 후 'assertion' ContentProviderOperation를 만드는 방법을 보여줍니다.
//java
/*
 * 애플리케이션에서는 원시 연락처 테이블에 쿼리하기 위해 CursorLoader 사용
 *  시스템에서 해당 메서드를 load가 끝날 때 호출
 */
public void onLoadFinished(Loader<Cursor> loader, Cursor cursor) {
    // 원시 연락처의 _ID와 VERSION 값 얻기
    rawContactID = cursor.getLong(cursor.getColumnIndex(BaseColumns._ID));
    mVersion = cursor.getInt(cursor.getColumnIndex(SyncColumns.VERSION));
}

...

// assert 연산을위한 Uri 설정
Uri rawContactUri = ContentUris.withAppendedId(RawContacts.CONTENT_URI, rawContactID);

// assert 연산 빌더 생성
ContentProviderOperation.Builder assertOp = ContentProviderOperation.newAssertQuery(rawContactUri);

// assertions에 assert 연산 추가. 테스트할 열의 개수와 version과 검사
assertOp.withValue(SyncColumns.VERSION, mVersion);
assertOp.withExpectedCount(1);

//ContentProviderOperation 객체를 담을 ArrayList 생성
ArrayList ops = new ArrayList<ContentProviderOperation>;

ops.add(assertOp.build());

//ops에 원하는 배치 연산 추가 가능

...

// 배치 적용. assert가 실패하면 예외 발생
try
    {
        ContentProviderResult[] results =
                getContentResolver().applyBatch(AUTHORITY, ops);

    } catch (OperationApplicationException e) {

        //assert 연산이 실패할 때 원하는 동작 작동
    }
//kotlin
/*
 * 애플리케이션에서는 원시 연락처 테이블에 쿼리하기 위해 CursorLoader 사용
 *  시스템에서 해당 메서드를 load가 끝날 때 호출
 */
override fun onLoadFinished(loader: Loader<Cursor>, cursor: Cursor) {
    // 원시 연락처의 _ID와 VERSION 값 얻기
    rawContactID = cursor.getLong(cursor.getColumnIndex(BaseColumns._ID))
    mVersion = cursor.getInt(cursor.getColumnIndex(SyncColumns.VERSION))
}

...

// assert 연산을위한 Uri 설정
val rawContactUri: Uri = ContentUris.withAppendedId(
        ContactsContract.RawContacts.CONTENT_URI,
        rawContactID
)

// assert 연산 빌더 생성
val assertOp: ContentProviderOperation.Builder =
        ContentProviderOperation.newAssertQuery(rawContactUri).apply {
            //assertions에 assert 연산 추가. 테스트할 열의 개수와 version과 검사
            withValue(SyncColumns.VERSION, mVersion)
            withExpectedCount(1)
        }

//ContentProviderOperation 객체를 담을 ArrayList 생성
val ops = arrayListOf<ContentProviderOperation>()

ops.add(assertOp.build())

//ops에 원하는 배치 연산 추가 가능

...

// 배치 적용. assert가 실패하면 예외 발생
try {
    val results: Array<ContentProviderResult> = contentResolver.applyBatch(AUTHORITY, ops)
} catch (e: OperationApplicationException) {
    //assert 연산이 실패할 때 원하는 동작 작동
}


인텐트를 통한 검색과 수정
기기에 있는 연락처 애플리케이션에 인텐트를 전송하면 연락처 제공자에 간접적으로 접근할 수 있습니다. 이 인텐트는 사용자가 연락처 관련 작업을 할 수 있는 기기에 있는 연락처 애플리케이션 UI를 시작합니다. 사용자가 인텐트로 접근할 때 할 수 있는 일은 다음과 같습니다.

- 목록에서 연락처를 선택하면 추가 작업을 위해 앱에 전달.
- 기존 연락처의 데이터 수정
- 새 원시 데이터에 해당되는 계정 중 아무 곳에나 삽입.
- 연락처 또는 연락처 데이터 삭제.

사용자가 현재 입력, 수정 중인 값을 최종적으로 적용되기 전에 인텐트의 일부로 전송할 수 있습니다. 인텐트를 통해 기기의 연락처 애플리케이션으로 연락처 제공자에 접근하면, 제공자에 접근하기 위한 고유한 UI나 코드를 작성할 필요가 없습니다. 또한 제공자에 대한 읽기 또는 쓰기 권한을 요청할 필요도 없습니다. 기기의 연락처 애플리케이션에서 연락처에 관한 읽기 권한을 위임할 수 있고 다른 애플리케이션을 통해 제공자를 수정하므로 쓰기 권한도 필요하지 않기 때문입니다. 

제공자에 접근하기 위해 인텐트를 전송하는 기본 과정은 다음을 참고하세요.  
https://velog.io/@miniji/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-4%EB%8C%80-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-Content-Provider1content-provider#2intent-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%97%90-%EC%A0%91%EA%B7%BC

사용할 수 있는 action, MIME 유형 및 데이터 값은 표에 요약되어 있습니다.

목록에서 연락처 선택/ACTION_PICK/ Contacts.CONTENT_URI: 연락처 목록 표시, Phone.CONTENT_URI: 원시 연락처의 전화번호 목록을 표시, StructuredPostal.CONTENT_URI: 원시 연락처의 우편 주소 목록을 표시, Email.CONTENT_URI: 원시 연락처의 이메일 주소 목록을 표시/ 사용되지 않음/ 개발자가 제공하는 콘텐츠 URI 유형에 따라 원시 연락처 목록 또는 원시 연락처의 데이터 목록을 표시. 선택한 행의 콘텐츠 URI를 반환하는 startActivityForResult()를 호출. URI 형식은 테이블의 콘텐츠 URI에 행의 LOOKUP_ID가 추가된 형태. 기기의 연락처 앱은 activity 수명 동안 이 콘텐츠 URI에 읽기 및 쓰기 권한을 위임
새 원시 연락처 삽입/Insert.ACTION/해당 사항 없음/RawContacts.CONTENT_TYPE: 여러 원시 연락처의 MIME 유형./ 기기의 연락처 애플리케이션에 연락처 추가 화면을 표시. 인텐트에 추가한 extra 값이 화면에 표시. 이 인텐트를 startActivityForResult()와 함께 보내면, 새로 추가된 raw contact의 콘텐츠 URI가 onActivityResult() 콜백 메서드의 Intent 인자의 "data" 필드에 담겨서 activity로 되돌옴. 이 값을 가져오려면 getData() 호출
연락처 수정/ACTION_EDIT/ 연락처의 ACTION_EDIT/ 편집기 activity를 통해 사용자는 해당 연락처와 연관된 데이터 편집 가능/Contacts.CONTENT_ITEM_TYPE, 단일 연락처/연락처 애플리케이션에 연락처 편집 화면 표시. 인텐트에 추가한 extra 값이 화면에 표시. 사용자가 완료를 클릭하여 수정사항을 저장하면 activity 포그라운드로 돌아옴
데이터를 추가할 수 있는 선택 도구를 표시/ACTION_INSERT_OR_EDIT/해당 사항 없음/CONTENT_ITEM_TYPE/이 인텐트는 항상 연락처 앱의 선택 도구 화면을 표시. 사용자는 수정할 연락처또는 새 연락처 추가 가능. 사용자의 선택에 따라 수정 또는 추가 화면이 표시. 개발자가 인텐트에 추가한 extra 값이 화면에 표시. 앱이 이메일이나 전화번호와 같은 연락처 데이터를 표시하는 경우 이 인텐트를 사용하면 사용자가 기존 연락처에 데이터를 추가 가능. 이 인텐트의 extra에서는 개발자가 직접 이름 값을 전송하지 않아도 됨. 사용자가 항상 기존 이름을 선택하거나 새 이름을 추가하기 때문. 또한 개발자가 이름을 전송하고 사용자가 수정을 선택하면 연락처 앱은 개발자가 보낸 이름을 표시하여 기존의 저장된 값을 덮어씀. 사용자가 이를 인식하지 못하고 수정사항을 저장하면 기존 값은 손실.

인텐트를 사용하여 원시 연락처 또는 그 데이터를 삭제할 수 없습니다. 대신 원시 연락처를 삭제하려면 ContentResolver.delete() 또는 ContentProviderOperation.newDelete()를 사용해야 합니다.

putExtra()와 함께 사용할 수 있는 추가 값은 ContactsContract.Intents.Insert 문서를 참고하세요.
https://developer.android.com/reference/android/provider/ContactsContract.Intents.Insert

다음 코드는 새로운 원시 연락처와 데이터를 삽입하는 인텐트를 구성하고 전송하는 방법을 보여줍니다.
//java
// UI에서 값 얻기
String name = contactNameEditText.getText().toString();
String phone = contactPhoneEditText.getText().toString();
String email = contactEmailEditText.getText().toString();

String company = companyName.getText().toString();
String jobtitle = jobTitle.getText().toString();

// 기기의 연락처 앱에 보낼 새로운 인텐트 생성
Intent insertIntent = new Intent(ContactsContract.Intents.Insert.ACTION);

// activity에서 삽입할 거 같은 MIME타입 설정
insertIntent.setType(ContactsContract.RawContacts.CONTENT_TYPE);

//삽입할 연락처 이름 설정
insertIntent.putExtra(ContactsContract.Intents.Insert.NAME, name);

//삽입할 회사와 직업 이름  설정
insertIntent.putExtra(ContactsContract.Intents.Insert.COMPANY, company);
insertIntent.putExtra(ContactsContract.Intents.Insert.JOB_TITLE, jobtitle);

/*
 * DATA 키와 연결된 ArrayList 형태로 데이터 행들을 추가하는 방법
 */

// 각 열에 ContentValues 객체를 포함하는 array list 정의
ArrayList<ContentValues> contactData = new ArrayList<ContentValues>();


/*
 * 원리 연락처 열 정의
 */

// ContentValues 객체 타입의 열 설정
ContentValues rawContactRow = new ContentValues();

// 열에 계정 타입과 이름 추가
rawContactRow.put(ContactsContract.RawContacts.ACCOUNT_TYPE, selectedAccount.getType());
rawContactRow.put(ContactsContract.RawContacts.ACCOUNT_NAME, selectedAccount.getName());

// array에 열 추가
contactData.add(rawContactRow);

/*
 * 휴대폰 번호 데이터 열 설정
 */

//ContentValues 객체 타입의 열 설정
ContentValues phoneRow = new ContentValues();

//해당 데이터 행에 대한 MIME 유형을 지정(모든 데이터 행은 유형별로 표시해야 함)
phoneRow.put(
        ContactsContract.Data.MIMETYPE,
        ContactsContract.CommonDataKinds.Phone.CONTENT_ITEM_TYPE
);

//행에 전화번호와 전화번호의 유형 추가
phoneRow.put(ContactsContract.CommonDataKinds.Phone.NUMBER, phone);

// array에 열 추가
contactData.add(phoneRow);

/*
 * 이메일 데이터 열 설정
 */

//ContentValues 객체 타입의 열 설정
ContentValues emailRow = new ContentValues();

//해당 데이터 행에 대한 MIME 유형을 지정(모든 데이터 행은 유형별로 표시해야 함)
emailRow.put(
        ContactsContract.Data.MIMETYPE,
        ContactsContract.CommonDataKinds.Email.CONTENT_ITEM_TYPE
);

//행에 이메일과 이메일의 유형 추가
emailRow.put(ContactsContract.CommonDataKinds.Email.ADDRESS, email);

// array에 열 추가
contactData.add(emailRow);

/*
 * array에 인텐트 extra추가. 프로세스 간 전달에서는 parcelable 객체 사용 필수
 * 기기의 연락처 앱에서의 키는 Intents.Insert.DATA
 */
insertIntent.putParcelableArrayListExtra(ContactsContract.Intents.Insert.DATA, contactData);

// 연락처를 추가하는 activity에서 인텐트를 전송할 연락처 앱 실행
startActivity(insertIntent);
//koltin
// UI에서 값 얻기
val name = contactNameEditText.text.toString()
val phone = contactPhoneEditText.text.toString()
val email = contactEmailEditText.text.toString()

val company = companyName.text.toString()
val jobtitle = jobTitle.text.toString()

/*
 * DATA 키와 연결된 ArrayList 형태로 데이터 행들을 추가하는 방법
 */
// 각 열에 ContentValues 객체를 포함하는 array list 정의
val contactData = arrayListOf<ContentValues>()

/*
 * 원시 연락처 열 정의
 */

// ContentValues 객체 타입의 열 설정
val rawContactRow = ContentValues().apply {
    // 열에 계정 타입과 이름 추가
    put(ContactsContract.RawContacts.ACCOUNT_TYPE, selectedAccount.type)
    put(ContactsContract.RawContacts.ACCOUNT_NAME, selectedAccount.name)
}

// array에 열 추가
contactData.add(rawContactRow)

/*
 * 휴대폰 번호 데이터 열 설정
 */

//ContentValues 객체 타입의 열 설정
val phoneRow = ContentValues().apply {
    //해당 데이터 행에 대한 MIME 유형을 지정(모든 데이터 행은 유형별로 표시해야 함) put(ContactsContract.Data.MIMETYPE,ContactsContract.CommonDataKinds.Phone.CONTENT_ITEM_TYPE)

    //행에 전화번호와 전화번호의 유형 추가
    put(ContactsContract.CommonDataKinds.Phone.NUMBER, phone)
}

// array에 열 추가
contactData.add(phoneRow)

/*
 * 이메일 데이터 열 설정
 */

//ContentValues 객체 타입의 열 설정
val emailRow = ContentValues().apply {
    //해당 데이터 행에 대한 MIME 유형을 지정(모든 데이터 행은 유형별로 표시해야 함)
    put(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.Email.CONTENT_ITEM_TYPE)

    //행에 이메일과 이메일의 유형 추가
    put(ContactsContract.CommonDataKinds.Email.ADDRESS, email)
}

// array에 열 추가
contactData.add(emailRow)

// 기기의 연락처 앱에 보낼 새로운 인텐트 생성
val insertIntent = Intent(ContactsContract.Intents.Insert.ACTION).apply {
    // activity에서 삽입할 거 같은 MIME타입 설정
    type = ContactsContract.RawContacts.CONTENT_TYPE

    //삽입할 연락처 이름 설정
    putExtra(ContactsContract.Intents.Insert.NAME, name)

    //삽입할 회사와 직업 이름  설정
    putExtra(ContactsContract.Intents.Insert.COMPANY, company)
    putExtra(ContactsContract.Intents.Insert.JOB_TITLE, jobtitle)

    /*
     * array에 인텐트 extra추가. 프로세스 간 전달에서는 parcelable 객체 사용 필수
     * 기기의 연락처 앱에서의 키는 Intents.Insert.DATA
     */
    putParcelableArrayListExtra(ContactsContract.Intents.Insert.DATA, contactData)
}

// 연락처를 추가하는 activity에서 인텐트를 전송할 연락처 앱 실행
startActivity(insertIntent)


데이터 무결성
연락처 저장소에는 사용자가 정확하고 최신일 거라고 예상하는 중요하고 민감한 데이터가 포함되어 있으므로, 연락처 제공자에는 데이터 무결성에 관해 잘 정의된 규칙이 있습니다. 개발자는 연락처 데이터를 수정할 때 이러한 규칙을 준수해야 합니다. 중요한 규칙은 다음과 같습니다.
- 추가하는 모든 ContactsContract.RawContacts 행에 항상 ContactsContract.CommonDataKinds.StructuredName 행을 추가: 
ContactsContract.Data 테이블에 ContactsContract.CommonDataKinds.StructuredName 행이 없는 ContactsContract.RawContacts 행은 집계 중에 문제를 일으킬 수 있음
- 항상 새 ContactsContract.Data 행을 상위 ContactsContract.RawContacts 행에 연결: ContactsContract.RawContacts에 연결되지 않은 ContactsContract.Data 행은 기기의 연락처 애플리케이션에 표시되지 않으며 동기화 어댑터에 문제를 일으킬 수 있음
- 개발자 본인 소유인 원시 연락처에 대한 데이터만 변경: 연락처 제공자는 일반적으로 여러 다양한 계정 유형/온라인 서비스에서 가져온 데이터를 관리한다는 사실에 유의 필요. 애플리케이션이 사용자에게 속한 행의 데이터만 수정하거나 삭제하도록 해야 하며, 개발자가 제어하는 계정 유형 및 이름으로만 데이터 삽입
- 권한, 콘텐츠 URI, URI 경로, 열 이름, MIME 유형 및 TYPE 값에는 항상 ContactsContract 및 서브클래스에 정의된 상수를 사용: 상수를 사용하면 오류를 방지하는 데 도움. 또한 지원 중단된 상수가 있는 경우 컴파일러 경고가 전송


맞춤 데이터 행
사용자 정의 MIME 타입을 생성하고 사용하면, ContactsContract.Data 테이블에 자신만의 데이터 행을 삽입·수정·삭제·조회할 수 있습니다. Generic column 이름에 대해 자체적으로 정의한 타입별 컬럼 이름을 매핑할 수 있지만 사용자 정의 행들은 ContactsContract.DataColumns에 정의된 컬럼만 사용할 수 있도록 제한됩니다. 기기 기본 연락처 앱에서는 이 데이터가 표시되지만, 수정·삭제할 수 없으며 사용자가 추가 데이터를 넣을 수도 없습니다. 사용자가 맞춤 데이터 행을 수정할 수 있게 하려면, 개발자가 자신의 앱 안에서 편집 activity를 직접 제공해야 합니다.

맞춤 데이터를 표시하려면 <ContactsAccountType> 요소와 하나 이상의 <ContactsDataKind> 하위 요소가 포함된 contacts.xml 파일을 생성해야 합니다.

맞춤 MIME 유형에 관해 자세히 보려면 다음을 참고하세요
https://velog.io/@miniji/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-4%EB%8C%80-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-Content-Provider2content-provider-%EC%83%9D%EC%84%B1#5-contentprovider-mime-%EC%9C%A0%ED%98%95-%EA%B5%AC%ED%98%84



연락처 제공자 동기화 어댑터
연락처 제공자는 기기와 온라인 서비스 간에 연락처 데이터의 동기화를 처리하도록 특별히 설계되었습니다. 이렇게 하면 사용자가 기존 데이터를 새 기기에 다운로드하고 기존 데이터를 새 계정에 업로드할 수 있습니다. 또한 동기화를 사용하면 추가나 변경의 출처와 관계없이 사용자가 최신 데이터를 사용할 수 있습니다. 동기화의 또 다른 장점은 기기가 네트워크에 연결되어 있지 않아도 연락처 데이터를 사용할 수 있다는 것입니다. 

다양한 방식으로 동기화를 구현할 수 있지만 Android 시스템에서는 다음 작업을 자동화하는 플러그인 동기화 프레임워크를 제공합니다.
- 네트워크 가용성 확인
- 사용자 기본 설정에 따라 동기화를 예약하고 실행
- 중단된 동기화 재시작

이 프레임워크를 사용하려면 개발자가 동기화 어댑터 플러그인을 직접 제공해야 합니다. 동기화 어댑터는 서비스와 콘텐츠 제공자마다 다르지만 동일한 서비스에 여러 계정 이름을 처리할 수 있습니다. 또한 프레임워크는 동일한 서비스와 제공자에 여러 개의 동기화 어댑터를 허용합니다.


동기화 어댑터 클래스 및 파일
동기화 어댑터를 AbstractThreadedSyncAdapter의 서브클래스로 구현하여 Android 애플리케이션의 일부로 설치합니다. 시스템은 애플리케이션 매니페스트의 요소와 매니페스트가 가리키는 특수 XML 파일에서 동기화 어댑터에 관한 정보를 얻습니다. XML 파일은 온라인 서비스의 계정 유형과 콘텐츠 제공자의 권한을 정의하며, 이 권한은 어댑터를 고유하게 식별합니다. 동기화 어댑터는 사용자가 동기화 어댑터의 계정 유형에 관한 값을 추가하고 동기화 어댑터가 동기화되는 콘텐츠 제공자의 동기화 사용 설정하기 전까지 활성화되지 않습니다. 그 시점부터 시스템이 어댑터를 관리하기 시작하며, 필요할 때마다 호출하여 콘텐츠 제공자와 서버 간 동기화를 수행합니다.

계정 유형을 동기화 어댑터의 식별 정보의 일부로 사용하면, 시스템은 동일한 조직에서 제공하는 서로 다른 서비스를 접근하는 동기화 어댑터들을 감지하고 하나로 묶을 수 있습니다. 예를 들어, Google 온라인 서비스를 위한 동기화 어댑터들은 모두 동일한 계정 유형 com.google을 가집니다. 사용자가 기기에 Google 계정을 추가하면, 설치된 모든 Google 서비스용 동기화 어댑터가 함께 표시되며, 각각의 동기화 어댑터는 기기 내 서로 다른 콘텐츠 제공자와 동기화됩니다.

대부분의 서비스에서는 사용자가 데이터에 접근하기 전에 ID를 확인해야 하므로 Android 시스템은 동기화 어댑터 프레임워크와 비슷하고 자주 사용되는 인증 프레임워크를 제공합니다. 인증 프레임워크는 AbstractAccountAuthenticator의 서브클래스인 플러그인 authenticator를 사용합니다. Authenticator는 다음 단계에 따라 사용자의 ID를 확인합니다.
- 사용자 이름, 비밀번호, 유사한 정보 (사용자의 사용자 인증 정보)를 수집
- 사용자 인증 정보를 서비스로 전송
- 서비스의 응답을 검토

서비스가 사용자 인증 정보를 수락하면 authenticator는 이후에 사용할 수 있도록 해당 사용자 인증 정보를 저장할 수 있습니다. 플러그인 authenticator는 프레임워크로 인해 AccountManager는 OAuth2 인증 토큰과 같이 authenticator가 지원하고 외부에서 사용할 수 있도록 선택한 모든 인증 토큰에 접근할 수 있습니다. 인증이 필수는 아니지만, 대부분 연락처 서비스는 이를 사용합니다. 하지만 인증을 수행하기 위해 Android 인증 프레임워크를 꼭 사용할 필요는 없습니다.


동기화 어댑터 구현
연락처 제공자의 동기화 어댑터를 구현하려면 Android 애플리케이션에 다음을 포함해야 합니다.

- 시스템의 요청에 응답하여 동기화 어댑터에 결합하는 Service 구성요소: 시스템에서 동기화를 실행하려는 경우 서비스의 onBind() 메서드를 호출하여 동기화 어댑터의 IBinder를 가져옴. IBinder는 시스템이 프로세스 간 통신을 통해 어댑터의 메서드를 사용 가능하게 함.

- AbstractThreadedSyncAdapter의 서브클래스로 구현된 실제 동기화 어댑터: 이 클래스는 서버에서 데이터 다운로드, 기기에서 데이터 업로드, 충돌을 해결하는 작업 실행. 어댑터의 기본 작업은 onPerformSync() 메서드에서 실행. 이 클래스는 반드시 싱글톤으로 인스턴스화해야 함.

- Application의 서브클래스: 이 클래스는 동기화 어댑터 싱글톤의 팩토리 역할. onCreate() 메서드를 사용하여 동기화 어댑터를 인스턴스화하고 동기화 어댑터 서비스의 onBind() 메서드에 싱글톤을 반환하는 정적 'getter' 메서드를 제공

- (선택사항) 시스템의 사용자 인증 요청에 응답하는 Service 구성요소: AccountManager가 이 서비스를 통해 인증 프로세스 시작. 서비스의 onCreate() 메서드는 authenticator 객체를 인스턴스화. 시스템이 애플리케이션 동기화 어댑터의 사용자 계정을 인증하려는 경우 시스템은 서비스의 onBind() 메서드를 호출하여 인증자의 IBinder를 가져옴.  IBinder는 시스템이 프로세스 간 통신을 통해 authenticator의 메서드를 사용 가능하게 함.

- (선택사항) 인증 요청을 처리하는 AbstractAccountAuthenticator의 구현 서브클래스: 이 클래스는 AccountManager가 서버에서 사용자 인증 정보를 인증하기 위해 호출하는 메서드 제공. 인증 프로세스의 세부 사항은 사용하는 서버 기술에 따라 매우 달라짐.

- 동기화 어댑터와 시스템 authenticator를 정의하는 XML 파일: 앞에서 설명한 동기화 어댑터와 authenticator 서비스 구성요소는 애플리케이션 매니페스트의 <service> 요소에서 정의. 이러한 요소는 시스템에 특정 데이터를 제공하는 <meta-data> 하위 요소를 포함.
    - 동기화 어댑터 서비스의 <meta-data> 요소는 XML 파일 res/xml/syncadapter.xml를 가리킴. 이 파일은 연락처 제공자와 동기화될 웹 서비스의 URI와 웹 서비스의 계정 유형을 지정.
    - 선택사항: authenticator의 <meta-data> 요소는 XML 파일 res/xml/authenticator.xml를 가리킴. 이 파일은 authenticator가 지원하는 계정 유형과 인증 프로세스 중에 표시되는 UI 리소스(예. 화면 레이아웃)를 지정. 이 요소에 지정된 계정 유형은 동기화 어댑터에 지정된 계정 유형과 동일해야 함.