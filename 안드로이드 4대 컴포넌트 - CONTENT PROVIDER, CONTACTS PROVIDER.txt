연락처 제공자는 사람에 대한 중앙 데이터 저장소를 관리하는 강력하고 유연한 Android 구성요소입니다. 연락처 제공자는 기기의 연락처 애플리케이션에서 볼 수 있는 데이터의 소스이며, 개발자는 자신의 애플리케이션에서 연락처 제공자의 데이터에 액세스하고 기기와 온라인 서비스 간에 데이터를 전송할 수도 있습니다. 이 제공업체는 광범위한 데이터 소스를 수용하고 각 개인에 대해 가능한 한 많은 데이터를 관리하려고 하므로 조직이 복잡합니다. 따라서 이 제공업체의 API에는 데이터 검색과 수정을 모두 용이하게 하는 광범위한 계약 클래스와 인터페이스 세트가 포함되어 있습니다.



연락처 제공자의 구성	
연락처 제공자는 Android 콘텐츠 제공자 구성요소입니다. 사용자에 관한 세 가지 유형의 데이터를 유지합니다. 각 유형은 그림 1에서와 같이 제공자가 제공하는 테이블에 대응합니다. 이 세 개의 테이블은 일반적으로 해당 계약 클래스 이름으로 불립니다. 이 클래스는 테이블에서 사용하는 콘텐츠 URI, 열 이름, 열 값의 상수를 정의합니다.

테이블 ContactsContract.Contacts
원시 연락처 행들을 종합하여 얻은 서로 다른 사람을 나타내는 행입니다.
테이블 ContactsContract.RawContacts
사용자 계정 및 유형에 따라 개인의 데이터 요약이 포함된 행입니다.
테이블 ContactsContract.Data
이메일 주소나 전화번호와 같은 원시 연락처의 세부정보가 포함된 행입니다.

ContactsContract의 계약 클래스에서의 이 외의 다른 테이블은 연락처 제공자가 작업을 관리하거나 기기의 연락처 또는 전화 통신 애플리케이션에서 특정 기능을 지원하는 데 사용하는 보조 테이블입니다.



원시 연락처
원시 연락처는 특정 계정 유형과 계정 이름에서 가져온 한 사람의 데이터를 의미한다. 이때 계정 유형은Google, Naver 같이 연락처를 제공하는 서비스의 종류를 의미하고 계정 이름은 계정을 식별하는 고유 문자열을 의미한다. 보통 계정의 로그인 ID나 이메일 주소를 뜻한다. Contacts Provider는 한 사람의 데이터 출처로 여러 온라인 서비스를 허용하기 때문에, 동일한 사람에 대해 여러 개의 raw contact를 가질 수 있다. 또한, 동일한 계정 유형 안에서 서로 다른 계정을 통해 한 사람의 데이터를 결합하는 것도 가능하다.

Raw contact의 대부분의 데이터는 ContactsContract.RawContacts 테이블에 저장되지 않는다. 대신, 하나 이상의 행으로 ContactsContract.Data 테이블에 저장된다. 각 데이터 행에는 Data.RAW_CONTACT_ID 컬럼이 있으며, 이는 해당 데이터 행이 속한 ContactsContract.RawContacts 행의 _ID 값을 가진다.

주요 원시 연락처 열
ContactsContract.RawContacts 테이블의 중요 열은 다음과 같습니다.
ACCOUNT_NAME	
이 원시 연락처의 소스인 계정 유형의 계정 이름입니다. 예를 들어 Google 계정의 계정 이름은 기기 소유자의 Gmail 주소 중 하나입니다. 
이 이름의 형식은 각 계정 유형별로 다릅니다. 반드시 이메일 주소일 필요는 없습니다.
ACCOUNT_TYPE	
이 원시 연락처의 소스인 계정 유형입니다. 예를 들어 Google 계정의 계정 유형은 com.google입니다.  도메인 식별자를 사용하여 항상 소유하거나 제어하는 도메인의 계정 유형을 지정하세요. 이렇게 하면 계정 유형이 고유하게 유지됩니다.
연락처 데이터를 제공하는 계정 유형에는 일반적으로 연락처 제공자와 동기화되는 동기화 어댑터가 연결되어 있습니다.
DELETED	
원시 연락처에 대한 '삭제됨' 플래그입니다.	
이 플래그를 사용하면 연락처 제공자가 동기화 어댑터가 서버에서 행을 삭제한 다음 최종적으로 저장소에서 해당 행을 삭제할 수 있을 때까지 내부적으로 행을 유지할 수 있습니다.

다음은 ContactsContract.RawContacts 테이블에 관한 중요한 참고사항입니다.
- 원시 연락처의 이름은 ContactsContract.RawContacts의 행에 저장되지 않습니다. 대신 ContactsContract.Data 테이블의 ContactsContract.CommonDataKinds.StructuredName 행에 저장됩니다. 하나의 원시 연락처에는 ContactsContract.Data 테이블에서 이 유형의 행이 하나만 있습니다. StructuredName은 이름 관련 필드를 담는 데이터 타입으로 하나의 raw contact는 이름이 하나만 있으므로, 이 타입의 row는 1개만 존재
- 원시 연락처 행에서 본인 소유의 계정 데이터를 사용하려면 이를 먼저 AccountManager에 등록해야 합니다. 이렇게 하려면 사용자에게 계정 유형과 계정 이름을 계정 목록에 추가하라는 메시지를 표시합니다. 이렇게 하지 않으면 연락처 제공자가 원시 연락처 행을 자동으로 삭제합니다. 즉, Contacts Provider는 해당 계정이 AccountManager에 등록되어 있어야 유효하다고 판단하기 때문에 유효한 계정의 대한 row만 유지. 예를 들어 앱에서 com.example.dataservice 도메인을 사용하는 웹 기반 서비스의 연락처 데이터를 유지하고 서비스의 사용자 계정이 becky.sharp@dataservice.example.com인 경우 사용자가 먼저 계정 '유형' (com.example.dataservice)과 계정 '이름'(becky.smart@dataservice.example.com)을 추가해야 앱에서 원시 연락처 행을 추가할 수 있습니다. 이 요구사항을 사용자에게 문서로 설명하거나 사용자에게 유형과 이름을 추가하라는 메시지를 표시하거나 두 가지를 모두 수행할 수 있습니다. 


원시 연락처 데이터 소스 예시
원시 연락처의 작동 방식을 이해하려면 기기에 다음 세 개의 사용자 계정이 정의된 사용자 'Emily Dickinson'이 있다고 가정해 보겠습니다.
- emily.dickinson@gmail.com
- emilyd@gmail.com
- Twitter 계정인 'belle_of_amherst'
이 사용자는 계정 설정에서 세 계정 모두의 연락처 동기화를 사용 설정했습니다. Emily Dickinson이 브라우저 창을 열고 emily.dickinson@gmail.com으로 Gmail에 로그인한 다음 연락처를 열고 'Thomas Higginson'을 추가한다고 가정해 보겠습니다. 나중에 그녀는 emilyd@gmail.com으로 Gmail에 로그인하고 'Thomas Higginson'에게 이메일을 보냅니다. 그러면 자동으로 연락처에 추가됩니다. 또한 트위터에서 'colonel_tom' (Thomas Higginson의 Twitter ID)도 팔로우합니다.

연락처 제공자는 이 작업의 결과로 원시 연락처를 세 개 생성합니다.
- 'Thomas Higginson'에 대해 생성된 첫번째 원시 연락처는 emily.dickinson@gmail.com 입니다. 사용자 계정 유형은 Google입니다.
- Thomas Higginson'에 대해 생성된 두 번째 원시 연락처는 emilyd@gmail.com입니다. 사용자 계정 유형은 마찬가지로 Google입니다. 이전과 같은 이름을 가진 동일 인물이라도 다른 계정을 추가하였기 때문에 두 번째 원시 연락처가 생성 되었습니다.
- Thomas Higginson'에 대해 생성된 세 번째 원시 연락처는'belle_of_amherst'입니다. 사용자 계정 유형은 Twitter입니다.



Data
개념
앞서 언급했듯이 원시 연락처의 데이터는 원시 연락처의 _ID 값과 연결된 ContactsContract.Data 행에 저장됩니다. 이렇게 하면 하나의 원시 연락처에 같은 유형의 데이터를 여러 개의 인스턴스로 생성할 수 있습니다. 예를 들어 Thomas Higginson는 Google 계정으로 emilyd@gmail.com의 원시 연락처를 가집니다. 해당 연락처 행의 집 이메일 주소가 thigg@gmail.com이고 직장 이메일 주소가 thomas.higginson@gmail.com이면, 연락처 제공자는 두 이메일 주소 행을 저장하고 두 가지를 원시 연락처에 연결합니다. 즉, 1개의 원시 연락처에 대해 2개의 Data 테이블이 참조합니다. 이때 원시 연락처의 _ID값을 통해 연결됩니다.

이 테이블 하나에 여러 가지 유형의 데이터가 저장될 수 있습니다. 표시 이름, 전화번호, 이메일, 우편 주소, 사진, 웹사이트 세부정보 행은 모두 ContactsContract.Data 테이블에 있습니다. 이를 관리하는 데 도움이 되도록 ContactsContract.Data 테이블에는 이름에 명이 포함된 열 몇 개와 일반적인 이름이 포함된 열이 몇 개 있습니다. 설명이 포함된 이름 열의 콘텐츠는 행의 데이터 유형과 관계없이 동일한 의미를 지니며, 일반 이름 열의 콘텐츠는 데이터 유형에 따라 의미가 달라집니다.


Descriptive column 이름
다음은 설명이 포함된 열 이름의 몇 가지 예입니다.

RAW_CONTACT_ID
이 데이터에 관한 원시 연락처의 _ID 열 값입니다.

MIMETYPE
이 행에 저장되는 데이터 유형으로, 맞춤 MIME 유형으로 표현됩니다. 연락처 제공자는 ContactsContract.CommonDataKinds의 서브클래스에 정의된 MIME 유형을 사용합니다. 이러한 MIME 유형은 오픈소스이며 연락처 제공자와 호환되는 모든 애플리케이션 또는 동기화 어댑터에서 사용할 수 있습니다.

IS_PRIMARY
하나의 원시 연락처에 대해 해당 데이터 유형이 2개 이상있는 경우, IS_PRIMARY 컬럼은 그 유형에서 기본데이터가 무엇인지 표시한다. 를 들어, 사용자가 연락처의 전화번호를 길게 눌러 기본값으로 설정하면, 해당 전화번호를 담고 있는 ContactsContract.Data row의 IS_PRIMARY 컬럼 값이 0이 아닌 값으로 설정된다


Generic column 이름
일반적으로 사용 가능한 DATA1~DATA15라는 일반 열 15개와 동기화 어댑터에서만 사용해야 하는 추가 일반 열 SYNC1~SYNC4 4개가 있습니다. 일반 열 이름 상수는 행에 포함된 데이터 유형과 관계없이 항상 작동합니다. DATA1 열은 인덱스로 사용됩니다. 연락처 제공자는 제공자가 가장 자주 쿼리의 대상이 될 것으로 예상하는 데이터에 항상 DATA1 열을 사용합니다. 예를 들어 이메일 행의 경우 이 열에 실제 이메일 주소가 저장됩니다. 쿼리 대상이 주로 휴대전화면 실제 전화번호 값이 저장됩니다. 그렇기 때문에 위에서 데이터 유형에 따라 의미가 달라진다고 하는 겁니다. 규칙에 따라 DATA15 열은 썸네일 사진과 같은 BLOB(Binary Large Object) 데이터 저장에 사용됩니다.


유형별 열 이름
특정 유형의 행에 관한 열 작업을 용이하게 하기 위해 연락처 제공자는 ContactsContract.CommonDataKinds의 서브클래스에 정의된 유형별 열 이름 상수도 제공합니다. 동일한 열 이름에 쉽게 구분하여 사용할 수 있는 여러 개의 상수 이름을 부여하므로 특정 유형의 행에 있는 데이터에 액세스하는 데 도움이 됩니다. 예를 들어 ContactsContract.CommonDataKinds.Email 클래스는 ContactsContract.Data 행에서 MIME 유형이 Email.CONTENT_ITEM_TYPE인 유형별 열 이름 상수를 정의합니다. 이 클래스에는 이메일 주소 열에 대해 ADDRESS 상수를 제공됩니다. ADDRESS의 실제 값은 Generic column과 동일한 'data1'입니다. data1을 유형에 따라 상수로 쉽게 구분할 수 있는 겁니다.

제공업체에서 사전 정의된 MIME 유형을 지정한 ContactsContract.Data 테이블에  자체 맞춤 데이터를 추가하지 마세요. 그렇게 하면 데이터가 손실되거나 제공자가 오작동을 일으킬 수 있습니다. 예를 들어 DATA1 열에 이메일 타입으로 지정했으면 이메일 주소를 입력해야하지 사용자 이름이 포함된 MIME 유형 Email.CONTENT_ITEM_TYPE의 행을 추가하면 안 됩니다. 행에 사용자 맞춤 MIME 유형을 사용해야 고유한 유형별 열 이름을 자유롭게 정의하고 원하는 대로 열을 사용할 수 있습니다.

그림 2는 descriptive열과 data열이 ContactsContract.Data 행에 표시되는 방식과 유형별 열 이름이 generic 열 이름에 '오버레이'되는 방식을 보여줍니다.


유형별 열 이름 클래스
표 2는 가장 보편적으로 사용되는 유형별 열 이름 클래스를 나열한 것입니다.

ContactsContract.CommonDataKinds.StructuredName	
이 데이터 행과 연결된 원시 연락처의 이름 데이터입니다.	
하나의 원시 연락처에는 이러한 행이 딱 하나만 있습니다.

ContactsContract.CommonDataKinds.Photo	
이 데이터 행과 연결된 원시 연락처의 기본 사진입니다.	
하나의 원시 연락처에는 이러한 행이 딱 하나만 있습니다.

ContactsContract.CommonDataKinds.Email	
이 데이터 행과 연결된 원시 연락처의 이메일 주소입니다.	
하나의 원시 연락처에는 여러 개의 이메일 주소가 있을 수 있습니다.

ContactsContract.CommonDataKinds.StructuredPostal	
이 데이터 행과 연결된 원시 연락처의 우편 주소입니다.	
하나의 원시 연락처에는 여러 개의 우편 주소가 있을 수 있습니다.

ContactsContract.CommonDataKinds.GroupMembership	
원시 연락처를 연락처 제공자의 그룹 중 하나와 연결하는 식별자입니다.	
그룹은 계정 유형과 계정 이름의 선택적 기능입니다.


연락처
연락처 제공자는 계정 유형과 이름으로 이루어진 모든 원시 연락처 행들을 합치고 동일 인물일 경우 합쳐서 연락처를 형성합니다. 이렇게 하면 사용자가 한 사람에 관해 수집한 모든 데이터를 쉽게 표시하고 수정할 수 있습니다. 연락처 제공자는 새로운 연락처 행의 생성과 원시 연락처를 기존 연락처 행과 합치는 작업을 관리합니다. 애플리케이션과 동기화 어댑터는 모두 연락처를 추가할 수 없으며 연락처 행의 일부 열은 읽기만 가능합니다. 이때 '읽기 전용'으로 표시된 열을 업데이트하려고 하면 업데이트가 무시됩니다. insert()를 사용하여 연락처 제공자에 연락처를 추가하려고 하면 UnsupportedOperationException 예외가 발생합니다. 

연락처 제공자는 기존 연락처와 일치하지 않는 새로운 원시 연락처가 추가되면 새 연락처를 생성합니다. 제공자는 기존 원시 연락처의 데이터가 변경되어 이전에 연결된 연락처와 더 이상 일치하지 않는 경우에도 이 작업을 실행합니다. 애플리케이션이나 동기화 어댑터가 기존 연락처와 일치하는 새로운 원시 연락처를 만들면 새로운 원시 연락처가 기존 연락처에 합쳐집니다. 

연락처 제공자는 Contacts 테이블에 있는 연락처 행의 _ID 열을 사용하여 연락처 행과 원시 연락처 행을 연결합니다. 원시 연락처 테이블 ContactsContract.RawContacts의 CONTACT_ID 열에는 각 원시 연락처 행과 연결된 연락처 행의 _ID 값이 포함됩니다.ContactsContract.Contacts 테이블에는 연락처 행에 대한 '영구' 링크인 LOOKUP_KEY 열도 있습니다. 연락처 제공자는 연락처를 자동으로 유지하므로, 집계 또는 동기화에 응답하여 연락처 행의 _ID 값을 변경할 수도 있습니다. 이 경우에도 연락처의 LOOKUP_KEY와 결합된 콘텐츠 URI인 CONTENT_LOOKUP_URI는 여전히 연락처 행을 가리키므로 LOOKUP_KEY를 사용하여 '즐겨찾기' 연락처 등에 대한 링크를 유지할 수 있습니다. 이 열에는 _ID 열의 형식과 관련이 없는 자체 형식이 있습니다. 그림 3은 세 가지 기본 테이블이 서로 연결되는 방식을 나타낸 것입니다.

 Google Play 스토어에 앱을 게시하거나 Android 10 (API 수준 29) 이상을 실행하는 기기에 앱이 있는 경우 일부 연락처 데이터 필드와 메서드들은 더 이상 사용되지 않습니다. 시스템은 아래의 데이터 필드에 작성된 값을 주기적으로 지웁니다.
ContactsContract.ContactOptionsColumns.LAST_TIME_CONTACTED
ContactsContract.ContactOptionsColumns.TIMES_CONTACTED
ContactsContract.DataUsageStatColumns.LAST_TIME_USED
ContactsContract.DataUsageStatColumns.TIMES_USED

위의 데이터 필드를 설정하는 데 사용하는 API도 사용이 중단되었습니다.
ContactsContract.Contacts.markAsContacted()
ContactsContract.DataUsageFeedback

또한 다음 필드에서는 이제 자주 사용하는 연락처를 반환하지 않습니다. 이러한 필드 중 일부는 연락처가 특정 데이터 종류의 일부인 경우에만 연락처 순위에 영향을 줍니다.
ContactsContract.Contacts.CONTENT_FREQUENT_URI
ContactsContract.Contacts.CONTENT_STREQUENT_URI
ContactsContract.Contacts.CONTENT_STREQUENT_FILTER_URI
CONTENT_FILTER_URI (Email, Phone, Callable, Contactables 데이터 종류에만 영향을 미침)
ENTERPRISE_CONTENT_FILTER_URI (Email, Phone 및 Callable 데이터 종류에만 영향을 미침)

앱에서 이러한 필드 또는 API에 액세스하거나 이를 업데이트하는 경우 다른 방법을 사용해야 합니다. 예를 들어 private 콘텐츠 제공업체 또는 앱이나 백엔드 시스템 내에 저장된 기타 데이터를 사용하여 대체하여 처리할 수 있습니다. 이 변경사항으로 인해 앱 기능이 영향을 받지 않는지 확인하려면 이러한 데이터 필드를 수동으로 지우면 됩니다. 이렇게 하려면 Android 4.1 (API 수준 16) 이상을 실행하는 기기에서 다음 ADB 명령어를 실행하세요.
adb shell content delete \
--uri content://com.android.contacts/contacts/delete_usage



동기화 어댑터의 데이터
사용자는 연락처 데이터를 기기에 직접 입력하지만 데이터는 동기화 어댑터를 통해 웹 서비스에서 연락처 제공자로 전송되어 기기와 서비스 간에 데이터 전송을 자동화합니다. 동기화 어댑터는 시스템의 제어하에 백그라운드에서 실행되며 ContentResolver 메서드를 호출하여 데이터를 관리합니다. Android에서 동기화 어댑터와 함께 작업하는 웹 서비스는 계정 유형으로 식별됩니다. 각 동기화 어댑터는 하나의 계정 유형에서 작동하지만 이러한 유형에는 여러 계정 이름을 지원할 수 있습니다. 

계정 유형
사용자가 데이터를 저장한 서비스를 식별합니다. 대부분의 경우 사용자는 서비스에 인증해야 합니다. 예를 들어 Google 주소록은 google.com 코드로 식별되는 계정 유형입니다. 이 값은 AccountManager에서 사용하는 계정 유형에 해당합니다.

계정 이름
계정 유형에 대한 특정 계정 또는 로그인을 식별합니다. Google 연락처 계정은 Google 계정과 동일합니다. 이때 Google 계정은 계정 이름으로 이메일 주소를 사용합니다. 다른 서비스에서는 단일 단어 사용자 이름 또는 숫자 ID를 사용할 수도 있습니다.

계정 유형은 고유하지 않아도 됩니다. 사용자는 여러 Google 주소록 계정을 구성하고 연락처 제공자에 데이터를 다운로드할 수 있습니다. 이는 사용자에게 개인 계정 이름으로 개인 연락처 목록이 있고 업무용으로 다른 연락처 목록이 있는 경우에 발생할 수 있습니다. 계정 이름은 일반적으로 고유합니다. 이 둘은 함께 사용되어 연락처 제공자와 외부 서비스 간의 특정 데이터 흐름을 식별합니다. 

서비스의 데이터를 연락처 제공자로 전송하려면 자체 동기화 어댑터를 작성해야 합니다. 그림 4는 연락처 제공자가 사람에 관한 데이터 흐름 속에서 어떤 위치와 역할을 하는지를 보여줍니다. "동기화 어댑터"라고 표시된 상자에서 각 어댑터는 계정 유형에 따라 이름이 지정됩니다.



필수 권한
연락처 제공자에 액세스하려는 애플리케이션은 다음 권한을 요청해야 합니다.

하나 이상의 테이블에 대한 읽기 권한
READ_CONTACTS, AndroidManifest.xml에 <uses-permission> 요소와 <uses-permission android:name="android.permission.READ_CONTACTS">로 지정됨.

하나 이상의 테이블에 대한 쓰기 권한
WRITE_CONTACTS, AndroidManifest.xml에 <uses-permission> 요소와 <uses-permission android:name="android.permission.WRITE_CONTACTS">로 지정됨.

이들 권한은 사용자 프로필 데이터와는 별개입니다. 사용자의 연락처 데이터는 개인 정보이며 민감한 정보라는 점을 기억해야 합니다. 사용자는 자신의 개인정보 보호를 중요하게 생각하므로 애플리케이션이 본인 또는 연락처에 관한 데이터를 수집하는 것을 원하지 않습니다. 사용자의 연락처 데이터에 액세스할 권한이 필요한 이유가 분명하지 않으면 애플리케이션에 낮은 평점을 매기거나 설치를 거부할 수도 있습니다.



사용자 프로필
ContactsContract.Contacts 테이블에는 기기 사용자의 프로필 데이터가 포함된 단일 행이 있습니다. 이 데이터는 사용자의 연락처 중 하나가 아니라 기기의 user를 설명합니다. 프로필 연락처 행은 프로필을 사용하는 각 시스템의 원시 연락처 행에 연결됩니다. 각 프로필 원시 연락처 행에는 여러 개의 데이터 행이 있을 수 있습니다. 사용자 프로필에 액세스하기 위한 상수는 ContactsContract.Profile 클래스에서 사용할 수 있습니다.

사용자 프로필에 액세스하려면 특수 권한이 필요합니다. 읽기와 쓰기에 필요한 READ_CONTACTS 및 WRITE_CONTACTS 권한 외에 사용자 프로필에 액세스하려면 읽기 및 쓰기 액세스에 관한 android.Manifest.permission#READ_PROFILE과 android.Manifest.permission#WRITE_PROFILE 권한이 각각 필요합니다. 사용자의 프로필은 민감한 정보로 간주해야 합니다. android.Manifest.permission#READ_PROFILE 권한을 사용하면 개발자가 기기 사용자의 개인 식별 데이터에 액세스할 수 있게 해줍니다. 애플리케이션 설명에서 사용자에게 사용자 프로필 액세스 권한이 필요한 이유를 알려야 합니다.

사용자 프로필이 포함된 연락처 행을 검색하려면 ContentResolver.query()를 호출합니다. 콘텐츠 URI를 CONTENT_URI로 설정하고 선택 기준은 제공하지 않습니다. 이 콘텐츠 URI는 원시 연락처 또는 프로필의 데이터를 검색하기 위한 기본 URI로 사용할 수도 있습니다. 예를 들어, 해당 코드는 프로필에 대한 데이터를 검색합니다.

//java
// 사용자 프로필 검색을 위한 열 설정
projection = new String[]
    {
        Profile._ID,
        Profile.DISPLAY_NAME_PRIMARY,
        Profile.LOOKUP_KEY,
        Profile.PHOTO_THUMBNAIL_URI
    };
//연락처 제공자로부터 프로필 검색
profileCursor =
        getContentResolver().query(
                Profile.CONTENT_URI,
                projection ,
                null,
                null,
                null);
//kotlin
// 사용자 프로필 검색을 위한 열 설정
projection = arrayOf(
        ContactsContract.Profile._ID,
        ContactsContract.Profile.DISPLAY_NAME_PRIMARY,
        ContactsContract.Profile.LOOKUP_KEY,
        ContactsContract.Profile.PHOTO_THUMBNAIL_URI
)

//연락처 제공자로부터 프로필 검색
profileCursor = contentResolver.query(
        ContactsContract.Profile.CONTENT_URI,
        projection,
        null,
        null,
        null
)

여러 연락처 행을 검색하고 그중 하나가 사용자 프로필인지 확인하려면 행의 IS_USER_PROFILE 열을 검사하면 됩니다. 이 열은 연락처가 사용자 프로필인 경우 '1'로 설정됩니다.



연락처 제공자 메타데이터
연락처 제공자는 저장소에 있는 연락처 데이터의 상태를 추적하는 데이터를 관리합니다. 저장소에 대한 이 메타데이터는 원시 연락처, 데이터, 연락처 테이블 행, ContactsContract.Settings 테이블, ContactsContract.SyncState 테이블 등의 다양한 위치에 저장됩니다. 다음 표는 이러한 메타데이터 각각이 미치는 영향을 보여준다

ContactsContract.RawContacts	
DIRTY	
"0" - 마지막 동기화 이후 변경되지 않습니다.
"1" - 마지막 동기화 후 변경되었으며 서버에 다시 동기화해야 합니다.
기기에서 변경되었으며 서버에 다시 동기화해야 하는 원시 연락처를 표시합니다. 이 값은 Android 애플리케이션이 행을 업데이트할 때 연락처 제공자에 의해 자동으로 설정됩니다.
원시 연락처 또는 데이터 테이블을 수정하는 동기화 어댑터는 항상 사용되는 콘텐츠 URI에 CALLER_IS_SYNCADAPTER 문자열을 추가해야 합니다. 그럼 Contacts Provider가 해당 변경을 서버에서 온 변경으로 인식하여 DIRTY 컬럼을 변경하지 않습니다. 그렇지 않으면 동기화 어댑터 수정이 로컬에서 수정된 것으로 인식하여 해당 row의 DIRTY 컬럼을 1로 설정합니다. 서버에서 수정된 거지만 다음 동기화 때 서버로 다시 전송됨. 불필요한 중복 전송 발생

ContactsContract.RawContacts	
VERSION	
이 행의 버전 번호.	
연락처 제공자는 해당 행이나 관련 데이터가 변경될 때마다 이 값을 자동으로 증가시킵니다.

ContactsContract.Data	
DATA_VERSION	
이 행의 버전 번호.	
연락처 제공자는 데이터 행이 변경될 때마다 이 값을 자동으로 증가시킵니다.

ContactsContract.RawContacts	
SOURCE_ID
해당 원시 연락처를 자신이 생성된 계정에 고유하게 식별하는 문자열 값입니다.	
동기화 어댑터가 새로운 원시 연락처를 생성하면, 이 열이 원시 연락처에 관한 서버의 고유 ID로 설정되어야 합니다. Android 애플리케이션이 새로운 원시 연락처를 만들 때 애플리케이션은 이 열을 비워 두어야 합니다. 이는 동기화 어댑터에 서버에 새로운 원시 연락처를 만들고 SOURCE_ID 값을 가져와야 한다는 신호를 보냅니다. 특히 소스 ID는 계정 유형마다 고유해야 하며 동기화 전체에서 안정적이어야 합니다.
고유: 계정의 각 원시 연락처에는 고유한 소스 ID가 있어야 합니다. 개발자가 이것을 강제 적용하지 않으면 연락처 애플리케이션에 문제를 일으킵니다. 동일한 계정 유형의 두 원시 연락처는 소스 ID가 같을 수 있습니다. 예를 들어 emily.dickinson@gmail.com 계정의 원시 연락처 'Thomas Higginson'은 emilyd@gmail.com 계정의 원시 연락처 'Thomas Higginson'과 소스 ID가 같을 수 있습니다.
안정화: 소스 ID는 원시 연락처에 관한 온라인 서비스 데이터의 영구적인 부분입니다. 예를 들어 사용자가 앱 설정에서 연락처 저장소를 삭제하고 다시 동기화하는 경우 복원된 원시 연락처의 소스 ID는 이전과 동일해야 합니다. 이를 적용하지 않으면 바로가기가 더 이상 작동하지 않습니다.

ContactsContract.Groups	
GROUP_VISIBLE	
"0" - 이 그룹의 연락처가 Android 애플리케이션 UI에 표시되면 안 됩니다.	
'1' - 이 그룹의 연락처가 애플리케이션 UI에 표시될 수 있습니다.
이 열은 사용자가 특정 그룹에 연락처를 숨길 수 있는 서버와의 호환성을 위한 것입니다.

ContactsContract.Settings	
UNGROUPED_VISIBLE	
'0' - 이 계정 유형과 계정에 대해서, 그룹에 속하지 않은 연락처는 Android 애플리케이션 UI에서 보이지 않는다.	
'1' - 이 계정 유형과 계정에 대해서, 그룹에 속하지 않은 연락처는 Android 애플리케이션 UI에서 표시됩니다.
기본적으로, 해당 연락처의 어떤 raw contact도 그룹에 속해 있지 않으면 그 연락처는 표시되지 않는다. 원시 연락처의 그룹 소속 여부는 ContactsContract.Data 테이블 안의 하나 이상의 ContactsContract.CommonDataKinds.GroupMembership row로 표시된다. ContactsContract.Settings 테이블에서 특정 계정 유형과 계정에 대한 row에 이 플래그를 설정하면, 그룹에 속하지 않은 연락처도 강제로 보이게 할 수 있다. 이 플래그의 한 가지 용도는 그룹 기능을 사용하지 않는 서버의 연락처를 표시하는 것이다.

ContactsContract.SyncState	
(모두)
이 테이블을 사용하여 동기화 어댑터의 메타데이터를 저장합니다.	
이 테이블을 사용하면 동기화 상태와 기타 동기화 관련 데이터를 기기에 영구적으로 저장할 수 있습니다.