1. 파일 안에 함수 선언하기
1)특징
- 코틀린은 파일 수준에서 함수 선언 가능. 자바의 static 메소드처럼 사용할 수 있음.
- package 단위로 함수 접근 가능
- 컴파일 시, 코틀린은 자동으로 클래스로 래핑함
- 상태(state)를 가지기 어렵고, 전역적으로 사용할 때 적합


2)장점
- 간단한 유틸리티 함수 작성에 적합
- 객체 생성 필요 없음


3)단점
- 상태를 유지할 수 없음
- OOP 구조에서 메소드 그룹화에 한계 있음.


4)예시
// Utils.kt
fun add(a: Int, b: Int) = a + b
fun subtract(a: Int, b: Int) = a - b



2. 객체(object) 안에 메소드 선언하기
1)특징
- object는 싱글톤 객체
- 상태를 가질 수 있음
- 메소드 호출 시 객체 이름으로 접근
- 전역에서 접근 가능하지만, OOP 구조를 따르는 경우 관리가 용이


2)장점
- 함수 그룹화를 명확하게 할 수 있음
- 상태를 가진 함수 구현 가능
- OOP 설계와 맞춤


3)단점
- 불필요하게 싱글톤 객체를 만들면 간단한 유틸 함수에는 오버헤드가 될 수 있음


4)예시
object Calculator {
    fun add(a: Int, b: Int) = a + b
    fun subtract(a: Int, b: Int) = a - b
}



3. 상태 유지
1)파일 함수
fun incrementCounter(): Int {
    var counter = 0
    counter += 1
    return counter
}

- 호출될 때마다 counter가 0으로 초기화됨
- 상태를 함수 외부에서 유지할 수 없음
- 누적 계산, 캐싱, 특정 객체에 속한 상태 유지가 필요한 함수에는 적합하지 않음


2)object 안 함수
object Counter {
    var counter = 0

    fun increment(): Int {
        counter += 1
        return counter
    }
}

- Counter.counter 변수는 객체 단위로 유지
- 함수 호출 시 이전 상태를 참조 가능
- 상태를 기반으로 한 기능 구현 가능(예: 카운터, 캐시, 설정값 관리)



4. 함수 그룹화
1)파일 함수
// Utils.kt
fun add() {...}
fun subtract() {...}
fun fetchData() {...}
fun formatDate() {...}  // 관련 없는 함수 섞임

- 파일 안에 여러 함수 선언 가능하지만, 논리적 그룹화가 약함.
- 함수가 많아지면 관련 없는 함수들과 섞이기 쉬움.


2)object 안 함수
object MathUtil {
    fun add() {...}
    fun subtract() {...}
}

object NetworkUtil {
    fun fetchData() {...}
    fun postData() {...}
}

- 관련 기능을 객체 단위로 묶어 관리 가능
- 호출 시 명확하게 그룹화됨(예: MathUtil.add(), NetworkUtil.fetchData())
- 코드 가독성과 유지보수 용이


3)그룹화가 필요 없는 경우
// 파일 함수
fun square(x: Int) = x * x
fun cube(x: Int) = x * x * x
fun isEven(x: Int) = x % 2 == 0

- 서로 관련은 있지만, 상태를 공유하지 않음
- 하나의 객체로 묶을 필요 없이 직접 호출 가능
- 유지보수와 사용이 간단함
- 그룹화가 필요 없으면 단순히 물리적 단위인 파일로 묶을 수 있음
- 파일명을 통해 대략적인 관련성을 나타낼 수 있음


4)그룹화가 필요한 경우
object MathUtil {
    fun add(a: Int, b: Int) = a + b
    fun subtract(a: Int, b: Int) = a - b
}

- 여러 수학 관련 함수가 하나의 객체로 묶이면, 사용 시 명확하게 구분 가능
- 상태를 공유하거나 관련 기능을 함께 관리할 때 유리


5)그룹화 기준
- 그룹화 필요 없음: 파일 함수 적합. 단독으로 사용 가능, 상태 공유 X, 단순 기능
- 그룹화 필요 있음: object 적합. 관련 함수들을 묶어 관리, 상태 공유 가능, OOP 설계.
- 판단 기준: 규모와 관리 용이성(함수/클래스 수, 모듈/패키지 구조, 유지보수 복잡도)
   - 파일 함수: 관련 함수 수 적고, 단순 기능.
   - object 안 함수: 함수 수 많고 여러 엔티티·DTO 변환 함수가 존재, 패키지·계층 구조 복잡하면  관리 필요



5. 차이점 비교
| 기준      | 파일 함수                                   | object 함수                                                 |
| ------- | --------------------------------------- | --------------------------------------------------------- |
| 상태 공유   | 불가                                      | 가능                                                        |
| 함수 호출   | `toA()`                                 | `EntityMapper.toA()`                                      |
| 그룹화 의미  | 파일명 외에는 명시적이지 않음                        | 객체 이름으로 명시적 그룹화 가능                                        |
| 관리 용이성  | 작은 프로젝트, 함수 수 적을 때 충분                   | 함수가 많거나 프로젝트 규모가 커서 유지보수 필요할 때 유리                         |
| 프로젝트 규모 | 작은 규모: 함수 수 적고 단순 구조                    | 중대형 규모: 함수 수 많고 모듈/패키지 구조 복잡, 유지보수 필요                     |
| 설계 목적   | 단순 유틸 함수, 상태 없는 독립 기능                   | 관련 함수 그룹화, 명시적 구분, 상태 관리 가능                               |
| 예시      | `fun A.toA()`, `fun B.toB()`를 같은 파일에 모음 | `object EntityMapper { fun A.toA() ... fun B.toB() ... }` |
