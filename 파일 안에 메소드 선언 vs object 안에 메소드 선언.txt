파일 안에 함수 선언하기

특징
코틀린은 파일 수준에서 함수 선언 가능. 자바의 static 메소드처럼 사용할 수 있음.
package 단위로 함수 접근 가능.
컴파일 시, 코틀린은 자동으로 **클래스(예: UtilsKt)**로 래핑함.
상태(state)를 가지기 어렵고, 전역적으로 사용할 때 적합.

장점
간단한 유틸리티 함수 작성에 적합.
객체 생성 필요 없음.

단점
상태를 유지할 수 없음.
OOP 구조에서 메소드 그룹화에 한계 있음.

예시
// Utils.kt
fun add(a: Int, b: Int) = a + b
fun subtract(a: Int, b: Int) = a - b



객체(object) 안에 메소드 선언하기

특징
object는 싱글톤(Singleton) 객체.
상태(state)를 가질 수 있음.
메소드 호출 시 객체 이름으로 접근.
전역에서 접근 가능하지만, OOP 구조를 따르는 경우 관리가 용이.

장점
함수 그룹화를 명확하게 할 수 있음.
상태를 가진 함수 구현 가능.
OOP 설계와 맞춤.

단점
불필요하게 싱글톤 객체를 만들면 간단한 유틸 함수에는 오버헤드가 될 수 있음.

예시
object Calculator {
    fun add(a: Int, b: Int) = a + b
    fun subtract(a: Int, b: Int) = a - b
}



상태(State) 유지
파일 함수
fun incrementCounter(): Int {
    var counter = 0
    counter += 1
    return counter
}


위 함수는 호출될 때마다 counter가 0으로 초기화됨.
상태를 함수 외부에서 유지할 수 없음.
따라서 누적 계산, 캐싱, 특정 객체에 속한 상태 유지가 필요한 함수에는 적합하지 않음.

object 안 함수
object Counter {
    var counter = 0

    fun increment(): Int {
        counter += 1
        return counter
    }
}


Counter.counter 변수는 객체 단위로 유지됨.
함수 호출 시 이전 상태를 참조 가능.
상태를 기반으로 한 기능 구현 가능 (예: 카운터, 캐시, 설정값 관리).



함수 그룹화
파일 함수
파일 안에 여러 함수 선언 가능하지만, 논리적 그룹화가 약함.
함수가 많아지면 관련 없는 함수들과 섞이기 쉬움.

// Utils.kt
fun add() {...}
fun subtract() {...}
fun fetchData() {...}
fun formatDate() {...}  // 관련 없는 함수 섞임

object 안 함수
관련 기능을 객체 단위로 묶어 관리 가능.
호출 시 명확하게 그룹화됨: MathUtil.add(), NetworkUtil.fetchData()
코드 가독성과 유지보수 용이.

object MathUtil {
    fun add() {...}
    fun subtract() {...}
}

object NetworkUtil {
    fun fetchData() {...}
    fun postData() {...}
}


그룹화가 필요 없는 경우
// 파일 함수
fun square(x: Int) = x * x
fun cube(x: Int) = x * x * x
fun isEven(x: Int) = x % 2 == 0

서로 관련은 있지만, 상태를 공유하지 않음.
하나의 객체로 묶을 필요 없이 직접 호출 가능.
유지보수와 사용이 간단함.
그룹화가 필요 없으면 단순히 파일 단위로 묶을 수 있음
// Utils.kt
fun square(x: Int) = x * x
fun cube(x: Int) = x * x * x
파일명을 통해 대략적인 관련성을 나타낼 수 있음.

물리적 단위: 코드가 저장되는 위치 기준.
파일이 커지거나 함수가 많아지면, 관련성이 모호한 함수도 함께 섞일 수 있음.
호출 시 파일명은 중요하지 않고 함수 이름만 사용함: square(3)
즉, 파일 단위 묶기는 단순히 함수들을 같은 파일에 모아둔 것에 불과합니다.


그룹화가 필요한 경우
object MathUtil {
    fun add(a: Int, b: Int) = a + b
    fun subtract(a: Int, b: Int) = a - b
}


여러 수학 관련 함수가 하나의 객체로 묶이면, 사용 시 명확하게 구분 가능.
예: MathUtil.add(), MathUtil.subtract()
상태를 공유하거나 관련 기능을 함께 관리할 때 유리.

그룹화 필요 없음 → 단독으로 사용 가능, 상태 공유 X, 단순 기능 → 파일 함수 적합.
그룹화 필요 있음 → 관련 함수들을 묶어 관리, 상태 공유 가능, OOP 설계 → object 적합.

논리적 단위로 관련 함수들을 묶음.
호출 시 명시적 그룹 이름 사용: MathUtil.square(3)
→ 어떤 그룹에 속한 함수인지 명확하게 구분됨.
상태 공유 가능: 객체 내부에 변수나 캐시를 둘 수 있음.
유지보수 시 기능 단위로 관리 가능.


그룹화의 핵심점 차이점은 규모와 관리 용이성임
여기서 말하는 프로젝트 규모는 단순히 코드 줄 수가 아니라, 함수·클래스 수, 모듈 구조, 유지보수 복잡도를 기준으로 합니다. 구체적으로 정리하면 다음과 같습니다.

1. 함수/클래스 수
작은 규모: 관련 함수가 수십 개 이하, 파일 하나·두 개 정도로 관리 가능
중대형 규모: 함수 수가 수백 개 이상, 여러 엔티티·DTO 변환 함수가 존재
예: A(B(C)) 구조에서 엔티티가 많아 toA(), toB(), toC() 함수가 수십~수백 개로 늘어날 경우

2. 모듈/패키지 구조
작은 규모: 단일 모듈, 단순 패키지 구조, 의존성 적음
중대형 규모: 모듈이 여러 개, 패키지·계층 구조 복잡, 서로 다른 팀이 개발
그룹화가 명시적이지 않으면 유지보수가 어려워짐

3. 유지보수 복잡도
함수가 많거나 관련 기능이 서로 의존적일 때, 객체 단위 그룹화가 유지보수와 가독성에 도움
단순 유틸 함수만 존재하면 파일 함수로도 충분

4. 요약
작은 프로젝트: 관련 함수 수 적고, 단순 기능만 → 파일 함수
중대형 프로젝트: 함수 수 많고 관리 필요 → object로 묶어 명시적 그룹화
즉, 규모 판단 기준 = 함수/클래스 수 + 모듈/패키지 구조 + 유지보수 복잡도입니다.



차이점 비교 표
| 기준      | 파일 함수                                   | object 함수                                                 |
| ------- | --------------------------------------- | --------------------------------------------------------- |
| 상태 공유   | 불가                                      | 가능                                                        |
| 함수 호출   | `toA()`                                 | `EntityMapper.toA()`                                      |
| 그룹화 의미  | 파일명 외에는 명시적이지 않음                        | 객체 이름으로 명시적 그룹화 가능                                        |
| 관리 용이성  | 작은 프로젝트, 함수 수 적을 때 충분                   | 함수가 많거나 프로젝트 규모가 커서 유지보수 필요할 때 유리                         |
| 프로젝트 규모 | 작은 규모: 함수 수 적고 단순 구조                    | 중대형 규모: 함수 수 많고 모듈/패키지 구조 복잡, 유지보수 필요                     |
| 설계 목적   | 단순 유틸 함수, 상태 없는 독립 기능                   | 관련 함수 그룹화, 명시적 구분, 상태 관리 가능                               |
| 예시      | `fun A.toA()`, `fun B.toB()`를 같은 파일에 모음 | `object EntityMapper { fun A.toA() ... fun B.toB() ... }` |
