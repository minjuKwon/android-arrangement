콘텐츠 제공자(Content Provider)는 중앙 데이터 저장소에 대한 접근을 관리하는 역할을 합니다. Android 애플리케이션에서 이를 구현하려면 하나 이상의 클래스를 작성해야합니다. 작성한 클래스 중 하나는 ContentProvider의 서브클래스를 구현하며, 이 클래스가 바로 다른 애플리케이션과 콘텐츠 제공자 간의 인터페이스 역할을 하게 됩니다. 이외 보조적인 클래스가 필요한 경우도 있습니다. 또한 매니페스트 파일에 콘텐츠 제공자 요소들을 추가해야 합니다. 

콘텐츠 제공자는 주로 다른 애플리케이션에서 데이터를 사용할 수 있도록 제공하기 위한 것이지만, 애플리케이션 내의 액티비티(Activity)에서도 사용자로 하여금 제공자가 관리하는 데이터를 조회하고 수정할 수있습니다. 이 페이지에는 콘텐츠 제공업체를 구축하기 위한 기본 프로세스와 사용할 API 목록이 포함되어 있습니다.



1. 구현 시작 전
1)공급업체 사용 여부 결정
공급업체를 구현하기 전에 콘텐츠 제공업체가 필요한지 여부를 결정해야 합니다. 다음 기능 중 하나 이상을 제공하려면 콘텐츠 제공업체를 구현해야 합니다:
- 복잡한 데이터나 파일을 다른 애플리케이션에 제공하려고 합니다.
- 사용자가 앱에서 다른 앱으로 복잡한 데이터를 복사할 수 있도록 허용해야 합니다.
- 검색 프레임워크를 사용하여 사용자 지정 검색 제안을 제공하려고 합니다.
- 애플리케이션 데이터를 위젯에 노출하려고 합니다.
-  AbstractThreadedSyncAdapter, CursorAdapter 또는 CursorLoader 클래스를 구현하려고 합니다.

데이터베이스나 기타 유형의 영구 저장소를 사용하는 경우, 사용이 전적으로 **자신의 애플리케이션 내부에서만 이루어지고 앞서 나열된 기능들 중 어떤 것도 필요하지 않다면**, 콘텐츠 제공자가 필요하지 않습니다.


2)공급업체 구현 과정
이제 다음 단계에 따라 공급업체를 구현합니다:

ⅰ) 데이터를 저장할 방식을 정하세요. 콘텐츠 제공업체는 두 가지 방식으로 데이터를 제공합니다:
파일 데이터
일반적으로 사진, 오디오 또는 비디오와 같은 파일 형태의 데이터입니다. 파일을 응용 프로그램의 개인 공간에 저장합니다. 다른 응용 프로그램의 파일 요청에 응답하여 제공업체가 파일에 대한 접근 수단을 제공할 수 있습니다.
구조화된 데이터
일반적으로 데이터베이스, array 또는 이와 유사한 구조 형태의 데이터입니다. 행과 열의 테이블과 호환되는 형태로 데이터를 저장합니다. 행은 사람이나 인벤토리의 항목과 같은 엔터티를 나타냅니다. 열은 사람의 이름이나 항목 가격과 같은 엔터티에 대한 일부 데이터를 나타냅니다. 이러한 유형의 데이터를 저장하는 일반적인 방법은 SQLite 데이터베이스에 있지만 모든 유형의 영구 저장소에서도 사용할 수 있습니다.

ⅱ) 콘텐츠 제공자 클래스의 구체적인 구현과 필요한 메서드을 정의합니다. 콘텐츠 제공자 클래스는 사용자의 데이터와 나머지 Android 시스템 간의 인터페이스입니다. 

ⅲ) 제공자의 권한 문자열, 콘텐츠 URI 및 열 이름을 정의합니다. 제공자의 응용 프로그램이 intent를 처리하도록 하려면 intent action, 추가 데이터 및 플래그도 정의하세요. 또한 데이터에 액세스하려는 응용 프로그램에 필요한 권한을 정의합니다. 이 모든 값을 별도의 계약 클래스의 상수로 정의하는 것을 고려해 보세요. 나중에 이 클래스를 다른 개발자에게 노출할 수 있습니다. 

ⅳ) 샘플 데이터 또는 공급자와 클라우드 기반 데이터 간에 데이터를 동기화할 수 있는 AbstractThreadedSyncAdapter 구현과 같은 다른 선택적 과정도 추가할 수 있습니다.



2.데이터 저장소 설계
1)저장 방식
콘텐츠 공급자는 구조화된 형식으로 저장된 데이터에 대한 인터페이스입니다. 인터페이스를 만들기 전에 데이터를 저장하는 방법을 결정해야 합니다. 원하는 형식으로 데이터를 저장한 다음 필요에 따라 데이터를 읽고 쓸 수 있도록 인터페이스를 설계할 수 있습니다.
다음은 Android에서 사용할 수 있는 데이터 저장 기술 중 일부입니다:

- 구조화된 데이터를 사용하는 경우 SQLite와 같은 관계형 데이터베이스 또는 LevelDB와 같은 비관계형 키값 데이터스토어를 고려하세요. 오디오, 이미지 또는 비디오 미디어와 같은 비정형 데이터를 사용하는 경우 데이터를 파일로 저장하는 것을 고려하세요. 여러 유형의 저장 방식을 조합하여 사용할 수도 있고 필요한 경우 단일 콘텐츠 제공업체를 사용하여 노출할 수 있습니다.

- Android 자체 제공업체가 테이블 지향 데이터를 저장하는 데 사용하는 SQLite 데이터베이스 API에 대한 액세스를 제공하는 Room 지속성 라이브러리와 상호 작용할 수 있습니다. 이 라이브러리를 사용하여 데이터베이스를 만들려면 RoomDatabase의 하위 클래스를 인스턴스화합니다. 저장소를 구현하기 위해 데이터베이스를 사용할 필요는 없습니다. 공급자는 관계형 데이터베이스와 유사하한 테이블 집합으로 외부로 표시하지만 공급자의 내부 구현을 위한 필요 요건은 아닙니다.

- 파일 데이터를 저장하기 위해 Android에는 다양한 파일 지향 API가 있습니다. 음악이나 동영상과 같은 미디어 관련 데이터를 제공하는 공급자를 설계하는 경우 테이블 데이터와 파일을 결합한 공급자가 있습니다.

- 드물게는 단일 애플리케이션에 대해 두 개 이상의 콘텐츠 제공자를 구현하면 이점을 얻을 수 있습니다. 예를 들어, 하나의 콘텐츠 제공자를 사용하여 위젯과 일부 데이터를 공유하고 다른 애플리케이션과 공유하기 위해 다른 데이터 세트를 노출할 수 있습니다.

- 네트워크 기반 데이터로 작업하려면 java.net 및 android.net 의 클래스를 사용하세요. 네트워크 기반 데이터를 데이터베이스와 같은 로컬 데이터 저장소에 동기화한 다음 데이터를 테이블 또는 파일로 제공할 수도 있습니다.

저장소 호환이 맞지 않아서 버전을 변경을 할 경우, 저장소에 새로운 버전 번호를 지정해야 합니다. 또한, 새로운 콘텐츠 제공자를 구현하는 앱의 버전 번호도 증가시켜야 합니다. 앱 버전은 빌드 파일에 있는 버전 코드를 말합니다. 이 변경을 통해 시스템 다운그레이드가 발생할 때, 호환되지 않는 콘텐츠 제공자를 가진 앱을 재설치하려고 할 때 시스템이 충돌하는 것을 방지할 수 있습니다.


2)데이터 설계 고려사항
공급업체의 데이터 구조를 설계하기 위한 몇 가지 팁은 다음과 같습니다

- 테이블 데이터에는 항상 공급자가 각 행에 대해 고유한 숫자 값으로 유지하는 "기본 키" 열이 있어야 합니다. 이 값을 통해 외래 키를 사용하여 행을 다른 테이블의 관련 행에 연결할 수 있습니다. 기본키 열에는 어떤 이름도 사용할 수 있지만, 공급자 쿼리 결과를 ListView에 연결하려면 검색된 열 중 하나에 _ID라는 이름이 있어야 하므로 BaseColumns._ID를 사용하는 것이 가장 좋습니다.

- 만약 비트맵 이미지나 파일 기반의 매우 큰  데이터를 제공하려면, 데이터를 테이블에 직접 저장하는 대신 파일에 저장하고 간접적으로 제공해야 합니다. 이렇게 할 경우, 사용자에게 제공자의 데이터를 접근하기 위해 ContentResolver 파일 메서드를 사용해야 한다는 것을 알려야 합니다.

- 이진 대형 객체(BLOB) 데이터 유형을 사용하면 크기가 다르거나 구조가 다른 데이터를 저장할 수 있습니다. 예를 들어 BLOB 열을 사용하여 프로토콜 버퍼 또는 JSON 구조를 저장할 수 있습니다.

BLOB를 사용하여 스키마 독립 테이블을 구현할 수도 있습니다. 이 유형의 테이블에서는 기본 키 열, MIME 유형 열, BLOB 유형의 하나 이상의 일반 열로 정의할 수 있습니다. BLOB 열의 데이터의 의미는 MIME 유형 열의 값으로 표시됩니다. 이렇게 하면 동일한 테이블에 다양한 행 유형을 저장할 수 있습니다. 연락처 제공업체의 "데이터" 테이블 ContactContract.Data는 스키마 독립 테이블의 예입니다.



3. 콘텐츠 URI 설계
콘텐츠 URI는 제공자의 데이터를 식별하는 URI입니다. 콘텐츠 URI에는 전체 제공자(권한)의 상징적 이름과 테이블 또는 파일(경로)을 가리키는 이름이 포함됩니다. 옵션 ID 부분은 테이블의 개별 행을 가리킵니다. 콘텐츠 제공자의 모든 데이터 액세스 메서드에는 인수로 콘텐츠 URI를 받습니다. 이를 통해 액세스할 테이블, 행 또는 파일을 결정할 수 있습니다.

1)권한 설계
공급자는 일반적으로 Android 내부 이름으로 사용되는 단일 권한을 가지고 있습니다. 다른 공급자와의 충돌을 방지하려면 인터넷 도메인 소유권(반대로)을 공급자 권한의 기본으로 사용합니다. 이 권장 사항은 Android 패키지 이름에도 적용되므로 공급자 권한을 공급자가 포함된 패키지 이름의 확장으로 정의할 수 있습니다. 예를 들어, Android 패키지 이름이 com.example.<appname>인 경우 제공업체에 com.example.<appname>.provider 권한을 부여합니다.


2)경로 구조 설계
개발자는 일반적으로 개별 테이블을 가리키는 경로를 추가하여 권한에서 콘텐츠 URI를 생성합니다. 예를 들어, 테이블1과 테이블2의 두 개의 테이블이 있는 경우 이전 예제의 권한과 결합하여 com.example.<appname>.provider/table1 및 com.example.<appname>.provider/table2의 콘텐츠 URI를 생성할 수 있습니다. 경로는 단일 세그먼트로 제한되지 않습니다. 여러 '/'를 사용하여 계층적인 경로를 만들 수 있습니다. 경로의 각 레벨은 반드시 테이블을 나타낼 필요는 없으며, 특정 항목이나 행을 식별하는 데 사용될 수도 있습니다


3)콘텐츠 URI ID 처리
관례에 따라 공급자는 URI의 끝에 있는 행에 대한 ID 값을 가진 콘텐츠 URI를 수락하여 테이블의 단일 행에 대한 액세스를 제공합니다. 또한 관례에 따라 공급자는 ID 값을 테이블의 _ID 열에 일치시키고 요청된 액세스를 일치하는 행에 대해 수행합니다. 이 규칙은 제공업체에 액세스하는 앱의 일반적인 설계 패턴을 용이하게 합니다. 앱은 제공업체에 대한 쿼리를 수행하고 CursorAdapter를 사용하여 결과 Cursor를 ListView에 표시합니다. CursorAdapter의 정의에 따르면 Cursor의 열 중 하나는 _ID여야 합니다. 그런 다음 사용자는 UI에서 표시된 행 중 하나를 선택하여 데이터를 조회하거나 수정합니다. 앱은 ListView를 지원하는 Cursor에서 해당 행을 가져오고, 이 행의 _ID값을 가져와 콘텐츠 URI에 추가한 뒤, 액세스 요청을 제공자에게 보냅니다. 그러면 제공자는 사용자가 선택한 정확한 행에 대해 조회 또는 수정을 수행할 수 있습니다.다.


4)콘텐츠 URI 패턴
수신되는 콘텐츠 URI에 대해 수행할 작업을 선택하는 데 도움이 되도록 제공자 API에는 콘텐츠 URI 패턴을 정수 값에 매핑하는 편의 클래스 UriMatcher가 포함되어 있습니다. 특정 패턴과 일치하는 콘텐츠 URI 또는 URI에 대해 원하는 작업을 선택하는 switch 문에서 정수 값을 사용할 수 있습니다.

콘텐츠 URI 패턴은 와일드카드 문자를 사용하여 콘텐츠 URI와 일치합니다:
* 는 모든 길이의 유효한 문자 문자열이면 일치.
# 는 모든 길이의 숫자 문자열이면 일치.

콘텐츠 URI 처리를 설계하고 코딩하는 예로, 테이블을 가리키는 다음 콘텐츠 URI를 인식하는 com.example.app.provider 권한을 가진 공급자를 생각해 보세요
content://com.example.app.provider/table1: table1 테이블
content://com.example.app.provider/table2/dataset1: dataset1 테이블
content://com.example.app.provider/table2/dataset2: dataset2 테이블
content://com.example.app.provider/table3: table3 테이블

제공자는 콘텐츠 URI에 행 ID가 추가된 경우도 인식합니다. 예를 들어, content://com.example.app.provider/table3/1은 table3에서 ID가 1인 행을 식별하는 URI입니다.

다음과 같은 콘텐츠 URI 패턴도 가능합니다.
content://com.example.app.provider/*
제공자의 모든 content URI 일치
content://com.example.app.provider/table2/*
dataset1과 dataset2 테이블의 콘텐츠 UIR과 일치하지만 table1 이나 table3 콘텐츠 URI과는 일치하지 않음.
content://com.example.app.provider/table3/#
content://com.example.app.provider/table3/6 같이 6으로 식별되는 행처럼 table3의 단일 행의 콘텐츠 URI과 일치.

다음 코드 스니펫은 UriMatcher의 메서드들이 어떻게 작동하는지 보여줍니다. 이 코드는 URI를 처리할 때, 테이블 전체를 위한 URI와 단일 행을 위한 URI를 다르게 처리합니다. 테이블을 위한 URI는 content://<authority>/<path> 패턴을 사용하고 단일 행을 위한 URI content://<authority>/<path>/<id> 패턴을 사용합니다. addURI() 메서드는 권한와 경로를 정수 값에 매핑합니다. match() 메서드는 특정 URI에 대해 해당하는 정수 값을 반환합니다. 그리고 switch 문을 사용해 반환된 정수 값을 기준으로 테이블 전체를 조회할지, 단일 레코드를 조회할지 선택합니다.

public class ExampleProvider extends ContentProvider {
...
    //UriMatcher 객체 생성
    private static final UriMatcher uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);

    static {
        /*
         *여기에서 제공자가 인식하는 모든 콘텐츠 URI 패턴을 처리하기 위해 addURI()호출
	 * 이 코드의 경우 테이블 3에 대한 호출만 표시됩니다.
         */

       //테이블 3의 여러 행에 대해 정수 1 설정. 여기서는 와일드카드 사용 안함.
        uriMatcher.addURI("com.example.app.provider", "table3", 1);

        /*
         * 단일 행에 대해 2로 설정. 여기서는 # 와일드카드 사용
         * content://com.example.app.provider/table3/3 일치
         * content://com.example.app.provider/table3 불일치.
         */
        uriMatcher.addURI("com.example.app.provider", "table3/#", 2);
    }
...
    // ContentProvider.query() 구현
    public Cursor query(
        Uri uri,
        String[] projection,
        String selection,
        String[] selectionArgs,
        String sortOrder) {
...
        /*
         * 조회할 테이블과 정렬 순서는 들어오는 URI에 대해 반환된 코드에 따라 선택됩니다. 
	 * 여기에서도 table3에 대한 구문만 표시됩니다.
         */
        switch (uriMatcher.match(uri)) {


            // URI가 table3일 경우
            case 1:
                if (TextUtils.isEmpty(sortOrder)) sortOrder = "_ID ASC";
                break;

            // URI가 table3의 단일 행일 경우            
	    case 2:
                /*
                 * 해당 URI가 단일 행 포함하기에 _ID 값 존재.
                 * URI의 마지막 경로를 통해 _ID 값 얻음
                 * 쿼리의 WHERE 절에 값 추가
                 */
                selection = selection + "_ID = " + uri.getLastPathSegment();
                break;

            default:
            ...
                // URI 인식 불가일 경우에 대한 에러 처리
        }
        // 실제 쿼리 실행 코드
    }

ContentUris 클래스는 콘텐츠 URI의 id 부분을 처리하기 위한 편의 메서드를 제공합니다. 예를 들어 ContentUris.appendId() 있습니다. Uri 및 Uri.Builder 클래스는 기존 Uri 객체를 파싱하고 새로운 Uri 객체를 생성하기 위한 편의 메서드를 포함하고 있습니다. 위 코드에서 사용한 uri.getLastPathSegment()와 Uri.parse()등이 있습니다.



4. ContentProvider 클래스 구현
ContentProvider 인스턴스는 다른 애플리케이션의 요청을 처리하여 구조화된 데이터 세트에 대한 액세스를 관리합니다. 모든 형태의 액세스는 결국 ContentResolver를 호출한 다음 구체적인 방법의 ContentProvider를 호출하여 액세스를 얻습니다.

1)필요 메서드
추상 클래스 ContentProvider는 여섯 개의 추상 메서드를 정의하며, 이를 구체적인 서브클래스에서 구현해야 합니다. onCreate()를 제외한 이러한 모든 메서드는 콘텐츠 공급자에 액세스하려고 시도하는 클라이언트 애플리케이션에 의해 호출됩니다.

query()
공급업체를 통해 데이터 검색. 인수를 사용하여 쿼리할 테이블, 반환할 행과 열, 결과 정렬 순서 선택. 데이터를 cursor 개체로 반환.
insert()
공급자에 새 행을 삽입. 인수를 사용하여 대상 테이블을 선택하고 사용할 열 값을 가져옴. 새로 삽입한 행의 콘텐츠 URI를 반환.
update()
공급자의 기존 행을 업데이트. 인수를 사용하여 업데이트할 테이블과 행을 선택하고 업데이트된 열 값을 가져옴. 업데이트된 행의 수를 반환.
delete()
공급자에서 행을 삭제. 인수를 사용하여 테이블과 삭제할 행을 선택. 삭제한 행의 수를 반환합니다.
getType()
콘텐츠 URI에 대응하는 MIME 타입 리턴
onCreate()
제공자초기화. Android 시스템은 공급자 생성 즉후 이 메서드를 호출. 공급자는 ContentResolver 개체가 액세스를 시도할 때까지 생성되지 않음.

이 메서드들은 동일한 이름을 가진 ContentResolver 메서드들과 같은 구조를 가집니다. 이 메서드를 구현할 때는 다음 사항을 고려해야 합니다.
- onCreate()를 제외한 모든 메서드는 여러 스레드에서 동시에 호출될 수 있기 때문에 스레드 안전성을 고려해야 함.
- 시간이 오래 걸리는 작업은 onCreate()에서 처리하지 말고, 실제로 필요할 때 지연해서 처리해야 함.
- 메서드를 구현할 때 반드시 처리할 내용이 없다면, 예상된 데이터 타입을 반환하는 것만 해도 충분. 예를 들어, 데이터를 삽입하지 않으려면 insert() 호출을 무시하고 0을 반환 가능.


2)query() 구현
ContentProvider.query() 메서드는 Cursor 개체를 반환하거나 실패할 경우 예외를 던져야 합니다. 데이터 저장소로 SQLite 데이터베이스를 사용하는 경우, SQLiteDatabase 클래스에서 오버로드된 여러 query() 메서드 중 어느 것을 선택하든 Cursor를 반환받을 수 있습니다. 쿼리가 행과 일치하지 않는 경우 getCount() 메서드가 0을 반환하는 커서 인스턴스를 반환합니다. 쿼리 프로세스 중에 내부 오류가 발생한 경우에만 null을 반환합니다.

SQLite 데이터베이스를 데이터 저장소로 사용하지 않는 경우 Cursor의 구체적인 하위 클래스 중 하나를 사용합니다. 예를 들어, MatrixCursor 클래스는 각 행이 오브젝트 Object 배열인 커서를 구현합니다. 이 클래스에서는 adRow()를 사용하여 새 행을 추가합니다.

Android 시스템은 프로세스 경계를 넘어 예외를 통신할 수 있어야 합니다. Android는 쿼리 오류를 처리하는 데 유용한 다음 예외에 대해 이 작업을 수행할 수 있습니다:
-IllegalArgumentException:공업체가 잘못된 콘텐츠 URI를 수신하는 경우 사용
-NullPointerException


3)insert() 구현
insert() 메서드는 ContentValues 인수의 값을 사용하여 해당 테이블에 새 행을 추가합니다. 열 이름이 ContentValues 인수에 없는 경우를 대비하여 공급자 코드 또는 데이터베이스 스키마에 기본값을 설정할 수 있습니다. 이 메서드는 새 행의 콘텐츠 URI를 반환합니다. 이를 구성하려면 withAppendId()를 사용하여 새 행의 기본 키(_ID)를 테이블의 콘텐츠 URI에 추가합니다.


4)delete() 구현
꼭 delete()를 통해 데이터 저장소에서 행을 삭제할 필요가 없습니다. 공급업체와 동기화 어댑터를 사용하는 경우 삭제된 행을 완전히 제거하지 않고 "delete" 플래그로 표시하는 것을 고려하세요. 동기화 어댑터는 삭제된 행을 확인하고 서버에서 제거한 후 공급업체에서 삭제할 수 있습니다.


5)update() 구현
update() 메서드는 insert()에서 사용한 것과 동일한 ContentValues 인수와 delete() 및 ContentProvider.query()에서 사용한 것과 동일한 선택 및 선택Args 인수를 사용합니다. 이렇게 하면 이러한 메서드 간에 코드를 재사용할 수 있습니다.


6)onCreate() 구현
Android 시스템은 공급자를 시작할 때 OnCreate()를 호출합니다. 이 메서드로 빠르게 실행되는 초기화 작업만 수행하고 공급자가 실제로 데이터 요청을 받을 때까지 데이터베이스 생성 및 데이터 로딩을 연기합니다. onCreate()에서 긴 작업을 수행하면 공급자의 시작 속도가 느려집니다. 그러면 공급자가 다른 애플리케이션에 대해 응답하는 속도가 느려집니다.

다음 코드는 ContentProvider.onCreate()와 Room.databaseBuilder() 간의 상호 작용을 보여줍니다. 데이터베이스 개체가 구축되고 데이터 액세스 개체를 처리하는 ContentProvider.onCreate()의 구현을 보여줍니다:

public class ExampleProvider extends ContentProvider

    // Room 데이터베이스 참조 정의
    private AppDatabase appDatabase;
    //데이터 베이스 연산 수행을 위한 데이터 접근 객체 정의
    private UserDao userDao;
    // 데이터 베이스 이름 정의
    private static final String DBNAME = "mydb";

    public boolean onCreate() {

        // 새로운 데이터베이스 객체 생성
        appDatabase = Room.databaseBuilder(getContext(), AppDatabase.class, DBNAME).build();

        // 데이터 베이스 연산 수행을 위한 데이터 접근 객체 얻기
        userDao = appDatabase.getUserDao();

        return true;
    }
    ...
    // provider의 삽입 메서드 구현
    public Cursor insert(Uri uri, ContentValues values) {
	//데이터 삽입, 오류 조건 처리 등에 사용할 DAO를 결정할 코드
    }
}