이전 글의 content provider 생성 방법에 따라 직접 구현해보겠습니다. java와 kotlin 테이블를 만들고 각 테이블에 예제 코드 데이터가 있는 Content provider를 생성합니다. 그럼 외부 앱에서 해당 데이터를 쿼리하는 예제를 만들겁니다. 안드로이드 공식 문서에서 예제를 java나 kotlin으로 변환하고 해당 코드를 복사하는 흐름에서 따왔습니다.

1. Content Provider 앱
1)구현 시작 전
예제에 content provider가 진짜로 필요한지 생각해보겠습니다. 코드 데이터를 단순 문자열이 아닌 코드 제목과 내용으로 구성된 테이블로 관리할겁니다. 제목에는 코드가 어떤 내용인지 표시하고 내용에는 실제 코드를 저장하고 싶기 때문입니다. 테이블 형태의 데이터를 다른 앱으로 복사할 수 있도록 허용할 것이기에 content provider가 필요해보입니다.


2)데이터 저장소 설계 및 구현
테이블 형태의 구조화된 데이터이기 때문에 SQLite 관계형 데이터베이스에 저장하겠습니다. 물론 Room도 있지만 content provider 예제인 만큼 provider에 집중하기 위해 SQLite를 사용하겠습니다. 데이터 베이스와 java 및 kotlin 
테이블을 생성하면 됩니다. 각 테이블에는 기본 키를 위한 ID과 더불어 title과 content 열을 만듭니다.

- NotesDatabase.java

public class NotesDatabase extends SQLiteOpenHelper {

    private static final String DATABASE_NAME="notes.db";
    private static final int DATABASE_VERSION=1;

    public NotesDatabase(Context context){
        super(context,DATABASE_NAME,null,DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        final String SQLITE_CREATE_JAVA_TABLE=
                "CREATE TABLE "+ NotesContract.JavaNotesEntry.TABLE_NAME +"("+
                NotesContract.JavaNotesEntry._ID +" INTEGER PRIMARY KEY AUTOINCREMENT, "+
                NotesContract.JavaNotesEntry.COLUMN_TITLE+" TEXT NOT NULL, "+
                NotesContract.JavaNotesEntry.COLUMN_CONTENT+" TEXT NOT NULL);";

        final String SQLITE_CREATE_KOTLIN_TABLE=
                "CREATE TABLE "+ NotesContract.KotlinNotesEntry.TABLE_NAME +"("+
                NotesContract.KotlinNotesEntry._ID +" INTEGER PRIMARY KEY AUTOINCREMENT, "+
                NotesContract.KotlinNotesEntry.COLUMN_TITLE+" TEXT NOT NULL, "+
                NotesContract.KotlinNotesEntry.COLUMN_CONTENT+" TEXT NOT NULL);";

        db.execSQL(SQLITE_CREATE_JAVA_TABLE);
        db.execSQL(SQLITE_CREATE_KOTLIN_TABLE);
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        db.execSQL("DROP TABLE IF EXISTS "+ NotesContract.JavaNotesEntry.TABLE_NAME);
        db.execSQL("DROP TABLE IF EXISTS "+ NotesContract.KotlinNotesEntry.TABLE_NAME);
        onCreate(db);
    }

}

코드에 사용된 상수는 contract class 구현 부분에 설명하겠습니다.


3)콘텐츠 URI 설계
Content provider를 구현하기 전, provider의 데이터를 식별하기 위한 URI를 설계할겁니다. 콘텐츠 URI는 provider 권한과 경로로 구성됩니다. 권한은 고유성을 위해 패키지 이름을 활용할 것입니다. 경로는 개별 테이블을 가리키기 위해 필요합니다. 단지 권한에서 java와 kotlin 테이블 명을 추가하면 됩니다. 테이블 전체 데이터뿐만 아니라 테이블의 특정 데이터 또한 가져오고 싶기 때문에 각 행의 ID를 더하기도 할겁니다.

그럼 현재 java와 kotlin 테이블에 대한 URI와 각 테이블의 특정 데이터를 가져올 URI가 필요하기 때문에 총 4개가 필요해집니다.여러 개의 URI를 쉽게 작업하기 위해 UriMatcher를 사용할겁니다. URI는 비교적 복잡하고 길이가 길기 때문에 URI에 대한 상수를 정의하고 해당 상수를 이용하여 작업을 수행할겁니다. 콘텐츠 URI에 정수 값을 매핑하기 위해서는 addURI()를 사용하면 됩니다. addURI()의 매개변수로 권한, 경로, 정수 값을 전달하면 됩니다. 권한과 경로를 나누지 않고 바로 URI를 전달 할 수도 있습니다. 하지만 공통된 권한을 가지고 경로에만 차이가 있기 때문에 각각 상수로 정의하여 전달하겠습니다. 상수로 관리하는 것이 활용하기도 편합니다. provider에 관한 상수는 추후 설명할 contract파일에 정의하였습니다. Uri 패턴은 content provider 구현 파일에 작성하였습니다.

private static final int URI_CODE_JAVA_TABLE=1;
private static final int URI_CODE_JAVA_TABLE_ID=2;
private static final int URI_CODE_KOTLIN_TABLE=3;
private static final int URI_CODE_KOTLIN_TABLE_ID=4;

private static final UriMatcher uriMatcher=new UriMatcher(UriMatcher.NO_MATCH);

static{
        uriMatcher.addURI(AUTHORITY,TABLE_JAVA,URI_CODE_JAVA_TABLE);//java 테이블 전체를 위한 URI
        uriMatcher.addURI(AUTHORITY,TABLE_JAVA+"/#",URI_CODE_JAVA_TABLE_ID);//java 테이블 단일 행을 위한 URI
        uriMatcher.addURI(AUTHORITY,TABLE_KOTLIN,URI_CODE_KOTLIN_TABLE);//kotlin 테이블 전체를 위한 URI
        uriMatcher.addURI(AUTHORITY,TABLE_KOTLIN+"/#",URI_CODE_KOTLIN_TABLE_ID);/kotlin 테이블 단일 행을 위한 URI
    }

UriMatcher 생성자에 전달한 UriMatcher.NO_MATCH는 일치하는 패턴이 없을 때 반환하는 값으로 -1입니다.


4)ContentProvider 클래스 구현
이제 실제로 provider를 구현해보겠습니다. provider는 6개의 추상 메서드를 가집니다. onCreate(), insert(), delete(), update(), query(), getType()를 구현해야합니다. 

우선 onCreate()는 provider가 시작할 때 호출되기에 초기화 작업만 수행해야 합니다. 데이터베이스 도우미 클래스만 생성하도록 하겠습니다.

 private NotesDatabase notesDatabase;
 @Override
    public boolean onCreate() {
        notesDatabase=new NotesDatabase(getContext());
        return true;
    }

insert()에는 단순히 데이터베이스에 데이터를 추가 하면 됩니다. 앞서 생성한 데이터베이스 도우미 클래스를 통해 데이터베이스 인스턴스를 생성하고 인스턴스를 이용하여 insert() 호출하면 됩니다. 다만 저희는 2가지의 테이블을 가지기 때문에 이를 구분해줘야합니다. UriMatcher의 match()를 통해 Uri에 매핑한 정수 값에 따라 추가할 테이블을 달리하면 됩니다. 매핑한 정수 이외 값이 반환되면 유효하지 않는 URI에 대한 예외를 던집니다.

    @Nullable
    @Override
    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {
        long id=-1L;
        SQLiteDatabase db=notesDatabase.getWritableDatabase();

        switch (uriMatcher.match(uri)){
            case URI_CODE_JAVA_TABLE:
                id=db.insert(TABLE_JAVA,null,values);
                break;
            case URI_CODE_KOTLIN_TABLE:
                id=db.insert(TABLE_KOTLIN,null,values);
                break;
            default:
                throwInvalidUriException(uri);
        }

        if(id>0) notifyChange(uri);
        else Toast.makeText(getContext(),
                Objects.requireNonNull(getContext()).getString(R.string.invalid_value),
                Toast.LENGTH_LONG).show();
        
        return ContentUris.withAppendedId(uri,id);
    }

  private void notifyChange(Uri uri){
        Objects.requireNonNull(getContext(),"Context cannot be null")
                .getContentResolver().notifyChange(uri,null);
    }

    private void throwInvalidUriException(Uri uri) {
        throw new InvalidUriException(uri.toString());
    }

    private static class InvalidUriException extends RuntimeException{
        public InvalidUriException(String uri){
            super("Invalid uri"+uri);
        }
    }

db는 재활용하지 않고 메서드에서 새롭게 생성하였습니다. SQLiteDatabase는 스레드를 따로 관리하지 않기 때문에 한 스레드에서 삽입이나 쿼리가 동시에 발생할 수 있기 때문입니다. 독립적으로 호출하여 사용합니다. 또한 SQLiteOpenHelper는 내부적으로 캐시된 SQLiteDatabase 객체를 반환하기에 실질적으로 매번 새롭게 생성하지 않습니다. 물론 호출 비용은 존재하지만 부담스러울 정도는 아니죠.
데이터베이스의 insert()는 삽입한 행의 ID를 반환합니다. provider의 insert()는 삽입 행의 URI를 반환해야하기 때문에 withAppendedId() 이용하여 기존 URI에 ID값을 더해줍니다. 메서드명이 직관적이라 설명은 따로 필요 없을 겁니다. 
또한 데이터베이스의 insert()는 에러 발생 시 -1를 반환하기에 문제 시 이를 알릴 수 있는 Toast를 표시합니다. 성공적으로 삽입했다면 notifyChange() 통해서 변경 사항을 Content Observer에게 알립니다. Content Observer에 대해서는 조금 있다가 설명을 하겠습니다. 지금은 그저 변경 사항을 알리는 메서드라고 알아주세요.

delete()입니다. insert() 구조와 비슷합니다. 다만 데이터베이스의 delete()는 삭제된 행의 수를 반환하고 provider의 delete()도 삭제된 행의 수를 반환해야하므로 삭제 메서드의 반환 값을 그대로 이용하면 됩니다.

   @Override
    public int delete(@NonNull Uri uri, @Nullable String selection,
                      @Nullable String[] selectionArgs) {
        int rowsDeleted=0;
        SQLiteDatabase db=notesDatabase.getWritableDatabase();

        switch (uriMatcher.match(uri)){
            case URI_CODE_JAVA_TABLE:
                rowsDeleted=db.delete(TABLE_JAVA,selection,selectionArgs);
                break;
            case URI_CODE_KOTLIN_TABLE:
                rowsDeleted=db.delete(TABLE_KOTLIN,selection,selectionArgs);
                break;
            default:
                throwInvalidUriException(uri);
        }

        if(rowsDeleted>0) notifyChange(uri);
        else Toast.makeText(getContext(),
                Objects.requireNonNull(getContext()).getString(R.string.invalid_value),
                Toast.LENGTH_LONG).show();

        return rowsDeleted;
    } 

update()도 위와 비슷한 로직을 따라갑니다. delete()와 마찬가지로 수정된 행의 수를 반환합니다.

  @Override
    public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection,
                      @Nullable String[] selectionArgs) {
        int rowsUpdated=0;
        SQLiteDatabase db=notesDatabase.getWritableDatabase();

        switch (uriMatcher.match(uri)){
            case URI_CODE_JAVA_TABLE:
                rowsUpdated=db.update(TABLE_JAVA,values, selection,selectionArgs);
                break;
            case URI_CODE_KOTLIN_TABLE:
                rowsUpdated=db.update(TABLE_KOTLIN,values,selection,selectionArgs);
                break;
            default:
                throwInvalidUriException(uri);
        }

        if(rowsUpdated>0) notifyChange(uri);
        else Toast.makeText(getContext(),
                Objects.requireNonNull(getContext()).getString(R.string.invalid_value),
                Toast.LENGTH_LONG).show();

        return rowsUpdated;
    }

다음은 query()입니다. 큰 틀은 비슷하지만 조금 다릅니다. 위의 메서드와 달리 데이터베이스를 getWritableDatabase()가 아닌getReadableDatabase()으로 얻습니다. query()는 데이터 검색하는 메서드로 어떠한 변경도 발생하지 않기에 읽기 모드면 충분합니다. 또한 getContentResolver().notifyChange() 대신 Cursor.setNotificationUri()를 사용하여 데이터 변경을 알립니다. 이에 대한 설명 역시 조금만 더 후에 하도록 하겠습니다. 데이터베이스와 provider의 query() 모두 검색된 데이터를 Cursor 형태로 반환합니다.

   @Nullable
    @Override
    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection,
                        @Nullable String[] selectionArgs, @Nullable String sortOrder) {
        Cursor cursor=null;
        SQLiteDatabase db=notesDatabase.getReadableDatabase();

        switch(uriMatcher.match(uri)){
            case URI_CODE_JAVA_TABLE:
            case URI_CODE_JAVA_TABLE_ID:
                cursor=db.query(TABLE_JAVA,projection,selection,selectionArgs,
                        null,null,sortOrder);
                break;
            case URI_CODE_KOTLIN_TABLE:
            case URI_CODE_KOTLIN_TABLE_ID:
                cursor=db.query(TABLE_KOTLIN,projection,selection,selectionArgs,
                        null,null,sortOrder);
                break;
            default:
                throwInvalidUriException(uri);
        }

        cursor.setNotificationUri(
                Objects.requireNonNull(getContext(),"Context cannot be null")
                        .getContentResolver()
                ,uri );
        return cursor;
    }

마지막으로 getType()으로 데이터 유형을 MIME형식으로 반환합니다. 이때 데이터 유형은 컨텐츠 URI 유형을 말하므로 직접 MIME를 생성해야합니다. 유형은 vnd가 되고 하위 부분은 단일 행의 경우 android.cursor.item/, 여러 행의 경우 android.cursor.dir/로 생성해야합니다. 그리고 구분하기 위해 vnd.<name>.<type> 형식으로 더해야합니다.

 @Nullable
    @Override
    public String getType(@NonNull Uri uri) {
        switch (uriMatcher.match(uri)){
            case URI_CODE_JAVA_TABLE:
                return "vnd.android.cursor.dir/vnd.com.example.content-provider/java";
            case URI_CODE_JAVA_TABLE_ID:
                return "vnd.android.cursor.item/vnd.com.example.content-provider/java";
            case URI_CODE_KOTLIN_TABLE:
                return "vnd.android.cursor.dir/vnd.com.example.content-provider/kotlin";
            case URI_CODE_KOTLIN_TABLE_ID:
                return "vnd.android.cursor.item/vnd.com.example.content-provider/kotlin";
            default:
                throwInvalidUriException(uri);
                return "";
        }
    }


5)Contract class 구현
Contract class는 provider와 관련된 URI, 권한, 열 이름 등에 대한 상수 정의를 포함하는 public final class입니다. 앞에 코드에서 사용한 상수 대부분이 여기에 생성한 것들입니다. 

public final class NotesContract {

    public static final String AUTHORITY="com.example.content-provider";
    public static final String TABLE_JAVA="java_notes";
    public static final String TABLE_KOTLIN="kotlin_notes";
    public static final Uri BASE_CONTENT_URI=Uri.parse("content://"+AUTHORITY);

    public static final class JavaNotesEntry implements BaseColumns {
        static final Uri CONTENT_URI=Uri.withAppendedPath(BASE_CONTENT_URI,TABLE_JAVA);
        static final String TABLE_NAME="java_notes";
        static final String COLUMN_TITLE="title";
        static final String COLUMN_CONTENT="content";
    }

    public static final class KotlinNotesEntry implements BaseColumns{
        static final Uri CONTENT_URI=Uri.withAppendedPath(BASE_CONTENT_URI,TABLE_KOTLIN);
        static final String TABLE_NAME="kotlin_notes";
        static final String COLUMN_TITLE="title";
        static final String COLUMN_CONTENT="content";
    }

}

내부 클래스는 각 테이블에 대한 상수를 선언하고 있습니다. 테이블에 대한 URI는 공통된 콘텐츠 URI에 경로를 추가하여 생성하였습니다. BaseColumns는 내부적으로 _ID와 _COUNT를 추가해줍니다. 테이블의 기본키를 BaseColumns 인터페이스를 통해 상속받아 사용하는 겁니다.


6)Permission 구현 
저희가 구현하는 provider는 provider 앱에서 관리하는 데이터를 외부에서 복사해가는 예제입니다. 즉, provider 생성 앱에서 삽입, 삭제, 업데이트를 하고 외부 앱에서 provider에 대한 데이터를 쿼리할겁니다. 외부에서 의도하지 않게 데이터를 변경할 수도 있기 때문에 write를 하지 못하도록 접근을 막을 겁니다. 이를 위해서는 manifest에서 writePermission를 설정하면 됩니다.

<provider
            android:authorities="com.example.content-provider"
            android:name=".NotesContentProvider"
            android:writePermission="com.example.content-provider.WRITE_PERMISSION"
            android:exported="true" />