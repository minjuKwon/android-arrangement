이전 글의 content provider 생성 방법에 따라 직접 구현해보겠습니다. java와 kotlin 테이블를 만들고 각 테이블에 예제 코드 데이터가 있는 Content provider를 생성합니다. 그럼 외부 앱에서 해당 데이터를 쿼리하는 예제를 만들겁니다. 안드로이드 공식 문서에서 예제를 java나 kotlin으로 변환하고 해당 코드를 복사하는 흐름에서 따왔습니다.

1. Content Provider 앱
1)구현 시작 전
예제에 content provider가 진짜로 필요한지 생각해보겠습니다. 코드 데이터를 단순 문자열이 아닌 코드 제목과 내용으로 구성된 테이블로 관리할겁니다. 제목에는 코드가 어떤 내용인지 표시하고 내용에는 실제 코드를 저장하고 싶기 때문입니다. 테이블 형태의 데이터를 다른 앱으로 복사할 수 있도록 허용할 것이기에 content provider가 필요해보입니다.


2)데이터 저장소 설계 및 구현
테이블 형태의 구조화된 데이터이기 때문에 SQLite 관계형 데이터베이스에 저장하겠습니다. 물론 Room도 있지만 content provider 예제인 만큼 provider에 집중하기 위해 SQLite를 사용하겠습니다. 데이터 베이스와 java 및 kotlin 
테이블을 생성하면 됩니다. 각 테이블에는 기본 키를 위한 ID과 더불어 title과 content 열을 만듭니다.

- NotesDatabase.java

public class NotesDatabase extends SQLiteOpenHelper {

    private static final String DATABASE_NAME="notes.db";
    private static final int DATABASE_VERSION=1;

    public NotesDatabase(Context context){
        super(context,DATABASE_NAME,null,DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        final String SQLITE_CREATE_JAVA_TABLE=
                "CREATE TABLE "+ NotesContract.JavaNotesEntry.TABLE_NAME +"("+
                NotesContract.JavaNotesEntry._ID +" INTEGER PRIMARY KEY AUTOINCREMENT, "+
                NotesContract.JavaNotesEntry.COLUMN_TITLE+" TEXT NOT NULL, "+
                NotesContract.JavaNotesEntry.COLUMN_CONTENT+" TEXT NOT NULL);";

        final String SQLITE_CREATE_KOTLIN_TABLE=
                "CREATE TABLE "+ NotesContract.KotlinNotesEntry.TABLE_NAME +"("+
                NotesContract.KotlinNotesEntry._ID +" INTEGER PRIMARY KEY AUTOINCREMENT, "+
                NotesContract.KotlinNotesEntry.COLUMN_TITLE+" TEXT NOT NULL, "+
                NotesContract.KotlinNotesEntry.COLUMN_CONTENT+" TEXT NOT NULL);";

        db.execSQL(SQLITE_CREATE_JAVA_TABLE);
        db.execSQL(SQLITE_CREATE_KOTLIN_TABLE);
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        db.execSQL("DROP TABLE IF EXISTS "+ NotesContract.JavaNotesEntry.TABLE_NAME);
        db.execSQL("DROP TABLE IF EXISTS "+ NotesContract.KotlinNotesEntry.TABLE_NAME);
        onCreate(db);
    }

}

코드에 사용된 상수는 contract class 구현 부분에 설명하겠습니다.


3)콘텐츠 URI 설계
Content provider를 구현하기 전, provider의 데이터를 식별하기 위한 URI를 설계할겁니다. 콘텐츠 URI는 provider 권한과 경로로 구성됩니다. 권한은 고유성을 위해 패키지 이름을 활용할 것입니다. 경로는 개별 테이블을 가리키기 위해 필요합니다. 단지 권한에서 java와 kotlin 테이블 명을 추가하면 됩니다. 테이블 전체 데이터뿐만 아니라 테이블의 특정 데이터 또한 가져오고 싶기 때문에 각 행의 ID를 더하기도 할겁니다.

그럼 현재 java와 kotlin 테이블에 대한 URI와 각 테이블의 특정 데이터를 가져올 URI가 필요하기 때문에 총 4개가 필요해집니다.여러 개의 URI를 쉽게 작업하기 위해 UriMatcher를 사용할겁니다. URI는 비교적 복잡하고 길이가 길기 때문에 URI에 대한 상수를 정의하고 해당 상수를 이용하여 작업을 수행할겁니다. 콘텐츠 URI에 정수 값을 매핑하기 위해서는 addURI()를 사용하면 됩니다. addURI()의 매개변수로 권한, 경로, 정수 값을 전달하면 됩니다. 권한과 경로를 나누지 않고 바로 URI를 전달 할 수도 있습니다. 하지만 공통된 권한을 가지고 경로에만 차이가 있기 때문에 각각 상수로 정의하여 전달하겠습니다. 상수로 관리하는 것이 활용하기도 편합니다. provider에 관한 상수는 추후 설명할 contract파일에 정의하였습니다. Uri 패턴은 content provider 구현 파일에 작성하였습니다.

private static final int URI_CODE_JAVA_TABLE=1;
private static final int URI_CODE_JAVA_TABLE_ID=2;
private static final int URI_CODE_KOTLIN_TABLE=3;
private static final int URI_CODE_KOTLIN_TABLE_ID=4;

private static final UriMatcher uriMatcher=new UriMatcher(UriMatcher.NO_MATCH);

static{
        uriMatcher.addURI(AUTHORITY,TABLE_JAVA,URI_CODE_JAVA_TABLE);//java 테이블 전체를 위한 URI
        uriMatcher.addURI(AUTHORITY,TABLE_JAVA+"/#",URI_CODE_JAVA_TABLE_ID);//java 테이블 단일 행을 위한 URI
        uriMatcher.addURI(AUTHORITY,TABLE_KOTLIN,URI_CODE_KOTLIN_TABLE);//kotlin 테이블 전체를 위한 URI
        uriMatcher.addURI(AUTHORITY,TABLE_KOTLIN+"/#",URI_CODE_KOTLIN_TABLE_ID);/kotlin 테이블 단일 행을 위한 URI
    }

UriMatcher 생성자에 전달한 UriMatcher.NO_MATCH는 일치하는 패턴이 없을 때 반환하는 값으로 -1입니다.


4)ContentProvider 클래스 구현
이제 실제로 provider를 구현해보겠습니다. provider는 6개의 추상 메서드를 가집니다. onCreate(), insert(), delete(), update(), query(), getType()를 구현해야합니다. 

우선 onCreate()는 provider가 시작할 때 호출되기에 초기화 작업만 수행해야 합니다. 데이터베이스 도우미 클래스만 생성하도록 하겠습니다.

 private NotesDatabase notesDatabase;
 @Override
    public boolean onCreate() {
        notesDatabase=new NotesDatabase(getContext());
        return true;
    }

insert()에는 단순히 데이터베이스에 데이터를 추가 하면 됩니다. 앞서 생성한 데이터베이스 도우미 클래스를 통해 데이터베이스 인스턴스를 생성하고 인스턴스를 이용하여 insert() 호출하면 됩니다. 다만 저희는 2가지의 테이블을 가지기 때문에 이를 구분해줘야합니다. UriMatcher의 match()를 통해 Uri에 매핑한 정수 값에 따라 추가할 테이블을 달리하면 됩니다. 매핑한 정수 이외 값이 반환되면 유효하지 않는 URI에 대한 예외를 던집니다.

    @Nullable
    @Override
    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {
        long id=-1L;
        SQLiteDatabase db=notesDatabase.getWritableDatabase();

        switch (uriMatcher.match(uri)){
            case URI_CODE_JAVA_TABLE:
                id=db.insert(TABLE_JAVA,null,values);
                break;
            case URI_CODE_KOTLIN_TABLE:
                id=db.insert(TABLE_KOTLIN,null,values);
                break;
            default:
                throwInvalidUriException(uri);
        }

        if(id>0) notifyChange(uri);
        else Toast.makeText(getContext(),
                Objects.requireNonNull(getContext()).getString(R.string.invalid_value),
                Toast.LENGTH_LONG).show();
        
        return ContentUris.withAppendedId(uri,id);
    }

  private void notifyChange(Uri uri){
        Objects.requireNonNull(getContext(),"Context cannot be null")
                .getContentResolver().notifyChange(uri,null);
    }

    private void throwInvalidUriException(Uri uri) {
        throw new InvalidUriException(uri.toString());
    }

    private static class InvalidUriException extends RuntimeException{
        public InvalidUriException(String uri){
            super("Invalid uri"+uri);
        }
    }

db는 재활용하지 않고 메서드에서 새롭게 생성하였습니다. SQLiteDatabase는 스레드를 따로 관리하지 않기 때문에 한 스레드에서 삽입이나 쿼리가 동시에 발생할 수 있기 때문입니다. 독립적으로 호출하여 사용합니다. 또한 SQLiteOpenHelper는 내부적으로 캐시된 SQLiteDatabase 객체를 반환하기에 실질적으로 매번 새롭게 생성하지 않습니다. 물론 호출 비용은 존재하지만 부담스러울 정도는 아니죠.
데이터베이스의 insert()는 삽입한 행의 ID를 반환합니다. provider의 insert()는 삽입 행의 URI를 반환해야하기 때문에 withAppendedId() 이용하여 기존 URI에 ID값을 더해줍니다. 메서드명이 직관적이라 설명은 따로 필요 없을 겁니다. 
또한 데이터베이스의 insert()는 에러 발생 시 -1를 반환하기에 문제 시 이를 알릴 수 있는 Toast를 표시합니다. 성공적으로 삽입했다면 notifyChange() 통해서 변경 사항을 Content Observer에게 알립니다. Content Observer에 대해서는 조금 있다가 설명을 하겠습니다. 지금은 그저 변경 사항을 알리는 메서드라고 알아주세요.

delete()입니다. insert() 구조와 비슷합니다. 다만 데이터베이스의 delete()는 삭제된 행의 수를 반환하고 provider의 delete()도 삭제된 행의 수를 반환해야하므로 삭제 메서드의 반환 값을 그대로 이용하면 됩니다.

   @Override
    public int delete(@NonNull Uri uri, @Nullable String selection,
                      @Nullable String[] selectionArgs) {
        int rowsDeleted=0;
        SQLiteDatabase db=notesDatabase.getWritableDatabase();

        switch (uriMatcher.match(uri)){
            case URI_CODE_JAVA_TABLE:
                rowsDeleted=db.delete(TABLE_JAVA,selection,selectionArgs);
                break;
            case URI_CODE_KOTLIN_TABLE:
                rowsDeleted=db.delete(TABLE_KOTLIN,selection,selectionArgs);
                break;
            default:
                throwInvalidUriException(uri);
        }

        if(rowsDeleted>0) notifyChange(uri);
        else Toast.makeText(getContext(),
                Objects.requireNonNull(getContext()).getString(R.string.invalid_value),
                Toast.LENGTH_LONG).show();

        return rowsDeleted;
    } 

update()도 위와 비슷한 로직을 따라갑니다. delete()와 마찬가지로 수정된 행의 수를 반환합니다.

  @Override
    public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection,
                      @Nullable String[] selectionArgs) {
        int rowsUpdated=0;
        SQLiteDatabase db=notesDatabase.getWritableDatabase();

        switch (uriMatcher.match(uri)){
            case URI_CODE_JAVA_TABLE:
                rowsUpdated=db.update(TABLE_JAVA,values, selection,selectionArgs);
                break;
            case URI_CODE_KOTLIN_TABLE:
                rowsUpdated=db.update(TABLE_KOTLIN,values,selection,selectionArgs);
                break;
            default:
                throwInvalidUriException(uri);
        }

        if(rowsUpdated>0) notifyChange(uri);
        else Toast.makeText(getContext(),
                Objects.requireNonNull(getContext()).getString(R.string.invalid_value),
                Toast.LENGTH_LONG).show();

        return rowsUpdated;
    }

다음은 query()입니다. 큰 틀은 비슷하지만 조금 다릅니다. 위의 메서드와 달리 데이터베이스를 getWritableDatabase()가 아닌getReadableDatabase()으로 얻습니다. query()는 데이터 검색하는 메서드로 어떠한 변경도 발생하지 않기에 읽기 모드면 충분합니다. 또한 getContentResolver().notifyChange() 대신 Cursor.setNotificationUri()를 사용하여 데이터 변경을 알립니다. 이에 대한 설명 역시 조금만 더 후에 하도록 하겠습니다. 데이터베이스와 provider의 query() 모두 검색된 데이터를 Cursor 형태로 반환합니다.

   @Nullable
    @Override
    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection,
                        @Nullable String[] selectionArgs, @Nullable String sortOrder) {
        Cursor cursor=null;
        SQLiteDatabase db=notesDatabase.getReadableDatabase();

        switch(uriMatcher.match(uri)){
            case URI_CODE_JAVA_TABLE:
            case URI_CODE_JAVA_TABLE_ID:
                cursor=db.query(TABLE_JAVA,projection,selection,selectionArgs,
                        null,null,sortOrder);
                break;
            case URI_CODE_KOTLIN_TABLE:
            case URI_CODE_KOTLIN_TABLE_ID:
                cursor=db.query(TABLE_KOTLIN,projection,selection,selectionArgs,
                        null,null,sortOrder);
                break;
            default:
                throwInvalidUriException(uri);
        }

        cursor.setNotificationUri(
                Objects.requireNonNull(getContext(),"Context cannot be null")
                        .getContentResolver()
                ,uri );
        return cursor;
    }

마지막으로 getType()으로 데이터 유형을 MIME형식으로 반환합니다. 이때 데이터 유형은 컨텐츠 URI 유형을 말하므로 직접 MIME를 생성해야합니다. 유형은 vnd가 되고 하위 부분은 단일 행의 경우 android.cursor.item/, 여러 행의 경우 android.cursor.dir/로 생성해야합니다. 그리고 구분하기 위해 vnd.<name>.<type> 형식으로 더해야합니다.

 @Nullable
    @Override
    public String getType(@NonNull Uri uri) {
        switch (uriMatcher.match(uri)){
            case URI_CODE_JAVA_TABLE:
                return "vnd.android.cursor.dir/vnd.com.example.content-provider/java";
            case URI_CODE_JAVA_TABLE_ID:
                return "vnd.android.cursor.item/vnd.com.example.content-provider/java";
            case URI_CODE_KOTLIN_TABLE:
                return "vnd.android.cursor.dir/vnd.com.example.content-provider/kotlin";
            case URI_CODE_KOTLIN_TABLE_ID:
                return "vnd.android.cursor.item/vnd.com.example.content-provider/kotlin";
            default:
                throwInvalidUriException(uri);
                return "";
        }
    }

ContentProvider 구현 전체 코드입니다.

- NotesContentProvider.java

public class NotesContentProvider extends ContentProvider {

    private static final int URI_CODE_JAVA_TABLE=1;
    private static final int URI_CODE_JAVA_TABLE_ID=2;
    private static final int URI_CODE_KOTLIN_TABLE=3;
    private static final int URI_CODE_KOTLIN_TABLE_ID=4;

    private NotesDatabase notesDatabase;
    private static final UriMatcher uriMatcher=new UriMatcher(UriMatcher.NO_MATCH);

    static{
        uriMatcher.addURI(AUTHORITY,TABLE_JAVA,URI_CODE_JAVA_TABLE);
        uriMatcher.addURI(AUTHORITY,TABLE_JAVA+"/#",URI_CODE_JAVA_TABLE_ID);
        uriMatcher.addURI(AUTHORITY,TABLE_KOTLIN,URI_CODE_KOTLIN_TABLE);
        uriMatcher.addURI(AUTHORITY,TABLE_KOTLIN+"/#",URI_CODE_KOTLIN_TABLE_ID);
    }

    @Override
    public boolean onCreate() {
        notesDatabase=new NotesDatabase(getContext());
        return true;
    }

    @Nullable
    @Override
    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection,
                        @Nullable String[] selectionArgs, @Nullable String sortOrder) {
        Cursor cursor=null;
        SQLiteDatabase db=notesDatabase.getReadableDatabase();

        switch(uriMatcher.match(uri)){
            case URI_CODE_JAVA_TABLE:
            case URI_CODE_JAVA_TABLE_ID:
                cursor=db.query(TABLE_JAVA,projection,selection,selectionArgs,
                        null,null,sortOrder);
                break;
            case URI_CODE_KOTLIN_TABLE:
            case URI_CODE_KOTLIN_TABLE_ID:
                cursor=db.query(TABLE_KOTLIN,projection,selection,selectionArgs,
                        null,null,sortOrder);
                break;
            default:
                throwInvalidUriException(uri);
        }

        cursor.setNotificationUri(
                Objects.requireNonNull(getContext(),"Context cannot be null")
                        .getContentResolver()
                ,uri );
        return cursor;
    }

    @Nullable
    @Override
    public String getType(@NonNull Uri uri) {
        switch (uriMatcher.match(uri)){
            case URI_CODE_JAVA_TABLE:
                return "vnd.android.cursor.dir/vnd.com.example.content-provider/java";
            case URI_CODE_JAVA_TABLE_ID:
                return "vnd.android.cursor.item/vnd.com.example.content-provider/java";
            case URI_CODE_KOTLIN_TABLE:
                return "vnd.android.cursor.dir/vnd.com.example.content-provider/kotlin";
            case URI_CODE_KOTLIN_TABLE_ID:
                return "vnd.android.cursor.item/vnd.com.example.content-provider/kotlin";
            default:
                throwInvalidUriException(uri);
                return "";
        }
    }

    @Nullable
    @Override
    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {
        long id=-1L;
        SQLiteDatabase db=notesDatabase.getWritableDatabase();

        switch (uriMatcher.match(uri)){
            case URI_CODE_JAVA_TABLE:
                id=db.insert(TABLE_JAVA,null,values);
                break;
            case URI_CODE_KOTLIN_TABLE:
                id=db.insert(TABLE_KOTLIN,null,values);
                break;
            default:
                throwInvalidUriException(uri);
        }

        if(id>0) notifyChange(uri);
        else Toast.makeText(getContext(),
                Objects.requireNonNull(getContext()).getString(R.string.invalid_value),
                Toast.LENGTH_LONG).show();
        
        return ContentUris.withAppendedId(uri,id);
    }

    @Override
    public int delete(@NonNull Uri uri, @Nullable String selection,
                      @Nullable String[] selectionArgs) {
        int rowsDeleted=0;
        SQLiteDatabase db=notesDatabase.getWritableDatabase();

        switch (uriMatcher.match(uri)){
            case URI_CODE_JAVA_TABLE:
                rowsDeleted=db.delete(TABLE_JAVA,selection,selectionArgs);
                break;
            case URI_CODE_KOTLIN_TABLE:
                rowsDeleted=db.delete(TABLE_KOTLIN,selection,selectionArgs);
                break;
            default:
                throwInvalidUriException(uri);
        }

        if(rowsDeleted>0) notifyChange(uri);
        else Toast.makeText(getContext(),
                Objects.requireNonNull(getContext()).getString(R.string.invalid_value),
                Toast.LENGTH_LONG).show();

        return rowsDeleted;
    }

    @Override
    public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection,
                      @Nullable String[] selectionArgs) {
        int rowsUpdated=0;
        SQLiteDatabase db=notesDatabase.getWritableDatabase();

        switch (uriMatcher.match(uri)){
            case URI_CODE_JAVA_TABLE:
                rowsUpdated=db.update(TABLE_JAVA,values, selection,selectionArgs);
                break;
            case URI_CODE_KOTLIN_TABLE:
                rowsUpdated=db.update(TABLE_KOTLIN,values,selection,selectionArgs);
                break;
            default:
                throwInvalidUriException(uri);
        }

        if(rowsUpdated>0) notifyChange(uri);
        else Toast.makeText(getContext(),
                Objects.requireNonNull(getContext()).getString(R.string.invalid_value),
                Toast.LENGTH_LONG).show();

        return rowsUpdated;
    }

    private void notifyChange(Uri uri){
        Objects.requireNonNull(getContext(),"Context cannot be null")
                .getContentResolver().notifyChange(uri,null);
    }

    private void throwInvalidUriException(Uri uri) {
        throw new InvalidUriException(uri.toString());
    }

    private static class InvalidUriException extends RuntimeException{
        public InvalidUriException(String uri){
            super("Invalid uri"+uri);
        }
    }

}


5)Contract class 구현
Contract class는 provider와 관련된 URI, 권한, 열 이름 등에 대한 상수 정의를 포함하는 public final class입니다. 앞에 코드에서 사용한 상수 대부분이 여기에 생성한 것들입니다. 

- NotesContract.java

public final class NotesContract {

    public static final String AUTHORITY="com.example.content-provider";
    public static final String TABLE_JAVA="java_notes";
    public static final String TABLE_KOTLIN="kotlin_notes";
    public static final Uri BASE_CONTENT_URI=Uri.parse("content://"+AUTHORITY);

    public static final class JavaNotesEntry implements BaseColumns {
        static final Uri CONTENT_URI=Uri.withAppendedPath(BASE_CONTENT_URI,TABLE_JAVA);
        static final String TABLE_NAME="java_notes";
        static final String COLUMN_TITLE="title";
        static final String COLUMN_CONTENT="content";
    }

    public static final class KotlinNotesEntry implements BaseColumns{
        static final Uri CONTENT_URI=Uri.withAppendedPath(BASE_CONTENT_URI,TABLE_KOTLIN);
        static final String TABLE_NAME="kotlin_notes";
        static final String COLUMN_TITLE="title";
        static final String COLUMN_CONTENT="content";
    }

}

내부 클래스는 각 테이블에 대한 상수를 선언하고 있습니다. 테이블에 대한 URI는 공통된 콘텐츠 URI에 경로를 추가하여 생성하였습니다. BaseColumns는 내부적으로 _ID와 _COUNT를 추가해줍니다. 테이블의 기본키를 BaseColumns 인터페이스를 통해 상속받아 사용하는 겁니다.


6)Permission 구현 
저희가 구현하는 provider는 provider 앱에서 관리하는 데이터를 외부에서 복사해가는 예제입니다. 즉, provider 생성 앱에서 삽입, 삭제, 업데이트를 하고 외부 앱에서 provider에 대한 데이터를 쿼리할겁니다. 외부에서 의도하지 않게 데이터를 변경할 수도 있기 때문에 write를 하지 못하도록 접근을 막을 겁니다. 이를 위해서는 manifest에서 writePermission를 설정하면 됩니다.

<provider
            android:authorities="com.example.content-provider"
            android:name=".NotesContentProvider"
            android:writePermission="com.example.content-provider.WRITE_PERMISSION"
            android:exported="true" />


7)Provider 사용
Content provider에 대한 모든 코드 작성이 완료되었습니다. 이제 사용하기만 하면 됩니다. 드디어 그동안 미루었던 ContentObserver에 대해 우선 설명하겠습니다. 이름에서 짐작할 수 있듯이 내용물 관찰자로 URI에 연결된 데이터가 변경되면 이를 알려주는 클래스입니다. 변경사항을 실시간으로 알려주어 항상 데이터가 최신 상태로 유지할 수 있도록 도와줍니다. 물론 저희 예제에서는 삽입, 삭제, 수정이 버튼을 통해 명시적으로 이루어져서 ContentObserver가 크게 필요하지는 않습니다. 해당 버튼이 클릭될 때 연산 작업이 바로 수행되므로 따로 관찰할 필요가 없기 때문이죠. 그럼에도 ContentObserver는 content provider에 자주 사용되기에 적용해보겠습니다. content provider는 데이터를 중앙에서 관리하기에 데이터 변경을 알려주는 중간 역할이 필요하기 때문이죠.

ContentObserver를 생성할 때는 Handler를 전달해야합니다. 변경된 데이터에 대한 알림이 어느 스레드에서 처리할지를 결정하는 역할을 합니다. 알림을 UI에 전달하여 리스트를 갱신할 것이기에 UI스레드(메인스레드)로 설정합니다. 만약 시간이 오래 걸리는 작업을 할 경우에는 별도의 스레드에서 작업을 해야 할겁니다. 

변경된 알림은 onChange()를 통해 처리됩니다. selfChange 매개변수는 변경이 동일 프로세스에서 발생하였는지를 나타내고 uri는 변경된 데이터의 URI입니다. 여기서 주의할 점은 변경된 데이터 자체가 아닌 데이터를 가리키는 URI입니다. 예를 들어 content://com.example.content-provider/java_notes 를 데이터 URI로 등록합니다. 데이터를 삽입을 해서 content://com.example.content-provider/java_notes/1로 항목이 추가되면 '/1'이라는 변경 사항을 감지합니다. 그럼 onChange는 변경된 content://com.example.content-provider/java_notes/1이 아니라 여전히 등록된 URI인 content://com.example.content-provider/java_notes 가집니다.

ContentObserver contentObserver=new ContentObserver(new Handler(Looper.getMainLooper())) {
            @Override
            public void onChange(boolean selfChange, @Nullable Uri uri) {
                super.onChange(selfChange, uri);

                if(uri==null) throw new NullPointerException("uri is null");
                
                if(uri.equals(NotesContract.JavaNotesEntry.CONTENT_URI)){
                    getSupportLoaderManager().restartLoader(
                            LOADER_ID_TABLE_JAVA,null,MainActivity.this);
                }else if(uri.equals(NotesContract.KotlinNotesEntry.CONTENT_URI)){
                    getSupportLoaderManager().restartLoader(
                            LOADER_ID_TABLE_KOTLIN,null,MainActivity.this);
                }

            }
        };

onChange()에 각 테이블의 URI가 변경(삽입,삭제,수정)될 때 진행할 작업을 실행합니다. 본문에 있는 loader에 대해서는 ContentObserver 설명이 마무리된 후에 설명하겠습니다. 만약 변경 알림은 필요하지만 onChange()에서 구현할 별도의 로직이 필요 없는 경우 handler가 필요없기에 null을 전달하면 됩니다.

이제 생성된 contentObserver를 등록 및 해제합니다. 등록할 때는 등록할 데이터의 URI, 하위 URI 감지 여부, 구현된 contentObserver 인스턴스를 전달합니다.

getContentResolver().registerContentObserver(
                NotesContract.JavaNotesEntry.CONTENT_URI,true,contentObserver);
        getContentResolver().registerContentObserver(
                NotesContract.KotlinNotesEntry.CONTENT_URI,true,contentObserver
        );

getContentResolver().unregisterContentObserver(contentObserver);

ContentProvider에 사용에 잊지 말아야 할 요소가 있는데 바로 비동기입니다. 쿼리를 하는 동안 사용자가 UI를 계속 사용할 수 있어야 하기 때문입니다. ContentProvider에서는 쿼리를 자동으로 비동기로 실행하지 않습니다. 그러기 위해 사용하는 것이 아까 언급된 Loader입니다. Loader는 데이터를 비동기로 데이터를 로드해줍니다. 특히 Loader 종류 중 하나인 CursorLoader는 데이터 결과를 Cursor 형태로 반환하기 때문에 ContentProvider와 함께 사용됩니다. 현재는 더 효율적인 방식의 등장으로 deprecated되었습니다만 이전 포스팅에서 CursorLoader가 언급되었고 예전에는 자주 이용되었기에 사용해보겠습니다. 참고로 현재는 ViewModel, LiveData, Coroutines 등을 사용합니다.

CursorLoader를 사용하기 위해서는 LoaderManager.LoaderCallbacks<Cursor>를 implements 해야합니다. 필수적으로 구현해야하는 메서드가 3가지 있는데 onCreateLoader, onLoadFinished, onLoaderReset 입니다. onCreateLoader()에서 CursorLoader를 생성하고 데이터 로드가 완료되면, onLoadFinished() 콜백이 호출되어 데이터를 업데이트합니다. Loader가 필요 없을 때는 onLoaderReset()이 호출되어 리소스를 정리합니다.

 private static final int LOADER_ID_TABLE_JAVA=1;
 private static final int LOADER_ID_TABLE_KOTLIN=2;

  @NonNull
    @Override
    public Loader<Cursor> onCreateLoader(int id, @Nullable Bundle args) {
        Uri uri;
        switch (id){
            case LOADER_ID_TABLE_JAVA:
                uri=NotesContract.JavaNotesEntry.CONTENT_URI;
                break;
            case LOADER_ID_TABLE_KOTLIN:
                uri=NotesContract.KotlinNotesEntry.CONTENT_URI;
                break;
            default:
                throw new IllegalArgumentException("Invalid loader ID");
        }
        return new CursorLoader(
                this,uri,null,null,null,null
        );
    }

id는 Loader의 고유 id를 의미합니다. 저희는 두 테이블에 대한 콘텐츠 URI가 2개 있으므로 각 URI를 관리하는 Loader 역시 2개를 생성하였습니다. onCreateLoader()에서 이를 구분하여 CursorLoader에 URI를 전달합니다.

@Override
    public void onLoadFinished(@NonNull Loader<Cursor> loader, Cursor data) {
        if(loader.getId()==LOADER_ID_TABLE_JAVA) javaListAdapter.swapCursor(data);
        else if(loader.getId()==LOADER_ID_TABLE_KOTLIN) kotlinListAdapter.swapCursor(data);
    }

    @Override
    public void onLoaderReset(@NonNull Loader<Cursor> loader) {
        javaListAdapter.swapCursor(null);
        kotlinListAdapter.swapCursor(null);
    }

swapCursor()를 통해 새로운 데이터를 recyclerView의 adapter에 전달합니다. 저희 예제에서는 변경된 데이터만 업데이트하는 방식이 아니라 변경된 데이터를 포함한 전체 데이터를 다시 로드하는 간단한 방식으로 진행됩니다.

Loader를 등록하기 위해서는 initLoader()를 통해 Loader를 초기화시켜줍니다. 또한 생성 이후 재시작, 데이터 업데이트가 필요할 경우 restartLoader()를 호출합니다. 앞에 contentObserver의 onChange() 안에 구현한 내용이 바로 이 restartLoader()입니다. initLoader()와 restartLoader() 모두 매개변수로 loader의 id, 전달 데이터인 args, 콜백 인스턴스를 가집니다.

getSupportLoaderManager().initLoader(LOADER_ID_TABLE_JAVA,null,this);
getSupportLoaderManager().initLoader(LOADER_ID_TABLE_KOTLIN,null,this);

이제 ContentResolver를 이용하여 ContentProvider를 사용하겠습니다. 우선 삭제의 경우 테이블 인덱스 값을 받아 해당 인덱스 값을 가진 데이터를 삭제하겠습니다.

Uri uri=checkTable(table);

String selection = BaseColumns._ID+"=?";
String [] selectionArgs=new String[]{idx};
getContentResolver().delete(uri,selection, selectionArgs);

 private Uri checkTable(String table){
        Uri uri=Uri.EMPTY;
        if(table.equals("j")){
            uri=NotesContract.JavaNotesEntry.CONTENT_URI;
        }else if(table.equals("k")){
            uri=NotesContract.KotlinNotesEntry.CONTENT_URI;
        }
        return uri;
    }

삽입의 경우 코드의 제목과 내용을 입력하고 ContentValues를 통해 전달해줍니다. ContentValues는 한 줄 형태의 Cursor와 유사한 개체입니다.

Uri uri=checkTable(table);

ContentValues values=new ContentValues();
values.put(NotesContract.JavaNotesEntry.COLUMN_TITLE, name);
values.put(NotesContract.JavaNotesEntry.COLUMN_CONTENT,value);
getContentResolver().insert(uri,values);

업데이트는 수정할 데이터의 인덱스를 입력하고 ContentValues를 통해 수정할 데이터를 전달합니다.

Uri uri=checkTable(table);

ContentValues values=new ContentValues();
values.put(NotesContract.JavaNotesEntry.COLUMN_TITLE,name);
values.put(NotesContract.JavaNotesEntry.COLUMN_CONTENT,value);
String selection=BaseColumns._ID+"=?";
String [] selectionArgs=new String[]{idx};
getContentResolver().update(uri,values,selection,selectionArgs);

전체 코드입니다.

- MainActivity.java

public class MainActivity extends AppCompatActivity implements LoaderManager.LoaderCallbacks<Cursor> {

    private static final int LOADER_ID_TABLE_JAVA=1;
    private static final int LOADER_ID_TABLE_KOTLIN=2;

    private ActivityMainBinding binding;
    private NotesRecyclerviewAdapter javaListAdapter;
    private NotesRecyclerviewAdapter kotlinListAdapter;
    private ContentObserver contentObserver;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        initializeBinding();
        initializeLoaders();
        setupRecyclerviewAdapter();
        setupClickListener();
    }

    @Override
    protected void onStart() {
        super.onStart();
        registerContentObserver();
    }

    @Override
    protected void onStop() {
        super.onStop();
        getContentResolver().unregisterContentObserver(contentObserver);
    }

    @NonNull
    @Override
    public Loader<Cursor> onCreateLoader(int id, @Nullable Bundle args) {
        Uri uri;
        switch (id){
            case LOADER_ID_TABLE_JAVA:
                uri=NotesContract.JavaNotesEntry.CONTENT_URI;
                break;
            case LOADER_ID_TABLE_KOTLIN:
                uri=NotesContract.KotlinNotesEntry.CONTENT_URI;
                break;
            default:
                throw new IllegalArgumentException("Invalid loader ID");
        }
        return new CursorLoader(
                this,uri,null,null,null,null
        );
    }

    @Override
    public void onLoadFinished(@NonNull Loader<Cursor> loader, Cursor data) {
        if(loader.getId()==LOADER_ID_TABLE_JAVA) javaListAdapter.swapCursor(data);
        else if(loader.getId()==LOADER_ID_TABLE_KOTLIN) kotlinListAdapter.swapCursor(data);
    }

    @Override
    public void onLoaderReset(@NonNull Loader<Cursor> loader) {
        javaListAdapter.swapCursor(null);
        kotlinListAdapter.swapCursor(null);
    }
    
    private void initializeBinding(){
        binding=ActivityMainBinding.inflate(getLayoutInflater());
        setContentView(binding.getRoot());
    }

    private void setupRecyclerviewAdapter(){
        javaListAdapter=new NotesRecyclerviewAdapter(this, NotesContract.TABLE_JAVA);
        kotlinListAdapter=new NotesRecyclerviewAdapter(this,NotesContract.TABLE_KOTLIN);
        binding.javaList.setLayoutManager(new LinearLayoutManager(this));
        binding.kotlinList.setLayoutManager(new LinearLayoutManager(this));
        binding.javaList.setAdapter(javaListAdapter);
        binding.kotlinList.setAdapter(kotlinListAdapter);
    }

    private void initializeLoaders(){
        getSupportLoaderManager().initLoader(LOADER_ID_TABLE_JAVA,null,this);
        getSupportLoaderManager().initLoader(LOADER_ID_TABLE_KOTLIN,null,this);
    }

    private void setupClickListener(){
        binding.btnDelete.setOnClickListener(
                v->{
                    String deleteTable= String.valueOf(binding.editDeleteTable.getText());
                    String deleteIdx= String.valueOf(binding.editDeleteIdx.getText());
                    deleteData(deleteTable, deleteIdx);
                    binding.editDeleteTable.setText("");
                    binding.editDeleteIdx.setText("");
                });

        binding.btnInsert.setOnClickListener(
                v->{
                    String insertTable=
                            String.valueOf(binding.editInsertTable.getText());
                    String insertColumnName=
                            String.valueOf(binding.editInsertColumnName.getText());
                    String insertColumnValue=
                            String.valueOf(binding.editInsertColumnValue.getText());
                    insertData(insertTable, insertColumnName, insertColumnValue);
                    binding.editInsertTable.setText("");
                    binding.editInsertColumnName.setText("");
                    binding.editInsertColumnValue.setText("");
                });

        binding.btnUpdate.setOnClickListener(
                v->{
                    String updateTable=
                            String.valueOf(binding.editUpdateTable.getText());
                    String updateIdx=
                            String.valueOf(binding.editUpdateIdx.getText());
                    String updateColumnName=
                            String.valueOf(binding.editUpdateColumnName.getText());
                    String updateColumnValue=
                            String.valueOf(binding.editUpdateColumnValue.getText());
                    updateData(updateTable, updateIdx, updateColumnName, updateColumnValue);
                    binding.editUpdateTable.setText("");
                    binding.editUpdateIdx.setText("");
                    binding.editUpdateColumnName.setText("");
                    binding.editUpdateColumnValue.setText("");
                });
    }

    public void deleteData(String table, String idx){
        Uri uri=checkTable(table);

        String selection = BaseColumns._ID+"=?";
        String [] selectionArgs=new String[]{idx};
        getContentResolver().delete(uri,selection, selectionArgs);
    }

    public void insertData(String table, String name, String value){
        Uri uri=checkTable(table);

        ContentValues values=new ContentValues();
        values.put(NotesContract.JavaNotesEntry.COLUMN_TITLE, name);
        values.put(NotesContract.JavaNotesEntry.COLUMN_CONTENT,value);
        getContentResolver().insert(uri,values);
    }

    public void updateData(String table, String idx, String name, String value){
        Uri uri=checkTable(table);

        ContentValues values=new ContentValues();
        values.put(NotesContract.JavaNotesEntry.COLUMN_TITLE,name);
        values.put(NotesContract.JavaNotesEntry.COLUMN_CONTENT,value);
        String selection=BaseColumns._ID+"=?";
        String [] selectionArgs=new String[]{idx};
        getContentResolver().update(uri,values,selection,selectionArgs);
    }

    private Uri checkTable(String table){
        Uri uri=Uri.EMPTY;
        if(table.equals("j")){
            uri=NotesContract.JavaNotesEntry.CONTENT_URI;
        }else if(table.equals("k")){
            uri=NotesContract.KotlinNotesEntry.CONTENT_URI;
        }
        return uri;
    }

    private void registerContentObserver(){
        contentObserver=new ContentObserver(new Handler(Looper.getMainLooper())) {
            @Override
            public void onChange(boolean selfChange, @Nullable Uri uri) {
                super.onChange(selfChange, uri);

                if(uri==null) throw new NullPointerException("uri is null");

                if(uri.equals(NotesContract.JavaNotesEntry.CONTENT_URI)){
                    getSupportLoaderManager().restartLoader(
                            LOADER_ID_TABLE_JAVA,null,MainActivity.this);
                }else if(uri.equals(NotesContract.KotlinNotesEntry.CONTENT_URI)){
                    getSupportLoaderManager().restartLoader(
                            LOADER_ID_TABLE_KOTLIN,null,MainActivity.this);
                }

            }
        };

        getContentResolver().registerContentObserver(
                NotesContract.JavaNotesEntry.CONTENT_URI,true,contentObserver);
        getContentResolver().registerContentObserver(
                NotesContract.KotlinNotesEntry.CONTENT_URI,true,contentObserver
        );
    }

}
 