이전 글의 content provider 생성 방법에 따라 직접 구현해보겠습니다. java와 kotlin 테이블를 만들고 각 테이블에 예제 코드 데이터가 있는 Content provider를 생성합니다. 그럼 외부 앱에서 해당 데이터를 쿼리하는 예제를 만들겁니다. 안드로이드 공식 문서에서 예제를 java나 kotlin으로 변환하고 해당 코드를 복사하는 흐름에서 따왔습니다.

1. Content Provider 앱
1)구현 시작 전
예제에 content provider가 진짜로 필요한지 생각해보겠습니다. 코드 데이터를 단순 문자열이 아닌 코드 제목과 내용으로 구성된 테이블로 관리할겁니다. 제목에는 코드가 어떤 내용인지 표시하고 내용에는 실제 코드를 저장하고 싶기 때문입니다. 테이블 형태의 데이터를 다른 앱으로 복사할 수 있도록 허용할 것이기에 content provider가 필요해보입니다.


2)데이터 저장소 설계 및 구현
테이블 형태의 구조화된 데이터이기 때문에 SQLite 관계형 데이터베이스에 저장하겠습니다. 물론 Room도 있지만 content provider 예제인 만큼 provider에 집중하기 위해 SQLite를 사용하겠습니다. 데이터 베이스와 java 및 kotlin 
테이블을 생성하면 됩니다. 각 테이블에는 기본 키를 위한 ID과 더불어 title과 content 열을 만듭니다.

- NotesDatabase.java

public class NotesDatabase extends SQLiteOpenHelper {

    private static final String DATABASE_NAME="notes.db";
    private static final int DATABASE_VERSION=1;

    public NotesDatabase(Context context){
        super(context,DATABASE_NAME,null,DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        final String SQLITE_CREATE_JAVA_TABLE=
                "CREATE TABLE "+ NotesContract.JavaNotesEntry.TABLE_NAME +"("+
                NotesContract.JavaNotesEntry._ID +" INTEGER PRIMARY KEY AUTOINCREMENT, "+
                NotesContract.JavaNotesEntry.COLUMN_TITLE+" TEXT NOT NULL, "+
                NotesContract.JavaNotesEntry.COLUMN_CONTENT+" TEXT NOT NULL);";

        final String SQLITE_CREATE_KOTLIN_TABLE=
                "CREATE TABLE "+ NotesContract.KotlinNotesEntry.TABLE_NAME +"("+
                NotesContract.KotlinNotesEntry._ID +" INTEGER PRIMARY KEY AUTOINCREMENT, "+
                NotesContract.KotlinNotesEntry.COLUMN_TITLE+" TEXT NOT NULL, "+
                NotesContract.KotlinNotesEntry.COLUMN_CONTENT+" TEXT NOT NULL);";

        db.execSQL(SQLITE_CREATE_JAVA_TABLE);
        db.execSQL(SQLITE_CREATE_KOTLIN_TABLE);
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        db.execSQL("DROP TABLE IF EXISTS "+ NotesContract.JavaNotesEntry.TABLE_NAME);
        db.execSQL("DROP TABLE IF EXISTS "+ NotesContract.KotlinNotesEntry.TABLE_NAME);
        onCreate(db);
    }

}

코드에 사용된 상수는 contract class 구현 부분에 설명하겠습니다.


3)콘텐츠 URI 설계
Content provider를 구현하기 전, provider의 데이터를 식별하기 위한 URI를 설계할겁니다. 콘텐츠 URI는 provider 권한과 경로로 구성됩니다. 권한은 고유성을 위해 패키지 이름을 활용할 것입니다. 경로는 개별 테이블을 가리키기 위해 필요합니다. 단지 권한에서 java와 kotlin 테이블 명을 추가하면 됩니다. 테이블 전체 데이터뿐만 아니라 테이블의 특정 데이터 또한 가져오고 싶기 때문에 각 행의 ID를 더하기도 할겁니다.

그럼 현재 java와 kotlin 테이블에 대한 URI와 각 테이블의 특정 데이터를 가져올 URI가 필요하기 때문에 총 4개가 필요해집니다.여러 개의 URI를 쉽게 작업하기 위해 UriMatcher를 사용할겁니다. URI는 비교적 복잡하고 길이가 길기 때문에 URI에 대한 상수를 정의하고 해당 상수를 이용하여 작업을 수행할겁니다. 콘텐츠 URI에 정수 값을 매핑하기 위해서는 addURI()를 사용하면 됩니다. addURI()의 매개변수로 권한, 경로, 정수 값을 전달하면 됩니다. 권한과 경로를 나누지 않고 바로 URI를 전달 할 수도 있습니다. 하지만 공통된 권한을 가지고 경로에만 차이가 있기 때문에 각각 상수로 정의하여 전달하겠습니다. 상수로 관리하는 것이 활용하기도 편합니다. provider에 관한 상수는 추후 설명할 contract파일에 정의하였습니다. Uri 패턴은 content provider 구현 파일에 작성하였습니다.

private static final int URI_CODE_JAVA_TABLE=1;
private static final int URI_CODE_JAVA_TABLE_ID=2;
private static final int URI_CODE_KOTLIN_TABLE=3;
private static final int URI_CODE_KOTLIN_TABLE_ID=4;

private static final UriMatcher uriMatcher=new UriMatcher(UriMatcher.NO_MATCH);

static{
        uriMatcher.addURI(AUTHORITY,TABLE_JAVA,URI_CODE_JAVA_TABLE);//java 테이블 전체를 위한 URI
        uriMatcher.addURI(AUTHORITY,TABLE_JAVA+"/#",URI_CODE_JAVA_TABLE_ID);//java 테이블 단일 행을 위한 URI
        uriMatcher.addURI(AUTHORITY,TABLE_KOTLIN,URI_CODE_KOTLIN_TABLE);//kotlin 테이블 전체를 위한 URI
        uriMatcher.addURI(AUTHORITY,TABLE_KOTLIN+"/#",URI_CODE_KOTLIN_TABLE_ID);/kotlin 테이블 단일 행을 위한 URI
    }

UriMatcher 생성자에 전달한 UriMatcher.NO_MATCH는 일치하는 패턴이 없을 때 반환하는 값으로 -1입니다.
