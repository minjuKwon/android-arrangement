Compose에서는 Activity에 직접 의존하지 않도록 설계되어 있기 때문에 Lifecycle을 통해 생명주기를 다룹니다. 
androidx.lifecycle 패키지는 수명 주기 인식 구성요소(활동이나 프래그먼트의 현재 수명 주기 상태를 기반으로 동작을 자동 조정할 수 있는 구성요소)를 빌드할 수 있는 클래스 및 인터페이스를 제공합니다.
Lifecycle은 활동이나 프래그먼트와 같은 구성요소의 수명 주기 상태 관련 정보를 포함하며 다른 객체가 이 상태를 관찰할 수 있게 하는 클래스입니다.
Lifecycle은 두 가지 기본 열거를 사용하여 연결된 구성요소의 수명 주기 상태를 추적합니다.

이벤트
프레임워크 및 Lifecycle 클래스에서 전달되는 수명 주기 이벤트입니다. 이러한 이벤트는 활동과 프래그먼트의 콜백 이벤트에 매핑됩니다.
상태
Lifecycle 객체가 추적한 구성요소의 현재 상태입니다.

클래스는 DefaultLifecycleObserver를 구현하고 onCreate, onStart 등의 상응하는 메서드를 재정의하여 구성요소의 수명 주기 상태를 모니터링할 수 있습니다. 그러면 다음 예에 나와 있는 것처럼 Lifecycle 클래스의 addObserver() 메서드를 호출하고 관찰자의 인스턴스를 전달하여 관찰자를 추가할 수 있습니다. 해당 예에서 myLifecycleOwner 객체는 LifecycleOwner 인터페이스를 구현합니다
class MyObserver : DefaultLifecycleObserver {
    override fun onResume(owner: LifecycleOwner) {
        connect()
    }

    override fun onPause(owner: LifecycleOwner) {
        disconnect()
    }
}

myLifecycleOwner.getLifecycle().addObserver(MyObserver())


LifecycleOwner는 클래스에 Lifecycle이 있음을 나타내는 단일 메서드 인터페이스입니다. 이 인터페이스에는 클래스에서 구현해야 하는 getLifecycle() 메서드가 하나 있습니다. 대신 전체 애플리케이션 프로세스의 수명 주기를 관리하려는 경우 ProcessLifecycleOwner를 참고하세요.

이 인터페이스는 Fragment 및 AppCompatActivity와 같은 개별 클래스에서 Lifecycle의 소유권을 추출하고, 함께 작동하는 구성요소를 작성할 수 있게 합니다. 모든 맞춤 애플리케이션 클래스는 LifecycleOwner 인터페이스를 구현할 수 있습니다.

관찰자가 관찰을 위해 등록할 수 있는 수명 주기를 소유자가 제공할 수 있으므로, DefaultLifecycleObserver를 구현하는 구성요소는 LifecycleOwner를 구현하는 구성요소와 원활하게 작동합니다.

위치 추적 예에서는 MyLocationListener 클래스에서 DefaultLifecycleObserver를 구현하도록 한 후 onCreate() 메서드에서 활동의 Lifecycle로 클래스를 초기화할 수 있습니다. 이렇게 하면 MyLocationListener 클래스가 자립할 수 있습니다. 즉, 수명 주기 상태의 변경에 반응하는 로직이 활동 대신 MyLocationListener에서 선언됩니다. 개별 구성요소가 자체 로직를 저장하도록 설정하면 활동과 프래그먼트 로직을 더 쉽게 관리할 수 있습니다.

class MyActivity : AppCompatActivity() {
    private lateinit var myLocationListener: MyLocationListener

    override fun onCreate(...) {
        myLocationListener = MyLocationListener(this, lifecycle) { location ->
            // update UI
        }
        Util.checkUserStatus { result ->
            if (result) {
                myLocationListener.enable()
            }
        }
    }
}

일반적인 사용 사례에서는 Lifecycle이 현재 정상 상태가 아닌 경우 특정 콜백 호출을 피합니다. 예를 들어 활동 상태가 저장된 후 콜백이 프래그먼트 트랜잭션을 실행하면 비정상 종료를 트리거할 수 있으므로 콜백을 호출하지 않는 것이 좋습니다.
이러한 사용 사례를 쉽게 만들 수 있도록 Lifecycle 클래스는 다른 객체가 현재 상태를 쿼리할 수 있도록 합니다.

internal class MyLocationListener(
        private val context: Context,
        private val lifecycle: Lifecycle,
        private val callback: (Location) -> Unit
): DefaultLifecycleObserver {

    private var enabled = false

    override fun onStart(owner: LifecycleOwner) {
        if (enabled) {
            // connect
        }
    }

    fun enable() {
        enabled = true
        if (lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)) {
            // connect if not connected
        }
    }

    override fun onStop(owner: LifecycleOwner) {
        // disconnect if connected
    }
}

이 구현으로 LocationListener 클래스는 수명 주기를 완전히 인식합니다. 다른 활동이나 프래그먼트의 LocationListener를 사용해야 한다면 클래스를 초기화하기만 하면 됩니다. 모든 설정과 해제 작업은 클래스 자체에서 관리합니다.

라이브러리에서 Android 수명 주기와 작동하는 데 필요한 클래스를 제공한다면 수명 주기 인식 구성요소를 사용하는 것이 좋습니다. 클라이언트 측에서 직접 수명 주기를 관리하지 않아도 라이브러리 클라이언트는 이러한 구성요소를 쉽게 통합할 수 있습니다.

지원 라이브러리 26.1.0 이상의 프래그먼트 및 활동에서는 이미 LifecycleOwner 인터페이스가 구현되어 있습니다.

LifecycleOwner를 만들려는 맞춤 클래스가 있다면 LifecycleRegistry 클래스를 사용할 수 있지만 다음 코드 예와 같이 이 클래스에 이벤트를 전달해야 합니다.

class MyActivity : Activity(), LifecycleOwner {

    private lateinit var lifecycleRegistry: LifecycleRegistry

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        lifecycleRegistry = LifecycleRegistry(this)
        lifecycleRegistry.markState(Lifecycle.State.CREATED)
    }

    public override fun onStart() {
        super.onStart()
        lifecycleRegistry.markState(Lifecycle.State.STARTED)
    }

    override fun getLifecycle(): Lifecycle {
        return lifecycleRegistry
    }
}


LaunchedEffect

정의 / 목적: Compose의 side-effect API. Composable의 생명주기(구성)에 묶여 코루틴을 시작하고, 키가 바뀌거나 Composable이 사라지면 코루틴을 자동 취소/재시작한다.
동작 방식:

LaunchedEffect(key1, key2) 내부는 suspend 가능한 코루틴 블록이다.
키가 변경되면 기존 코루틴이 취소되고 새로운 코루틴이 시작된다.
Composable이 composition에서 제거되면 코루틴이 취소된다.

언제 사용:
Composable이 존재하는 동안 유지되어야 하는 coroutine 작업(예: UI와 연동되는 Flow 수집, 초기화용 suspend 호출 등).
키 변경 시 재시작이 필요할 때.
장점:
구성 생명주기와 구조적 동시성(Structured Concurrency)이 보장됨.
suspend 함수 직접 호출 가능.
주의점 / 단점:
키 관리를 잘못하면 불필요한 재시작(재실행)이 발생.
재컴포지션(recomposition)과는 별개로 키가 바뀌면 재시작됨 — 의도치 않은 재시작 주의.


DisposableEffect

정의 / 목적: Composable이 등록/해제해야 하는 비-서스펜딩(비코루틴) 자원(리스너, Observer, 콜백 등)을 관리하기 위한 API. 생성 시점에 설정하고 onDispose에서 해제한다.

동작 방식:
DisposableEffect(key) 블록은 즉시 실행되고 onDispose { ... }로 정리 코드를 제공한다.
키 변경 또는 composition에서 제거될 때 onDispose가 호출된다.

언제 사용:
Android 리스너, Lifecycle.addObserver 같은 등록/해제 패턴.
비동기 suspend 코드 없이 단순한 자원 등록과 해제가 필요한 경우.

장점:
명시적 등록/해제 제공 → 메모리 누수 방지 가능.
재컴포지션으로 인한 불필요한 재등록을 키로 제어 가능.

주의점 / 단점:
suspend 불가(직접 suspend 호출 불가). suspend 호출이 필요하면 내부에서 코루틴을 직접 launch 해야 함.
등록/해제를 수동으로 관리해야 함(하지만 onDispose로 안전하게 처리).


repeatOnLifecycle

정의 / 목적: Lifecycle의 특정 상태(예: STARTED, RESUMED) 동안 suspend 블록을 실행하고, 상태가 벗어나면 해당 블록을 취소했다가 다시 상태가 되면 재시작하는 편리한 확장 함수(코루틴 기반).

동작 방식:
lifecycle.repeatOnLifecycle(state) { /* suspend block */ }는 호출된 코루틴 내에서 동작해야 한다(즉 launch {}나 LaunchedEffect 내부 등).
Lifecycle이 목표 상태에 들어오면 블록을 실행하기 위해 새 코루틴을 시작하고, 상태가 벗어나면 그 코루틴을 취소한다. 상태가 다시 오면 새 코루틴으로 재시작한다.

언제 사용:
Flow를 수집하거나 suspend 작업을 Lifecycle 상태에 맞춰 안전하게 실행할 때(예: 화면 보이는 동안만 collect).

장점:
Flow 수집과 같은 반복적 suspend 작업을 Lifecycle 상태에 자동으로 맞춰 관리해 줌.
ON_STOP 등으로 내려가면 자동으로 취소 → 리소스 사용 최소화.

주의점 / 단점:
repeatOnLifecycle 자체는 suspend 함수이므로 반드시 코루틴 컨텍스트에서 호출해야 함.
진입/탈출마다 블록이 새 코루틴으로 다시 실행되므로 블록 내부에서 상태를 잘 관리해야 함(예: 중복 시작 방지, 초기화 비용 고려).


LifecycleEventObserver

정의 / 목적: LifecycleObserver의 한 구현 형태로, onStateChanged(owner, event)로 lifecycle 이벤트(ON_CREATE, ON_START, ON_RESUME 등)를 직접 전달받는다.

동작 방식:
lifecycle.addObserver(observer)로 등록하고 removeObserver로 해제.
이벤트 기반(event-driven) 처리에 적절.

언제 사용:
특정 lifecycle 이벤트에 대해 정확히 한 번 반응해야 할 때(예: ON_RESUME에서 특정 API 호출), 혹은 이벤트별 세밀한 제어가 필요할 때.

장점:
이벤트 단위로 쉽고 명확하게 동작 정의 가능.

주의점 / 단점:
비서스펜드(suspend) 작업을 직접 할 수 없음 — 내부에서 코루틴을 launch 해야 함.
등록/제거를 잊으면 메모리 누수 가능 → DisposableEffect와 조합 권장.


rememberUpdatedState

정의 / 목적: 재컴포지션으로 값(특히 람다)이 바뀌어도 장기 보유(long-lived callback) 코드에서 최신 값을 안전하게 참조하도록 하는 유틸.

동작 방식:
val current = rememberUpdatedState(value) → current.value는 최신 값을 가리키도록 업데이트됨.
Observer/콜백 같은 장기간 살아있는 객체에 최신 람다/값을 전달할 때 사용.

언제 사용:
DisposableEffect에서 등록한 observer가 콜백을 호출할 때, 콜백 내부에서 최신 Composable 상태/람다를 사용해야 할 경우.

장점:
observer를 재등록하지 않고도 최신 상태를 안전하게 사용 가능 → 불필요한 등록/해제 회피.

주의점 / 단점:
rememberUpdatedState는 값의 동시성 보장을 단순화하지만, 상태 변경과 observer 호출 시점 간의 race를 완전히 제거해 주지 않음(상황에 따라 동기화 필요).


SideEffect

정의 / 목적: recomposition이 완료된 직후에 호출되는 동기(side-effect) 훅. 주로 "UI가 확정된 상태"를 외부 시스템에 즉시 반영할 때 사용.

동작 방식:
매 재컴포지션 성공 후 실행(비서스펜드).
결과는 동기적으로 실행되며, recomposition이 여러 번 일어나면 여러 번 호출된다.

언제 사용:
Compose 상태 변경을 Android 뷰 속성 또는 외부 상태에 즉시 반영해야 할 때(간단한 업데이트).

주의점 / 단점:
무거운 작업, 블로킹 작업을 넣으면 안 됨(메인 스레드에서 실행될 수 있음).
SideEffect는 정리 코드(onDispose)가 없으므로 리소스 등록/해제 용도로 부적합.


rememberCoroutineScope

정의 / 목적: Composable 내부에서 CoroutineScope를 얻어 이벤트 핸들러(버튼 클릭 등)에서 코루틴을 시작할 때 사용.

동작 방식:
val scope = rememberCoroutineScope()는 composition에 묶인 scope를 반환.
이 scope는 그 Composable이 버려질 때(cancel) 취소된다.
재컴포지션이 일어나더라도 동일한 scope를 반환(재생성되지 않음).

언제 사용:
사용자 입력(클릭 등) 시 즉시 코루틴을 시작해야 할 때.
여러 개의 독립 코루틴을 수동으로 시작/관리해야 할 때.

장점:
재컴포지션과 무관하게 동일한 scope 사용 가능(불필요한 재취소 방지).

주의점 / 단점:
scope로 시작한 코루틴은 키(key) 변경 시 자동으로 재시작되지 않음(LaunchedEffect와의 차이).
Composable이 disposal될 때만 취소됨.


LocalLifecycleOwner / lifecycleOwner

정의 / 목적: Compose에서 현재 문맥(예: Activity, Fragment, NavBackStackEntry)에 매핑된 LifecycleOwner를 제공하는 CompositionLocal.

사용:
val lifecycleOwner = LocalLifecycleOwner.current
이를 통해 lifecycleOwner.lifecycle로 lifecycle에 접근.

주의점:
NavHost/Navigation을 사용할 경우 LocalLifecycleOwner가 NavBackStackEntry에 의해 바뀔 수 있음(네비게이션 시점 주의).
DisposableEffect/LaunchedEffect 등의 키로 lifecycleOwner를 사용해 재등록 조건을 제어하는 것이 좋음.



공통적인 조합 의도(요약)

LaunchedEffect + repeatOnLifecycle
목적: Composable에 묶인 코루틴으로, Lifecycle 상태(예: STARTED) 동안 안전하게 Flow를 수집하거나 suspend 작업을 실행하려 할 때.
역할 분리: LaunchedEffect = composition-연결된 코루틴 스코프, repeatOnLifecycle = lifecycle 상태 기반 반복 실행·자동 취소.


DisposableEffect + LifecycleEventObserver
목적: 이벤트 단위(ON_RESUME 등)를 감지해 간단한 작업을 하고, observer 등록/해제를 안전하게 처리하려는 경우.
역할 분리: DisposableEffect = 등록/해제 생명주기 관리, LifecycleEventObserver = 이벤트 감지.


LaunchedEffect + LifecycleEventObserver
목적: 이벤트 기반으로 동작하면서도 동시에 suspend 작업(예: delay, Flow collect)이 필요할 때.
주의: observer 제거를 try/finally 또는 onDispose처럼 확실히 처리해야 메모리 누수 방지.


rememberUpdatedState + DisposableEffect
목적: observer를 재등록하지 않고도 콜백이 최신 Composable 상태/람다를 사용하게 하려는 경우.
역할: rememberUpdatedState는 최신 값 참조를 보장, DisposableEffect는 observer의 수명 관리.


SideEffect
목적: 재컴포지션 후 외부 UI(또는 시스템)에 즉시 동기 반영해야 할 때. 리스너 등록/해제에는 적절하지 않음.


rememberCoroutineScope
목적: 사용자의 조작에 따른 즉시 코루틴 실행(예: 버튼 클릭) 또는 여러 독립 코루틴의 수동 관리에 사용.


ViewModel / onCleared 등
목적: Composable의 세부 생명주기와 분리해 상태를 장기간 보존하거나 정리할 때.



흔한 실수 & 권장 관행

Observer 등록을 컴포지션 내부(매 재컴포지션)에서 직접 하면 중복 등록 발생 → DisposableEffect(lifecycleOwner)로 관리.

suspend 작업은 DisposableEffect 본문에서 직접 호출 불가 → 내부에서 코루틴 launch 하거나 LaunchedEffect/repeatOnLifecycle 사용.

콜백(람다)을 observer에 캡처하면 재컴포지션 후 stale reference 발생 → rememberUpdatedState 사용.

반복 폴링(while + delay)로 lifecycle 상태 체크는 비효율 → repeatOnLifecycle 또는 observer 사용 권장.

LaunchedEffect 키 관리 부실로 불필요한 재시작 발생 → 키를 최소화하거나 의도적으로 관리.