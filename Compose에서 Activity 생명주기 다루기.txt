LaunchedEffect

정의 / 목적: Compose의 side-effect API. Composable의 생명주기(구성)에 묶여 코루틴을 시작하고, 키가 바뀌거나 Composable이 사라지면 코루틴을 자동 취소/재시작한다.
동작 방식:

LaunchedEffect(key1, key2) 내부는 suspend 가능한 코루틴 블록이다.
키가 변경되면 기존 코루틴이 취소되고 새로운 코루틴이 시작된다.
Composable이 composition에서 제거되면 코루틴이 취소된다.

언제 사용:
Composable이 존재하는 동안 유지되어야 하는 coroutine 작업(예: UI와 연동되는 Flow 수집, 초기화용 suspend 호출 등).
키 변경 시 재시작이 필요할 때.
장점:
구성 생명주기와 구조적 동시성(Structured Concurrency)이 보장됨.
suspend 함수 직접 호출 가능.
주의점 / 단점:
키 관리를 잘못하면 불필요한 재시작(재실행)이 발생.
재컴포지션(recomposition)과는 별개로 키가 바뀌면 재시작됨 — 의도치 않은 재시작 주의.


DisposableEffect

정의 / 목적: Composable이 등록/해제해야 하는 비-서스펜딩(비코루틴) 자원(리스너, Observer, 콜백 등)을 관리하기 위한 API. 생성 시점에 설정하고 onDispose에서 해제한다.

동작 방식:
DisposableEffect(key) 블록은 즉시 실행되고 onDispose { ... }로 정리 코드를 제공한다.
키 변경 또는 composition에서 제거될 때 onDispose가 호출된다.

언제 사용:
Android 리스너, Lifecycle.addObserver 같은 등록/해제 패턴.
비동기 suspend 코드 없이 단순한 자원 등록과 해제가 필요한 경우.

장점:
명시적 등록/해제 제공 → 메모리 누수 방지 가능.
재컴포지션으로 인한 불필요한 재등록을 키로 제어 가능.

주의점 / 단점:
suspend 불가(직접 suspend 호출 불가). suspend 호출이 필요하면 내부에서 코루틴을 직접 launch 해야 함.
등록/해제를 수동으로 관리해야 함(하지만 onDispose로 안전하게 처리).


repeatOnLifecycle

정의 / 목적: Lifecycle의 특정 상태(예: STARTED, RESUMED) 동안 suspend 블록을 실행하고, 상태가 벗어나면 해당 블록을 취소했다가 다시 상태가 되면 재시작하는 편리한 확장 함수(코루틴 기반).

동작 방식:
lifecycle.repeatOnLifecycle(state) { /* suspend block */ }는 호출된 코루틴 내에서 동작해야 한다(즉 launch {}나 LaunchedEffect 내부 등).
Lifecycle이 목표 상태에 들어오면 블록을 실행하기 위해 새 코루틴을 시작하고, 상태가 벗어나면 그 코루틴을 취소한다. 상태가 다시 오면 새 코루틴으로 재시작한다.

언제 사용:
Flow를 수집하거나 suspend 작업을 Lifecycle 상태에 맞춰 안전하게 실행할 때(예: 화면 보이는 동안만 collect).

장점:
Flow 수집과 같은 반복적 suspend 작업을 Lifecycle 상태에 자동으로 맞춰 관리해 줌.
ON_STOP 등으로 내려가면 자동으로 취소 → 리소스 사용 최소화.

주의점 / 단점:
repeatOnLifecycle 자체는 suspend 함수이므로 반드시 코루틴 컨텍스트에서 호출해야 함.
진입/탈출마다 블록이 새 코루틴으로 다시 실행되므로 블록 내부에서 상태를 잘 관리해야 함(예: 중복 시작 방지, 초기화 비용 고려).


LifecycleEventObserver

정의 / 목적: LifecycleObserver의 한 구현 형태로, onStateChanged(owner, event)로 lifecycle 이벤트(ON_CREATE, ON_START, ON_RESUME 등)를 직접 전달받는다.

동작 방식:
lifecycle.addObserver(observer)로 등록하고 removeObserver로 해제.
이벤트 기반(event-driven) 처리에 적절.

언제 사용:
특정 lifecycle 이벤트에 대해 정확히 한 번 반응해야 할 때(예: ON_RESUME에서 특정 API 호출), 혹은 이벤트별 세밀한 제어가 필요할 때.

장점:
이벤트 단위로 쉽고 명확하게 동작 정의 가능.

주의점 / 단점:
비서스펜드(suspend) 작업을 직접 할 수 없음 — 내부에서 코루틴을 launch 해야 함.
등록/제거를 잊으면 메모리 누수 가능 → DisposableEffect와 조합 권장.


rememberUpdatedState

정의 / 목적: 재컴포지션으로 값(특히 람다)이 바뀌어도 장기 보유(long-lived callback) 코드에서 최신 값을 안전하게 참조하도록 하는 유틸.

동작 방식:
val current = rememberUpdatedState(value) → current.value는 최신 값을 가리키도록 업데이트됨.
Observer/콜백 같은 장기간 살아있는 객체에 최신 람다/값을 전달할 때 사용.

언제 사용:
DisposableEffect에서 등록한 observer가 콜백을 호출할 때, 콜백 내부에서 최신 Composable 상태/람다를 사용해야 할 경우.

장점:
observer를 재등록하지 않고도 최신 상태를 안전하게 사용 가능 → 불필요한 등록/해제 회피.

주의점 / 단점:
rememberUpdatedState는 값의 동시성 보장을 단순화하지만, 상태 변경과 observer 호출 시점 간의 race를 완전히 제거해 주지 않음(상황에 따라 동기화 필요).


SideEffect

정의 / 목적: recomposition이 완료된 직후에 호출되는 동기(side-effect) 훅. 주로 "UI가 확정된 상태"를 외부 시스템에 즉시 반영할 때 사용.

동작 방식:
매 재컴포지션 성공 후 실행(비서스펜드).
결과는 동기적으로 실행되며, recomposition이 여러 번 일어나면 여러 번 호출된다.

언제 사용:
Compose 상태 변경을 Android 뷰 속성 또는 외부 상태에 즉시 반영해야 할 때(간단한 업데이트).

주의점 / 단점:
무거운 작업, 블로킹 작업을 넣으면 안 됨(메인 스레드에서 실행될 수 있음).
SideEffect는 정리 코드(onDispose)가 없으므로 리소스 등록/해제 용도로 부적합.


rememberCoroutineScope

정의 / 목적: Composable 내부에서 CoroutineScope를 얻어 이벤트 핸들러(버튼 클릭 등)에서 코루틴을 시작할 때 사용.

동작 방식:
val scope = rememberCoroutineScope()는 composition에 묶인 scope를 반환.
이 scope는 그 Composable이 버려질 때(cancel) 취소된다.
재컴포지션이 일어나더라도 동일한 scope를 반환(재생성되지 않음).

언제 사용:
사용자 입력(클릭 등) 시 즉시 코루틴을 시작해야 할 때.
여러 개의 독립 코루틴을 수동으로 시작/관리해야 할 때.

장점:
재컴포지션과 무관하게 동일한 scope 사용 가능(불필요한 재취소 방지).

주의점 / 단점:
scope로 시작한 코루틴은 키(key) 변경 시 자동으로 재시작되지 않음(LaunchedEffect와의 차이).
Composable이 disposal될 때만 취소됨.


LocalLifecycleOwner / lifecycleOwner

정의 / 목적: Compose에서 현재 문맥(예: Activity, Fragment, NavBackStackEntry)에 매핑된 LifecycleOwner를 제공하는 CompositionLocal.

사용:
val lifecycleOwner = LocalLifecycleOwner.current
이를 통해 lifecycleOwner.lifecycle로 lifecycle에 접근.

주의점:
NavHost/Navigation을 사용할 경우 LocalLifecycleOwner가 NavBackStackEntry에 의해 바뀔 수 있음(네비게이션 시점 주의).
DisposableEffect/LaunchedEffect 등의 키로 lifecycleOwner를 사용해 재등록 조건을 제어하는 것이 좋음.



공통적인 조합 의도(요약)

LaunchedEffect + repeatOnLifecycle

목적: Composable에 묶인 코루틴으로, Lifecycle 상태(예: STARTED) 동안 안전하게 Flow를 수집하거나 suspend 작업을 실행하려 할 때.
역할 분리: LaunchedEffect = composition-연결된 코루틴 스코프, repeatOnLifecycle = lifecycle 상태 기반 반복 실행·자동 취소.


DisposableEffect + LifecycleEventObserver

목적: 이벤트 단위(ON_RESUME 등)를 감지해 간단한 작업을 하고, observer 등록/해제를 안전하게 처리하려는 경우.
역할 분리: DisposableEffect = 등록/해제 생명주기 관리, LifecycleEventObserver = 이벤트 감지.


LaunchedEffect + LifecycleEventObserver

목적: 이벤트 기반으로 동작하면서도 동시에 suspend 작업(예: delay, Flow collect)이 필요할 때.
주의: observer 제거를 try/finally 또는 onDispose처럼 확실히 처리해야 메모리 누수 방지.


rememberUpdatedState + DisposableEffect

목적: observer를 재등록하지 않고도 콜백이 최신 Composable 상태/람다를 사용하게 하려는 경우.
역할: rememberUpdatedState는 최신 값 참조를 보장, DisposableEffect는 observer의 수명 관리.


SideEffect

목적: 재컴포지션 후 외부 UI(또는 시스템)에 즉시 동기 반영해야 할 때. 리스너 등록/해제에는 적절하지 않음.


rememberCoroutineScope
목적: 사용자의 조작에 따른 즉시 코루틴 실행(예: 버튼 클릭) 또는 여러 독립 코루틴의 수동 관리에 사용.


ViewModel / onCleared 등
목적: Composable의 세부 생명주기와 분리해 상태를 장기간 보존하거나 정리할 때.



흔한 실수 & 권장 관행

Observer 등록을 컴포지션 내부(매 재컴포지션)에서 직접 하면 중복 등록 발생 → DisposableEffect(lifecycleOwner)로 관리.

suspend 작업은 DisposableEffect 본문에서 직접 호출 불가 → 내부에서 코루틴 launch 하거나 LaunchedEffect/repeatOnLifecycle 사용.

콜백(람다)을 observer에 캡처하면 재컴포지션 후 stale reference 발생 → rememberUpdatedState 사용.

반복 폴링(while + delay)로 lifecycle 상태 체크는 비효율 → repeatOnLifecycle 또는 observer 사용 권장.

LaunchedEffect 키 관리 부실로 불필요한 재시작 발생 → 키를 최소화하거나 의도적으로 관리.