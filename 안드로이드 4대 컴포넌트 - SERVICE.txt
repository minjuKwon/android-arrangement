1. Service란

1)service? 
service는 여러 가지 이유로 백그라운드에서 앱을 계속 실행시키는 다목적 진입점입니다. 이는 UI없이 백그라운드에서 실행되는 구성 요소로, 오랫동안 실행되는 작업을 수행하거나 원격 프로세스를 위한 작업을 수행합니다. 예를 들어 service는 사용자가 다른 앱에 있는 동안에 백그라운드에서 음악 재생과 파일 I/O 수행, 그리고 사용자와 activity간의 상호작용을 방해하지 않고 네트워크를 통해 데이터를 가져올 수도 있습니다. activity 같은 다른 component가 service를 시작시켜 다른 앱으로 전환되어도 사라지지 않은 채 백그라운드에서 계속 실행할 수 있고, 자신에게 바인딩하여 상호작용하게 할 수도 있습니다. service는 사용자와 애플리케이션 상호작용 여부 상관없이 백그라운드에서 실행될 수 있는 구성 요소이기에 필요한 경우에만 사용해야 합니다.


2)service 유형
 service에는 시스템에게 앱 관리 방법을 지시하는 두 가지 유형이 있는데 started service 와 bound service입니다. started service는 작업이 완료될 때까지 해당 service를 계속 실행하라고 시스템에 지시합니다. 사용자가 앱에서 나간 후에도 음악을 재생하기와 백그라운드에서 일부 데이터를 동기화하기가 있습니다. 음악 재생과 백그라운드에서 데이터 동기화하기는 started service에서 다시 두가지 유형으로 나뉘는데, 이는 시스템이 service를 처리하는 방식이 다릅니다. 

 우선 음악 재생의 경우 foreground service입니다. 사용자가 바로 인식할 수 있는 작업이기 때문에, 앱은 사용자에게 실행 중이라는 알림을 보내면서 시스템에는 포그라운드로 옮기라는 지시를 합니다. 이때 알림 표시는 필수적입니다. service를 포그라운드에서 제거하거나 중지하지 않는 한 알림을 계속 표시해야합니다. 시스템은 이러한 종류의 service 프로세스가 계속 실행되는 것을 우선시 해야합니다. 이 service가 사라지면 사용자가 불만을 가지게 되기 때문입니다. 그렇기에 foreground service는 사용자가 앱과 상호작용하지 않을 때도 계속 실행됩니다. 필요시 foreground service를 직접 사용하는 것보다 WorkManager API를 사용하기도 합니다.
 데이터 동기화 같이 정기적인 백그라운드에서의 활동은 background service입니다. 사용자가 실행되고 있다고 직접 인식할 수 없는 작업이므로 시스템은 좀 더 자유롭게 프로세스를 관리할 수 있습니다. 어느 앱이 압축 저장하는데 service를 사용했다면 이것은 대개 background service입니다. 이 service는 도중에 종료될 수도 있는데 사용자와 좀 더 직접적인 관련이 있는 작업에 RAM이 필요할 경우가 있기 때문입니다. 물론 나중에 service를 다시 시작할 수도 있습니다. 앱이 API 레벨 26 이상을 대상으로 한다면, 앱이 포그라운드에 있지 않을 때 시스템에서  background service 실행를 제한합니다. 백그라운드에서는 위치 정보에 엑세스하지 못하기 때문입니다. 이와 같은 경우에서는 WorkManager 사용해야 합니다.

 bound service는 다른 앱이나 component 심지어 다른 service에서 bindService()를 호출하여 해당 service를 바인딩하고 싶을 때 실행됩니다. bound service는 클라이언트-서버 인터페이스를 제공하여, component가 service와 상호작용하게 하고 응답을 보내 결과를 받을 수 있으며 여러 프로세스에 걸쳐 프로세스 간 통신(IPC)으로 수행할 수도 있습니다. 이는 service가 다른 프로세스에 API를 제공하고 시스템은 이러한 프로세스 사이의 종속성이 있음을 알게 됩니다. 예를 들어 프로세스 A가 프로세스 B의 service에 바인딩되어 있을 경우, 시스템은 프로세스 A를 위해 프로세스 B 및 그 service를 실행해야 한다고 인식하게 됩니다. 또한 사용자가 프로세스 A에 관심을 기울이고 있다면 시스템에서 프로세스 B도 사용자가 관심을 기울이는 것처럼 취급해야 합니다. bound service는 다른 애플리케이션 component에 바인딩되어 있는 경우에만 실행됩니다. 여러 componet가 service에 한꺼번에 바인딩될 수 있지만 바인딩이 해제되면 해당 service는 소멸됩니다. service는 유연하기 때문에 각종 고차원적 시스템 개념에서 매우 유용한 기본 구성 요소로 사용되었습니다. 라이브 배경화면, 알림 리스너, 화면 보호기, 입력 메서드, 접근성 서비스 및 여러 가지 기타 핵심 시스템 기능들은 애플리케이션에서 구현되고 애플리케이션이 실행될 때 시스템에서 바인딩되는 service로 빌드됩니다. 

 그러므로 serivce는 총 foregound, background, bound 세 가지 유형으로 나뉘게 됩니다. 다른 유형으로 나뉘게 된다고 별도의 service인 것은 아닙니다. started service 와 bound service를 동시에 동작할 수 있습니다. 즉 무한히 실행되도록 시작하면서 바인딩 할 수 있습니다. 이는 단순히 콜백 메서드를 구현 여부에 좌우되는 문제입니다. onStartCommand()는 component가 service를 시작하게 하고 onBind()는 바인드를 허용합니다. service가 시작되었든 바인딩 되었든 아니면 모두이든, component 혹은 별도의 애플리케이션이에서도 해당 service를 사용할 수 있으며 이는 어느 component든  Intent로 activity를 시작시킬 수 있는 것과 같습니다. 그러나 매니페스트에서 serivce를 비공개로 선언하고 다른 애플리케이션으로부터의 액세스를 차단할 수도 있습니다. 


3)manifest 선언
activity 및 다른 component와 마찬가지로, service는 모두 애플리케이션의 매니페스트 파일에서 선언해야 합니다. <service> 요소를 <application> 요소의 하위로 추가하면 됩니다.

<manifest ... >
  ...
  <application ... >
      <service android:name=".ExampleService" />
      ...
  </application>
</manifest>
 
 <service> 요소에는 service를 시작하는 데 필요한 권한과 service를 실행해야 하는 프로세스 등의 특성을 정의할 수 있습니다. android:name이 유일 필수 특성인데 service의 클래스 이름을 나타냅니다. 이 이름을 바꾸게 되면, service를 시작하거나 바인딩할 명시적 인텐트에 대한 종속성 때문에 코드가 깨질 위험이 있어 애플리케이션 출시 후에는 이 이름을 그대로 두어야 합니다. android:exported 특성을 포함하고 이를 false로 설정하면 해당 service를 본인의 앱에만 사용 가능하게 할 수 있습니다. 이렇게 하면 다른 앱이 여러분의 service를 시작하지 못하도록 효과적으로 방지하며, 이는 명시적 인텐트를 사용하는 경우에도 적용됩니다.

 앱의 보안을 지키기 위해서는 service를 시작할 때에는 항상 명시적 인텐트만 사용하고 service에 대한 인텐트 필터는 선언하지 말아야 합니다. 암시적 인텐트를 사용하여 service를 시작하면 보안이 위험해집니다. 인텐트에 어느 service가 응답할 것인지 확신할 수 없고, 사용자는 어느 service가 시작되는지 볼 수 없기 때문입니다. Android 5.0, API 레벨 21부터 시스템은 개발자가 암시적 인텐트로 bindService()를 호출하면 예외를 발생시킵니다.

사용자는 기기에서 어떤 service가 실행되는지 볼 수 있습니다. 정체를 모르거나 신뢰할 수 없는 service를 보면 사용자가 service를 중단할 수 있습니다. 사용자에 의해 우발적으로 service가 중단되는 불상사를 막으려면 앱 매니페스트의 <service> 요소에 android:description 특성을 추가해야 합니다. 여기에 service가 하는 일과 service의 장점을 설명하는 간략한 문장을 기재하면 됩니다.


4)주요 메서드
serivce를 생성하려면 Service의 하위 클래스나 이것의 기존 하위 클래스 중 하나를 생성해야 합니다. 구현에서는, 수명 주기의 주요 부분을 처리하는 일부 콜백 메서드를 재정의해야 하며 필요시 service에 바인딩할 component에 대한 메커니즘을 제공해야 합니다. 다음은 재정의가 필요한 중요한 콜백 메서드입니다.

onStartCommand()
activity 같은 다른 component가 service를 시작하고자 할 때, startService()을 부르면 시스템은 이 메서드를 호출합니다. 이 메서드가 실행되면, service가 시작되고 백그라운드에서 무한히 실행될 수 있습니다. service 작업이 완료되었을 때 해당 service를 중단하는 건 개발자 역량이며, 이때 stopSelf() 또는 stopService()를 호출하면 됩니다. 바인딩만 제공하고자 하는 경우 해당 메서드를 구현하지 않아도 됩니다.

onBind()
RPC 같이 다른 component가 해당 serivce에 바인딩되고자 할 때, bindService()을 부르면 시스템은 이 메서드를 호출합니다. 이 메서드에는 클라이언트가 service와 통신을 송수신할 때 사용할 인터페이스를 제공해야 하며 이 인터페이스는 IBinder를 반환해야 합니다. 이 메서드는 항상 구현해야 하지만 바인딩을 원치 않을 때는 null을 반환하면 됩니다.

onCreate()
시스템은 service가 처음 생성되었을 때, 즉 service가 onStartCommand() 또는 onBind()를 호출하기 전에 이 메서드를 호출하여 초기 설정 과정을 거칩니다. service가 이미 실행 중인 경우에는 호출되지 않습니다.

onDestroy()
service를 더 이상 사용하지 않고 소멸시킬 때 호출됩니다. service는 스레드, 등록된 리스너 또는 수신기 등의 각종 리소스를 정리하기 위해 구현해야 합니다. 이는 service가 수신하는 마지막 호출입니다.

어느 component가 startService()를 호출하여 service를 시작하면 onStartCommand()에 대한 호출 발생하고, 해당 service는 알아서 stopSelf()로 스스로 중단할 때까지 또는 다른 component가 stopService()를 호출하여 service를 중단시킬 때까지 실행 중인 상태로 유지됩니다. onStartCommand()를 호출하지 않은 채 bindService()만을 호출하여 service를 생성한다면, service는 해당 component에 바인딩되는 동안만 실행됩니다. service가 모든 클라이언트로부터 바인딩이 해제되면 시스템이 이를 소멸시킵니다.



2. Started Service란

1)Started Service?
started service는 다른 component가 startService()를 호출하면, 그 결과로 service의 onStartCommand() 메서드가 호출됩니다. service가 시작되면 이를 시작한 component와는 다른 독립적인 수명 주기를 가지게 됩니다. 해당 service를 시작한 component가 소멸되었더라도 service는 백그라운드에서 계속 실행될 수 있습니다. 따라서 service는 작업이 완료되면 stopSelf()를 호출하여 스스로 중단하거나 다른 component가 stopService()를 호출하여 중단시킵니다.

애플리케이션 component가 service를 시작할 때, startService()를 호출하고 Intent를 전달합니다. 이때 Intent에는 시작할 service를 지정하고 필요한 모든 데이터를 보냅니다. 그럼 이 Intent는 onStartCommand() 메서드에서 받습니다. 예를 들어 어느 activity가 온라인 데이터베이스에서 어떤 데이터를 저장해야 한다고 가정해보겠습니다. activity가 필요한 service를 시작하고, 인텐트를 startService()에 전달하여 service에 저장할 데이터를 전달합니다. service는 이 인텐트를 onStartCommand()에서 수신하고, 인터넷에 연결한 다음, 데이터베이스 트랜잭션을 수행합니다. 트랜잭션이 완료되면 service가 스스로 중단되어 소멸됩니다.

Service 클래스는 모든 service의 기본 클래스입니다. 이 클래스를 extend할 때는 새 스레드를 만드는 것이 중요합니다. service는 기본적으로 애플리케이션의 main 스레드를 사용하는데, 애플리케이션에서 실행 중인 작업에 영향을 주어 수행 속도가 느려질 수 있기 때문입니다. 그렇기에 안드로이드 프레임워크에서는 service의 하위 클래스인 IntentService를 제공했습니다. 이 클래스는 모든 시작 요청에 대해 한 번에 하나씩 처리하는 worker 스레드를 제공합니다. 하지만 백그라운드 실행 제한을 도입한 후, android 8부터 사용을 추천하지 않았으며 android 11부터는 deprecated 되었습니다. 그렇기에 지금은 IntentService대신 새로운 버전과 호환되는 JobIntentService를 사용합니다.

백그라운드 실행 제한?
백그라운드에서 실행 중인 service는 기기의 리소스를 소비하기 때문에 잠재적으로 나쁜 사용자 경험을 초래할 수 있습니다. 이러한 문제를 완화하기 위해, 시스템은 service에 여러 가지 제한을 적용합니다.


2)Service 클래스 확장(extends)
 모든 service의 기본 클래스입니다. 이 클래스를 확장할 때는 service가 모든 작업을 무사히 완료할 수 있게 새 스레드를 생성하는 것이 중요합니다. service는 기본적으로 애플리케이션의 main 스레드를 사용하기 때문에, 애플리케이션에 실행 중인 activity의 성능을 막기 위해서입니다. 또한 시작 요청을 동시에 처리해야 하는 경우에 적합합니다. 다만 대부분의 사용 사례에서 WorkManager 사용을 추천합니다.

 service가 멀티스레딩을 수행해야 하는 경우 Service 클래스를 확장하여 각각의 수신 인텐트를 처리하게 할 수 있습니다. 다음은 각 시작 요청에 대해 work 스레드로 작업을 수행하여 한 번에 하나씩만 순차적으로 처리하는 코드 예시입니다.

public class HelloService extends Service {
  private Looper serviceLooper;
  private ServiceHandler serviceHandler;

  //스레드에서 메시지를 받는 핸들러입니다
  private final class ServiceHandler extends Handler {
      public ServiceHandler(Looper looper) {
          super(looper);
      }
      @Override
      public void handleMessage(Message msg) {
       // 보통 여기서 파일 다운같은 작업을 합니다.
       // 본 예시에서는 단순히 5초 sleep 합니다
       try{
           Thread.sleep(5000);
       }catch(InterruptedException e){
          //인터럽트 상태 복원
          Thread.currentThread().interrupt();
       }
       //다른 작업을 처리하는 동안 service를 중지하지 않도록 
       //startId를 사용하여 service를 중지합니다
          stopSelf(msg.arg1);
      }
  }

  @Override
  public void onCreate() {
  //service를 실행하는 스레드를 시작합니다. 
 //service는 일반적으로 프로세스의 main 스레드에서 실행되므로 방해되지 않게 별도의  
 //스레드를 만듭니다.
 //또한 CPU 집약적 작업이 UI를 중단시키지 않도록 백그라운드 우선순위를 설정합니다.
    HandlerThread thread = new HandlerThread("ServiceStartArguments",
            Process.THREAD_PRIORITY_BACKGROUND);
    thread.start();

    // HandlerThread의 Looper를 얻어 핸들러에 사용합니다
    serviceLooper = thread.getLooper();
    serviceHandler = new ServiceHandler(serviceLooper);
  }

  @Override
  public int onStartCommand(Intent intent, int flags, int startId) {
  // 각 시작 요청에 대해 작업을 시작하라는 메시지와 start ID를 전달하면 
  //작업 완료 시 어떤 요청을 중지해야하는 알 수 있습니다
      Message msg = serviceHandler.obtainMessage();
      msg.arg1 = startId;
      serviceHandler.sendMessage(msg);

      //중단되면	이곳으로 리턴되어 재시작합니다
      return START_STICKY;
  }

  @Override
  public IBinder onBind(Intent intent) {
     //바인딩을 하지 않았기에 null을 반환시킵니다.
      return null;
  }

  @Override
  public void onDestroy() {
    Toast.makeText(this, "service done", Tost.LENGTH_SHORT).show()
  }
}

 위 예제코드는 onStartCommand()에 들어오는 모든 호출 처리와 백그라운드 스레드에서 실행되는 Handler 작업을 보여줍니다. 각 호출을 onStartCommand()로 직접 처리하기에 여러 개의 요청을 동시에 수행할 수 있습니다. 물론 위의 코드는 그런 작업을 하지 않지만 원하는 경우, 스레드풀에서 각 요청에 대해 새 스레드를 하나씩 생성한 다음 이전 요청이 끝날 때까지 기다리지 않고 곧바로 실행하면 됩니다.

 onStartCommand() 메서드는 반드시 정수를 반환해야 합니다. 이 정수는 시스템이 service를 종료할 경우 service를 어떻게 지속할 지 설명하는 값입니다. onStartCommand()로부터의 반환 값은 반드시 다음 상수 중 하나여야 합니다.

START_STICKY(1, 0x00000001)
시스템이 onStartCommand() 반환 후에 service를 중단하면, service를 다시 생성하여 onStartCommand()를 호출하되, 마지막으로 onStartCommand()으로 전달된 인텐트는 처리하지 않습니다. 그 대신 시스템이 인텐트 값을 null로 onStartCommand()를 호출합니다. 즉 service가 강제 종료가 되었을 경우 기존의 인텐트가 null로 초기화 되어 service를 재시작합니다. 단 service를 시작할 때 pending intent를 전달한 경우는 예외로, pending intent가 전달됩니다. 명령을 실행하지는 않지만 무한히 실행 중이며 작업을 기다리고 있는 미디어 플레이어 같은 service에 적합합니다.

START_NOT_STICKY(2, 0x00000002)
시스템이 service를 onStartCommand() 반환 후에 중단시키면 service를 재생성하지 않습니다. 다만 pending intent가 전달된 경우는 예외입니다. 이는 service가 불필요하게 실행되는 일을 피할 수 있는 가장 유용한 상수이며, 애플리케이션이 완료되지 않은 모든 작업을 단순히 다시 시작할 수 있을 때 유용합니다.

START_REDELIVER_INTENT(3, 0x00000003)
시스템이 onStartCommand() 반환 후에 service를 중단하는 경우, service를 다시 생성하고 이 service에 전달된 마지막 인텐트로 onStartCommand()를 호출합니다. 모든 pending intent는 차례로 전달됩니다. 파일 다운로드같이 즉시 재개되어야 하는 작업을 능동적으로 수행 중하는 service 에 적합합니다.



3) IntentService 클래스 확장
 Service의 하위 클래스로, 작업자 스레드를 사용하여 모든 시작 요청을 처리하되 한 번에 하나씩 처리합니다. service가 여러 개의 요청을 동시에 처리하지 않아도 되는 경우에 적합합니다. onHandleIntent()를 구현하는데 이는 각 시작 요청에 대해 인텐트를 수신해서 백그라운드 작업을 완료하도록 합니다.작업 큐를 통해 시작 요청을 처리

IntentService 클래스 확장
 started service는  여러 개의 요청을 동시에 처리하지 않아도 됩니다. 물론 이는 사실 위험한 다중 스레딩 시나리오일 수 있습니다. 사실 이 클래스는 Android 8 이후로는 사용할 수 없기 때문에 새로운 앱에서는 사용하지 않는 것이 좋습니다. 게다가 안드로이드 11부터는 더 이상 사용하지 않습니다.  IntentService의 대체품으로 최신 Android 버전과 호환되는  JobIntentService를 사용할 수 있습니다. 

IntentService 클래스는 다음과 같이 작동합니다.
-애플리케이션의 기본 스레드와는 별도로, onStartCommand()에 전달된 모든 인텐트를 실    행하는 기본 작업자 스레드를 생성합니다.
-인텐트를 한 번에 하나씩 onHandleIntent() 구현에 전달하는 작업 큐를 생성하므로, 다중    스레딩에 대해 염려할 필요가 전혀 없습니다.
-시작 요청이 모두 처리된 후 service를 중단하므로 개발자가 stopSelf()를 호출할 필요가     전혀 없습니다.
-onBind()의 기본 구현을 제공하여 null을 반환하도록 합니다.
-onStartCommand()의 기본 구현을 제공하여, 인텐트를 작업 큐로 보내고 그다음은          onHandleIntent() 구현으로 보냅니다.

클라이언트가 제공한 작업을 완료하기 위해 onHandleIntent()를 구현합니다. 
다음은 IntentService 구현의 예입니다.

public class HelloIntentService extends IntentService {

  /*생성자를 구현해야하며 super(작업생성자이름)을 꼭 생성해야합니다.*/
  public HelloIntentService() {
      super("HelloIntentService");
  }
  /**
  The IntentServic는 started the service 인텐트로 기본 작업자 스레드에서 이 메소드를 부릅니다. 이 메서드가 리턴하면  IntentService가 service를 적당한 시기에 멈춥니다
   */
  @Override
  protected void onHandleIntent(Intent intent) {
      // 보통 여기서 파일 다운같은 작업을 합니다.
  }
}
단지 생성자 하나와 onHandleIntent()만 구현하면 됩니다. 다른 콜백 메서드도 재정의하려면(예: onCreate(), onStartCommand() 또는 onDestroy()) 슈퍼 구현을 꼭 호출해야 합니다. 그래야만 IntentService가 작업자 스레드의 수명을 적절하게 처리할 수 있습니다. 예를 들어 onStartCommand()는 반드시 기본 구현을 반환해야 합니다. 그래야 인텐트가 onHandleIntent()로 전달됩니다. onHandleIntent() 외에 슈퍼 클래스를 호출하지 않아도 되는 메서드는 onBind() 뿐입니다. service가 바인드를 허용하는 경우에만 구현해야 합니다.


=====
service 시작
 activity 또는 다른 component에서 service를 시작하려면 Intent로 시작할 service를 지정하여 startService() 또는 startForegroundService()에 전달하면 됩니다. Android 시스템이 service의 onStartCommand() 메서드를 호출하고 여기에 시작할 service를 지정하는 Intent를 전달합니다. HelloService란 service를 activity가 시작하려면 startService()로 명시적 인텐트를 사용하면 됩니다.

Intent intent = new Intent(this, HelloService.class);
startService(intent);

 startService() 메서드가 즉시 반환되며 Android 시스템이 service의 onStartCommand() 메서드를 호출합니다. service가 아직 실행되지 않고 있다면 먼저 onCreate()를 호출한 다음, onStartCommand()를 호출해야 합니다.
 service가 바인딩을 제공하지 않는 경우, startService()와 함께 전달된 인텐트가 애플리케이션 component와 service 사이의 유일한 통신 수단입니다. 그러나 service가 결과를 돌려받기를 원하는 경우 service를 시작한 클라이언트가 PendingIngetBroadcast() 메소드를 사용하여 브로드캐스트으로 Intent를 만들고 이를 service를 시작한 Intent의 service에 전달할 수 있습니다. 그러면 service가 이 브로드캐스트으로 전달된 결과를 사용할 수 있게 됩니다.
 service를 시작하기 위한 요청을 여러 개 보내면 그에 대응하여 service의 onStartCommand()에 대해 여러 번 호출이 발생합니다. 반면 중단할 때는 stopSelf() 또는 stopService()으로 한 번만 중단을 요청하면 됩니다.
 만약 앱이 API 레벨 26 이상을 대상으로 한다면 앱이 포그라운드에 있지 않을 때 시스템에서 백그라운드 service 사용하거나 생성하는 것에 제한을 적용합니다. 앱이 포그라운드 service를 생성해야 하는 경우, 해당 앱은 startForegroundService()를 호출해야 합니다. 이 메서드는 백그라운드 service를 생성하지만, 메서드가 시스템에 신호를 보내 service가 자체적으로 포그라운드로 승격될 것이라고 알립니다. service가 생성되면 5초 이내에 startForeground() 메서드를 호출해야 합니다.
=====
service 중단
started service는 자신의 수명 주기를 직접 관리해야 합니다. 즉 시스템이 service를 중단하거나 소멸시키지 않는다는 뜻입니다. 다만 시스템 메모리를 회복해야 하고 service가 onStartCommand() 반환 후에도 계속 실행되는 경우는 예외입니다. service는 stopSelf()를 호출하여 스스로 중지하고 하고, 아니면 다른 component가 stopService()를 호출하여 이를 중지시킬 수 있습니다. 일단 stopSelf() 또는 stopService()로 중단 요청을 보내면 시스템은 가능한 한 빨리 service를 소멸시킵니다. service가 onStartCommand()에 대한 여러 요청을 동시에 처리하는 경우에는, 시작 요청의 처리를 끝낸 뒤에도 service를 중단하면 안 됩니다. 그 이후 새 시작 요청을 받았을 수 있기 때문입니다. 첫 요청이 끝날 때 중단하면 두 번째 요청이 종료될 수 있습니다. 이 문제를 피하려면, stopSelf(int)를 사용하여 service 중단 요청이 항상 가장 최근 시작 요청을 기준으로 하도록 해야 합니다. 다시 말해, stopSelf(int)를 호출할 경우 onStartCommand()에 전달된 startId를 전달하며, 여기에 중단 요청이 대응됩니다. 그런 다음 stopSelf(int)를 호출할 수 있게 되기 전에 service가 새 시작 요청을 수신하면 ID가 일치하지 않으므로 servcie는 중단되지 않습니다.
 단, 시스템 리소스 낭비를 피하고 배터리 전력 소모를 줄이기 위해서는 service의 작업이 완료되면 애플리케이션에서 service를 중단해야 합니다. 필요한 경우 stopService()를 호출하여 다른 component가 service를 중단할 수 있습니다. service에 대해 바인딩을 활성화하더라도, service가 onStartCommand()에 대한 호출을 한 번이라도 받았으면 항상 직접 service를 중단해야 합니다.
=====
포그라운드에서 service 실행
 foreground service는 사용자가 인식하고 있기에 메모리가 부족하더라도 시스템이 중단시킬 후보가 될 수 없습니다. foreground service는 상태 표시줄에 알림을 제공하기 때문에 service를 중단하거나 포그라운드에서 제거하지 않은 이상 알림을 해제할 수 없습니다. 그렇기에 foreground service를 너무 많이 사용하지 않도록 해야 합니다. 사용자의 눈에 잘 띄는 작업을 수행해야 하는 경우에만 사용해야 합니다. 사용자가 앱이 직접 상호작용을 주고받지 않을 때도 해당됩니다. 때문에 우선순위가 PRIORITY_LOW 이상이어야 하며, 이렇게 해야 사용자가 앱이 하는 일을 확실히 인식할 수 있습니다. 작업의 중요도가 낮아서 최소한의 우선순위 알림을 사용하고자 하는 경우에는 service를 사용하는 것보다 그 대신 예약된 작업을 사용하는 것이 낫습니다.
 service를 실행하는 앱은 모두 시스템에 추가적인 부하를 가하여 시스템 리소스를 소모합니다. 앱이 낮은 우선순위 알림을 사용해 service를 숨기려 하면 사용자가 활발히 상호작용을 주고받는 앱의 성능을 저해할 수 있습니다. 때문에 앱이 최소한의 우선순위 알림으로 service를 실행하려 하면 시스템이 앱의 동작에 대해 알림 드로어의 아래쪽 섹션에 호출하여 알립니다. 예를 들어 service에서 음악을 재생하는 음악 플레이어는 포그라운드에서 실행되도록 설정해야 합니다. 사용자가 작동을 분명히 인식하고 있기 때문입니다. 상태 표시줄에 있는 알림은 현재 노래를 나타내고, 사용자는 이 알림을 통해 음악 플레이어와 상호작용할 activity를 시작할 수 있습니다. 마찬가지로 사용자의 달리기 기록을 추적하는 앱은 사용자의 위치를 추적하는 데 foreground service가 필요할 수 있습니다. 
 Android 9(API 레벨 28) 이상을 대상으로 하고 foreground service를 사용하는 앱은 FOREGROUND_SERVICE 권한을 요청해야 합니다. 이 권한은 일반 권한이므로 시스템은 요청 앱에 자동으로 권한을 부여합니다. API 레벨 28을 대상으로 하는 앱이 FOREGROUND_SERVICE 권한 허가 없이 foreground service를 생성하려고 시도하면, 시스템이 SecurityException을 발생시킵니다.
<manifest xmlns:android="http://schemas.android.com/apk/res/android" ...>

    <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>

    <application ...>
        ...
    </application>
</manifest>

Context context = getApplicationContext();
Intent intent = new Intent(...); // service의 인텐트를 빌드합니다
context.startForegroundService(intent);
보통 onStartCommand()의 service 내부에서 service를 포그라운드에서 실행되도록 요청할 수 있습니다. 그러려면 startForeground()를 호출하면 됩니다. 이 메서드는 두 개의 매개변수를 취합니다. 그중 하나는 해당 알림을 고유하게 식별하는 정수이고 다른 하나는 상태 표시줄에 해당되는 Notification 객체입니다. 알림의 우선순위는 PRIORITY_LOW 이상이어야 합니다. 앱이 낮은 우선 순위의 알림을 사용하려고 하면 시스템이 알림 드로어에 메시지를 추가하여 사용자에게 앱의 foreground service 사용을 알립니다. 다음은 이에 대한 예입니다.
// 알람에 바로 답장하기 작업을 추가하고 싶으면 
//PendingIntent.FLAG_MUTABLE를 사용하면 됩니다.
Intent notificationIntent = new Intent(this, ExampleActivity.class);
PendingIntent pendingIntent =
        PendingIntent.getActivity(this, 0, notificationIntent,
                PendingIntent.FLAG_IMMUTABLE);

Notification notification =
          new Notification.Builder(this, CHANNEL_DEFAULT_IMPORTANCE)
    .setContentTitle(getText(R.string.notification_title))
    .setContentText(getText(R.string.notification_message))
    .setSmallIcon(R.drawable.icon)
    .setContentIntent(pendingIntent)
    .setTicker(getText(R.string.ticker_text))
    .build();

// 알람 ID는 0이 될 수 없습니다.
startForeground(ONGOING_NOTIFICATION_ID, notification);

service를 포그라운드에서 제거하려면 stopForeground()를 호출하면 됩니다. 이 메서드는 부울 값을 취하며, 상태 표시줄 알림도 제거할지 여부를 나타냅니다. 이 메서드는 service를 중단하지 않지만 service가 포그라운드에서 실행 중일 때 중단되면 알림도 마찬가지로 제거됩니다.
====
 Android 12(API 레벨 31)이상은 단시간 실행하는 foreground service를 위한 간소화된 환경을 제공합니다. 이 경우에서 시스템은 foreground service와 관련된 알림을 표시하기 전에 10초 동안 기다립니다. 항상 바로 알람을 표시하는 몇 유형의 service가 있기에 여러 예외가 있습니다.
=====
 foreground service를 사용하는 앱의 예는 다음과 같습니다

-foreground service에서 음악을 재생하는 뮤직 플레이어 앱입니다. 알림에 현재 재생 중    인 노래가 표시될 수 있습니다.
-사용자의 허가를 받은 foreground service에서 사용자의 러닝을 기록하는 피트니스 앱입    니다. 알림은 현재 피트니스 세션 중에 사용자가 이동한 거리를 표시할 수 있습니다.
=====
 Android 13(API 레벨 33)부터는 기본적으로 foreground service와 관련된 알림을 해제할 수 있습니다. 이를 위해 사용자는 알림에 스와이프 제스처를 수행합니다. 이전에는 foreground service가 중지되거나 포그라운드에서 제거되지 않는 한 알림은 해제되지 않습니다. 사용자가 알림을 해제할 수 없도록 하려면 Notification.Builder
을 사용하여 알림을 만들 때 setOngoing() 메서드에 true를 전달합니다.
=====
 foreground service에 다음 내용 중 하나라도 해당되면 Android 12 이상의 장치에서도 service 시작 직후에 관련 알림이 표시됩니다.

- service에 action button이 있는 알림과 연결되어 있습니다.
- service에 미디어 재생, 미디어 프로젝션 또는 전화 통화의 foregroundServiceType이      있습니다.
- 정의된 알림 카테고리 값에 전화, 내비게이션 또는 미디어 재생과 관련된 경우를 service     가 제공합니다.
- 알림 설정 시 FOREGROUT_SERVICE_IMMEDIATE를 setForgroundServiceBehavior()     로 전달하여 service는 동작 변화를 해제합니다.

 Android 13(API 레벨 33) 이상에서는 사용자가 알림 권한을 거부할 경우 작업 관리자에서 foreground service와 관련된 알림이 계속 볼 수 있지만 알림 드로어에는 표시되지 않습니다.
=====
 Android 12(API 레벨 31) 이상을 대상으로 하는 앱은 몇 가지 특별한 경우를 제외하고 백그라운드에서 실행되는 동안 foreground service를 시작할 수 없습니다. 만약 예외처리 사항을 처리하지 않았다면 시스템은 ForegroundServiceStartNotAllowedException를 발생시킵니다. 한 앱이 Context.startForgroundService()를 호출하여 다른 앱이 소유한 foreground service를 시작하는 경우 이러한 제한은 두 앱 모두 Android 12 이상을 대상으로 하는 경우에만 적용됩니다.
 백그라운드에서 실행되는 동안 앱이 foreground service를 시작하려는 사항을 잘 알 수 있게 하려면 이런 동작이 발생할 때마다 알림되도록 설정할 수 있습니다. 이렇게 하려면 테스트할 때 연결한 개발기기나 에뮬레이터에 다음 ADB 명령을 실행합니다.
$ adb shell device_config put activity_manager \
  default_fgs_starts_restriction_notification_enabled true
 만약 당신이 백그라운드에서 실행되는 동안 앱이 foreground service를 시작하는 것을 발견한다면 WorkManager를 사용하여 앱의 로직을 업데이트할 수 있습니다.
 다음과 같은 경우에는 앱이 백그라운드에서 실행되는 동안에도 앱이 foreground service를 시작할 수 있습니다

-앱이 activity같이 사용자가 볼 수 있는 상태로 전환할 때.
-기존 작업이 백스택에 있는 activity를 가진 경우를 제외하고 앱이 백그라운드에서
  activity 시작할 수 있을 때.
-Firebase Cloud Messaging을 사용하여 앱에 높은 우선 순위 메시지를 받습니다.
-도움말 풍선, 알람, 위젯이나 activty같이 사용작용할 수 있는 앱과 관련된 UI요소를 사용    자가 작업을 할 때

더 자세한 사항은 공식문서 참고해주세요. 
=====
앱에 실행 중인 foreground service를 사용자에 의해 멈추는 방법
 Android 13(API 레벨 33)부터 SDK 버전에 상관없이 foreground service를 실행하고 있는 앱을 멈추기 위해,  사용자는 알림 드로어에서 작업 흐름을 끝낼 수 있습니다. 이러한 동작을 작업 관리자라 하며 현재 foreground service를 실행 중인 앱 목록을 표시합니다. 이 목록은 활동 중인 앱이라고 부릅니다. 각 앱 옆에는 동작을 멈추는 버튼이 있습니다. 사진 1의 작업 관리자 작업은 Android13에서 실행중입니다. 작업 관리자에 있는 각 앱의 멈춤 버튼을 사용자가 누르게 되면 다음과 같은 일이 벌어집니다.

-시스템이 메모리에서 앱을 제거합니다. 그렇기에 foreground service뿐만 아니라 전체 앱    이 중지됩니다.
-시스템이 앱의 activity 백스택을 제거합니다.
-모든 미디어 재생이 중지됩니다.
-foreground service 연관된 알람이 제거됩니다.
-앱이 히스토리에 남습니다.
-예약된 작업은 예약된 시간에 실행됩니다.
-알람은 예약된 시간 또는 알람 창에 울립니다.

 사용자가 중지 버튼을 누를 때 시스템은 앱에 콜백을 보내지 않습니다. 앱이 백업을 시작할 때 ApplicationExitInfo API의 일부인 REASON_USER_REQUESTED 원인을 확인하는 것이 유용합니다.
사용자가 앱을 중지하는 동안과 이후에 앱이 예상대로 작동하는지 테스트하려면 터미널 창에서 다음 ADB 명령을 실행합니다
$adb shell cmd activity stop-app PACKAGE_NAME
=====
면제
 시스템은 다음 내용에서 설명하는 특정 유형의 앱에 대해 몇 가지 수준의 면제를 제공합니다. 면제는 프로세스별이 아니라 앱별로 이루어집니다. 시스템이 앱의 한 프로세스를 면제하면 해당 앱의 다른 모든 프로세스도 면제됩니다. 제조업체에서 제공한 일부 기본으로 설치된 앱도 면제될 수 있습니다.
 다음 앱은 foreground service를 실행할 수 있지만 작업 관리자에 전혀 표시되지 않습니다. (작업 관리자에 나타나는 예외)

-시스템 수준의 앱
-ROLE_EMERGENCY역할을 가진 보안 앱
-데모모드에 있는 기기

다음 유형의 앱은 foreground service를 실행하면 작업 관리자에 나타나지만 앱 이름 옆에 사용자가 탭할 수 있는 중지 버튼이 없습니다.(사용자가 중지하는 것에서의 예외)

Device owner apps
Profile owner apps
Persistent apps
- ROLE_DIALER 역할을 가진 앱



foreground service 타입 선언
 앱이 Android 10(API 레벨 29) 이상을 대상으로 foreground service의 위치 정보에 액세스하는 경우,  <service> 구성 요소의 속성에 foreground service의 위치 유형을 선언해야합니다. 앱이 Android 11(API 레벨 30) 이상을 대상으로 하고 foreground service에서 카메라 또는 마이크에 액세스하는 경우 <service> 구성 요소의 속성에  카메라 또는 마이크 foreground service 유형을 각각 선언해야합니다. 위치, 카메라 또는 마이크 유형을 추가하면 foreground service가 각 유형에 액세스할 수 있지만 이 foreground service는 Android 11에 의한 액세스 제한의 영향을 받습니다. 
 기본적으로 런타임에 startForground()를 호출하면 시스템은 사용자가 앱 매니페스트에 선언한 각 service 유형에 액세스합니다. 다음 내용의 코드 스니펫에 표시된 것처럼 선언된 service 유형의 하위 집합으로 액세스를 제한할 수 있습니다.
 앱의  foreground service가 장치의 위치와 카메라에 액세스해야 하는 경우 다음 스니펫에 표시된 대로 service를 선언합니다.
<manifest>
    ...
    <service ... android:foregroundServiceType="location|camera" />
</manifest>
 런타임에  foreground service가 매니페스트에 선언된 유형의 하위 집합에만 액세스해야 하는 경우 다음 코드 스니펫처럼 service 접근을 제한할 수 있습니다.
Notification notification = ...;
Service.startForeground(notification, FOREGROUND_SERVICE_TYPE_LOCATION);

 foreground service가 위치, 카메라 및 마이크에 접근해야 하는 경우 다음 스니펫에 표시된 대로 service를 선언합니다.
<manifest>
    ...
    <service ...
        android:foregroundServiceType="location|camera|microphone" />
</manifest>
 런타임에  foreground service가 매니페스트에 선언된 유형의 하위 집합에만 액세스해야 하는 경우 다음 코드 스니펫처럼 service 접근을 제한할 수 있습니다.
Notification notification = ...;
Service.startForeground(notification,
     FOREGROUND_SERVICE_TYPE_LOCATION|
FOREGROUND_SERVICE_TYPE_CAMERA);
 
 앱에서 작업 관리자를 사용하고 위치, 카메라 또는 마이크에 액세스해야 하는 장시간 실행 작업자가 있는 경우, 단계에 따라 장시간 실행 작업자에  foreground service을 추가하고 작업자가 사용하는 추가 또는 대체  foreground service 유형을 지정합니다. 다음  foreground service 유형 중에서 선택할 수 있습니다
-FOREGROUND_SERVICE_TYPE_LOCATION
-FOREGROUND_SERVICE_TYPE_CAMERA
-FOREGROUND_SERVICE_TYPE_MICROPHONE
=====
위치, 카마라, 마이크 접근 제한
 사용자의 개인 정보를 보호하기 위해 Android 11(API 레벨 30)은  foreground service가 장치의 위치, 카메라 또는 마이크 접근을 제한합니다. 앱이 백그라운드에서 실행되는 동안 앱이  foreground service를 시작하면  foreground service에는 다음과 같은 제한이 있습니다.
-사용자가 앱에  ACCESS_BACKGROUT_LOCATION 권한을 부여받지 않으면 foreground service는 위치에 액세스할 수 없습니다.
-foreground service는 마이크와 카메라에 접근할 수 없습니다.

 경우에 따라 앱이 백그라운드에서 실행되는 동안 foreground service가 시작되더라도 앱이 포그라운드에서 실행되는 동안(사용 중)에는 위치, 카메라 및 마이크 정보에 액세스할 수 있습니다. 동일한 상황에서 service가 foreground service 위치 유형을 선언하고 ACCESS_BACKGROUT_LOCATION 권한을 가진 앱에서 시작하는 경우 이 service는 앱이 백그라운드에서 실행되는 경우에도 항상 위치 정보에 액세스할 수 있습니다.
다음 내용은 위의 상황의 예시를 말합니다.
-시스템 component가 service를 시작합니다.
-앱 위젯과 상호작용하면서 service를 시작합니다.
-알람과 상호작용하면서 service를 시작합니다.
-가시성 있는 다른 앱에서 보낸 PendingIntent으로 service가 시작합니다.
-device owner모드에서 실행하는 device policy controller로 service가 시작합니다.
-VoiceInteractionService를 제공하는 앱에서 service를 시작합니다.
-START_ACTIVITIES_FROM_BACKGROUND 허가를 받은 앱에서 service를 시작합니다.
=====
앱에서 영향을 받는 service 검토
앱을 테스트할 때 자신의 oreground service를 시작합니다. started service가 위치, 마이크 및 카메라에 대한 액세스를 제한한 경우 다음 메시지가 Logcat에 나타납니다.

Foreground service started from background can not have \
location/camera/microphone access: service SERVICE_NAME
=====
bound service생성
 bound service는 bindService()를 호출하여 연결을 오래 유지하기위해 애플리케이션 component를 service에 바인딩하는 겁니다. 일반적으로는 startService()를 호출하더라도 component가 service를 시작하도록 허용하지 않습니다.
 activity와 애플리케이션의 component에서 service와 상호작용하기를 원하는 경우bound service를 생성해야 합니다. 아니면 애플리케이션의 기능 몇 가지를 프로세스 간 통신(IPC)을 통해 다른 애플리케이션에 노출하고자 하는 경우에도 사용됩니다.
 bound service를 생성하려면 onBind() 콜백 메서드를 구현하여 service의 통신을 위한 인터페이스를 정의하는 IBinder를 반환하도록 해야 합니다. 그러면 다른 애플리케이션 component가 bindService()를 호출하여 해당 인터페이스를 탐색하고, service에 있는 메서드를 호출할 수 있습니다. service는 자신에게 바인딩된 애플리케이션 component에 도움이 되기 위해서만 존재하기 때문에, service에 바인딩된 component가 없으면 시스템이 이를 소멸시킵니다. bound service는 service를 onStartCommand()를 통해 시작했을 때와 같은 방식으로 중단하지 않아도 됩니다.
 여러 클라이언트가 service에 한꺼번에 바인딩될 수 있습니다. 클라이언트가 service와의 상호작용이 끝나면 unbindService()를 호출하여 바인딩을 해제합니다. service에 바인딩된 클라이언트가 하나도 없으면 시스템이 해당 servcie를 소멸시킵니다.
 bound service를 구현하는 데에는 여러 가지 방법이 있지만 started service다 훨씬 복잡합니다.
Android 시스템이 service를 강제 중단하는 것은 메모리가 부족하여 사용자 포커스를 가진 activity를 위해 시스템 리소스를 회복해야만 하는 경우로만 국한됩니다. service가 사용자 포커스를 가진 activity에 바인딩 되었으면 종료될 가능성이 적고 service가 포그라운드에서 실행되도록 선언된 경우에는 종료될 가능성이 희박합니다. service가 시작되어 장시간 실행 중이라면 시스템은 시간이 지나면서 백그라운드 작업 목록에서 이 service가 차지하는 중요도를 낮추어 service가 종료될 가능성이 높아집니다. service가 시작되었다면 시스템에 의한 재시작을 정상적으로 처리하도록 설계해야 합니다. 시스템이 service를 중단하는 경우, 리소스를 다시 사용할 수 있게 되면 가능한 한 빨리 service가 다시 시작됩니다. 다만 개발자가 onStartCommand()에서 반환하는 값에 따라 달라집니다. 

 bound service란 클라이언트-서버 인터페이스 안의 서버를 말하며 일종의 Service 클래스 구현으로, 이를 통해 다른 애플리케이션이이 service에 바인딩하여 상호작용할 수 있도록 합니다. 이를 사용하면 component를 service에 바인딩하고, 요청을 보내고, 응답을 수신하며, 프로세스 간 통신(IPC)을 실행할 수 있습니다. 일반적으로 bound service는 다른 애플리케이션 component를 도울 때까지만 유지되고 백그라운드에서 무한히 실행되지 않습니다. service에 바인딩을 제공하려면 onBind() 콜백 메서드를 구현해야 합니다. 이 메서드는 클라이언트가 서비스와 상호작용하는 데 사용할 수 있는 프로그래밍 인터페이스를 정의하는 IBinder 객체를 반환합니다.
=====
started service에 바인딩
 위에 언급되었듯이 시작되었으면서도 바인드된 service를 만들 수 있습니다. 다시 말해, startService()를 호출하여 service를 시작하고 이를 통해 service가 무한히 실행되도록 할 수 있으며, bindService()를 호출하면 클라이언트가 service에 바인딩되도록 할 수 있다는 의미입니다. service가 시작되고 바인드되도록 허용한다면, service가 실제로 시작되었을 때 시스템은 클라이언트가 모두 바인딩을 해제해도 서비스를 소멸시키지 않습니다. 그 대신 service를 직접 확실히 중단해야 합니다. 그러려면 stopSelf() 또는 stopService()를 호출하면 됩니다.
 보통은 onBind() 또는 onStartCommand()를 구현하지만, 둘 다 구현해야 할 때도 있습니다. 예를 들어 음악 플레이어의 경우 service를 무한히 실행하면서 바인딩도 제공하는 것이 유용할 수 있습니다. 이 경우 어떤 activity에서 service를 시작해 음악을 재생하면, 사용자가 애플리케이션을 닫아도 음악이 계속 재생됩니다. 그런 다음, 사용자가 애플리케이션으로 다시 돌아오면 이activity를 service에 바인딩하여 재생 제어권을 다시 획득할 수 있습니다.
 클라이언트는 bindService()를 호출하여 service에 바인딩됩니다. 이때 service와의 연결을 모니터링하는 ServiceConnection의 구현을 반드시 제공해야 합니다. bindService()의 반환 값은 요청된 service가 존재하는지, 클라이언트에 service 액세스 권한이 있는지 나타냅니다. Android 시스템이 클라이언트와 service 사이에 연결을 생성하면 ServiceConnection에서 onServiceConnected()를 호출합니다. onServiceConnected() 메서드에는 IBinder 인수가 포함되고 클라이언트는 이를 사용하여 bound service 와 통신합니다.
 여러 클라이언트를 하나의 service와 동시에 연결할 수 있습니다. 그러나 시스템이 IBinder service 통신 채널을 캐시합니다. 다시 말해, 첫 번째 클라이언트가 바인딩될 때만 시스템이 service의 onBind() 메서드를 호출해 IBinder를 생성합니다. 그러면 시스템이 동일한 service에 바인딩되는 모든 추가 클라이언트에 동일한 IBinder를 전달합니다. onBind()는 다시 호출하지 않습니다. 마지막 클라이언트가 service에서 바인딩을 해제하면 시스템은 service를 소멸시킵니다. 단, service가 startService()로 시작되었을 경우는 예외입니다. bound service 를 구현할 때 가장 중요한 부분은 onBind() 콜백 메서드가 반환하는 인터페이스를 정의하는 것입니다.
=====
bound service  생성
바인딩을 제공하는 service를 생성할 때는 클라이언트가 service와 상호작용하는 데 사용할 수 있는 프로그래밍 인터페이스를 제공하는 IBinder를 제공해야 합니다. 인터페이스를 정의하는 방법은 세 가지가 있습니다.

바인더 클래스 확장
 service가 자신의 애플리케이션에 private하고 클라이언트와 같은 프로세스에서 실행되는 경우(이런 경우가 일반적), 인터페이스를 생성할 때 Binder 클래스를 확장하고 그 인스턴스를 onBind()에서 반환하는 방식을 사용해야 합니다. 클라이언트는 Binder를 받고, 이를 사용하여 Binder 구현이나 Service에서 제공되는 public 메서드에 직접 액세스할 수 있습니다. service가 애플리케이션을 위해 단순히 백그라운드에서 작동하는 요소에 그치는 경우 선호되는 기법입니다. 인터페이스를 생성할 때 이 방식을 사용하지 않는 경우는 service를 다른 애플리케이션이나 별도의 프로세스에서 사용할 때뿐입니다.

메신저 사용
 인터페이스가 여러 프로세스에서 작동해야 하는 경우, Messenger로 service 인터페이스를 생성할 수 있습니다. 이 방식을 사용하면 service가 여러 가지 유형의 Message 객체에 응답하는 Handler를 정의합니다. 이 Handler가 Messenger의 기초가 되어 클라이언트와 IBinder를 공유하고, 클라이언트는 Message 객체를 사용해 service에 명령어를 보낼 수 있게 됩니다. 그 외에도 클라이언트가 자체적으로 Messenger를 정의하여 service가 메시지를 돌려보내도록 할 수 있습니다.
 이것이 프로세스 간 통신(IPC)을 실행하는 가장 간단한 방법입니다. Messenger가 모든 요청을 단일 스레드로 큐에 저장하므로 service를 스레드로부터 안전하게 설계할 필요가 없기 때문입니다.

AIDL 사용
 Android 인터페이스 정의 언어(AIDL)는 객체를 운영체제가 이해할 수 있는 원시 유형으로 해체한 다음, 여러 프로세스에서 마샬링하여 IPC를 실행합니다. Messenger를 사용하는 이전 기법은 실제로 AIDL을 기본 구조로 하고 있습니다. 위에서 언급한 바와 같이 Messenger는 단일 스레드에 모든 클라이언트 요청 큐를 생성하므로 service는 한 번에 하나씩 요청을 수신합니다. 그러나 service가 동시에 여러 요청을 처리하게 하려면 AIDL을 직접 사용해도 됩니다. 이 경우에 service는 스레드로부터 안전해야 하고 다중 스레딩 처리가 가능해야 합니다.
 AIDL을 직접 사용하려면 프로그래밍 인터페이스를 정의하는 .aidl 파일을 생성해야 합니다. Android SDK 도구는 이 파일을 사용하여 인터페이스를 구현하고 IPC를 처리하는 추상 클래스를 생성합니다. 그 후에는 개발자가 서비스 내에서 이 추상 클래스를 확장하면 됩니다. 대부분의 애플리케이션은 bound service를 생성할 때 AIDL을 사용하면 안 됩니다. 그렇게 하면 다중 스레딩 기능이 필요할 수 있고 따라서 구현이 더욱 복잡해지기 때문입니다. 이런 이유로 AIDL은 대부분의 애플리케이션에 적합하지 않습니다.
=====
바인더 클래스 확장
 service가 로컬 애플리케이션에서만 사용되고 여러 프로세스에서 작동할 필요가 없는 경우, 자체적인 Binder 클래스를 구현하여 클라이언트가 service 내의 public 메서드에 직접 액세스하도록 할 수도 있습니다. 설정하는 방법은 다음과 같습니다.

1. service에서 다음 중 한 가지 기능을 하는 Binder의 인스턴스를 생성합니다.
-클라이언트가 호출할 수 있는 public 메서드를 포함합니다.
-클라이언트가 호출할 수 있는 public 메서드가 있는 현재 Service 인스턴스를 반환합니다.
-클라이언트가 호출할 수 있는 public 메서드가 포함된 service가 호스팅하는 다른 클래스의 인스턴스를 반환합니다.
2.Binder의 인스턴스를 onBind() 콜백 메서드에서 반환합니다.
3.클라이언트의 경우, Binder를 onServiceConnected() 콜백 메서드에서 받아서 제공된 메서드로 bound service를 호출합니다.

 service와 클라이언트가 같은 애플리케이션에 있어야 클라이언트가 반환된 객체를 전송하여 그 API를 적절히 호출할 수 있습니다. 또한 service와 클라이언트는 같은 프로세스에 있어야 하기도 합니다. 이 기법에서는 여러 프로세스에서 마샬링을 전혀 실행하지 않기 때문입니다.
 다음 예시는 service가 Binder 구현을 통해 service 내의 메서드에 액세스할 수 있는 권한을 클라이언트에 제공하는 것을 보여줍니다.

public class LocalService extends Service {
    // 클라이언트에 제공된 바인더
    private final IBinder binder = new LocalBinder();
    // 랜덤 숫자 생성기
    private final Random mGenerator = new Random();

    /**
     *클라이언트 바인더에 사용되는 클래스입니다. 이 service는 항상  클라이언트와 
     * 동일한 프로세스에서 실행되므로 IPC를 처리할 필요가 없습니다.
      */
    public class LocalBinder extends Binder {
        LocalService getService() {
            // LocalService의 this 인스턴스를 리턴하기에 클라이언트는 public 메소드	     들을 호출할 수 있습니다.
            return LocalService.this;
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        return binder;
    }

    /** 클라이언트를 위한 메소드 */
    public int getRandomNumber() {
      return mGenerator.nextInt(100);
    }
}

 LocalBinder는 LocalService의 현재 인스턴스를 검색하기 위한 getService() 메서드를 클라이언트에 제공합니다. 이렇게 하면 클라이언트가 service 내의 public 메서드를 호출할 수 있습니다. 예를 들어 클라이언트는 service에서 getRandomNumber()를 호출할 수 있습니다.
 다음은 버튼을 클릭했을 때 LocalService에 바인딩되어 getRandomNumber()를 호출하는 활동을 나타냅니다.

public class BindingActivity extends Activity {
    LocalService mService;
    boolean mBound = false;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
    }

    @Override
    protected void onStart() {
        super.onStart();
        // LocalService로 바인드
        Intent intent = new Intent(this, LocalService.class);
        bindService(intent, connection, Context.BIND_AUTO_CREATE);
    }

    @Override
    protected void onStop() {
        super.onStop();
        unbindService(connection);
        mBound = false;
    }

    /** 버튼이 클릭되었을 때 호출(레이아웃 파일의 버튼에서 android:onClick 
       속성으로 이 메소드를 결합 **/
    public void onButtonClick(View v) {
        if (mBound) {
            // LocalService에서의 메소드를 호출. 하지만 그러나 이 호출이 중단될 경우
            // 활동 성능 저하를 방지하기 위해 별도의 스레드에서 이 요청이
	    // 발생해야 합니다.
            int num = mService.getRandomNumber();
            Toast.makeText(this, "number: " + num, Toast.LENGTH_SHORT).show();
        }
    }

    /** bindService()에 전달된 service 바인딩에 대한 콜백을 정의합니다. */
    private ServiceConnection connection = new ServiceConnection() {

        @Override
        public void onServiceConnected(ComponentName className,
                IBinder service) {
            // LocalService로 바인드하여 IBinder를 캐스트하고 
	    //LocalService 인스턴스를 가져옵니다.
            LocalBinder binder = (LocalBinder) service;
            mService = binder.getService();
            mBound = true;
        }

        @Override
        public void onServiceDisconnected(ComponentName arg0) {
            mBound = false;
        }
    };
}

위 예시는 클라이언트가 ServiceConnection 구현과 onServiceConnected() 콜백을 사용하여 service에 바인딩되는 방법을 보여줍니다. onStop() 메서드는 service에서 클라이언트의 바인딩을 해제합니다. 적절한 시기에 service에서 클라이언트의 바인딩을 해제해야 합니다(추가 참고사항에 설명됨).
=====
메신저 사용
 service가 원격 프로세스와 통신해야 한다면 Messenger를 사용하여 service에 인터페이스를 제공할 수 있습니다. 이 기법을 사용하면 AIDL을 쓰지 않고도 프로세스 간 통신(IPC)을 실행할 수 있습니다.
인터페이스에 Messenger를 사용하는 것이 AIDL을 사용하는 것보다 더욱 간단합니다. Messenger는 모든 service 호출을 큐에 올리기 때문입니다. 순수한 AIDL 인터페이스는 service에 동시 요청을 보내고, 이를 받은 service는 다중 스레딩을 처리해야 합니다. 대부분의 애플리케이션에서는 service가 다중 스레딩을 처리할 필요가 없으므로 Messenger를 사용하면 한 번에 하나씩 호출을 처리할 수 있습니다. service의 다중 스레딩 처리가 중요한 경우, AIDL을 사용하여 인터페이스를 정의해야 합니다. 다음은 Messenger 사용 방법을 간략하게 요약한 것입니다.

1. service가 각 클라이언트 호출의 콜백을 받는 Handler를 구현합니다.
2. 그러면 service가 Handler를 사용하여 Messenger 객체(Handler의 참조)를 생성합니다.
3. Messenger가 IBinder를 생성하고, service가 이를 onBind()에서 클라이언트로 반환하도록 합니다.
4. 클라이언트는 IBinder를 사용하여 Messenger(service의 Handler를 참조)를 인스턴스화하고, 이를 이용하여 Message 객체를 service에 전송합니다.
5. service가 각 Message를 Handler로 수신합니다. 구체적으로는 handleMessage() 메서드를 사용합니다.

 이렇게 하면 클라이언트가 service에서 호출할 메서드가 없습니다. 대신 클라이언트는 메시지(Message 객체)를 전달하여 service가 Handler로 받을 수 있도록 합니다.

다음은 Messenger 인터페이스를 사용하는 service의 간단한 예시입니다.

public class MessengerService extends Service {
    // 메시지를 표시하는 service 명령
    static final int MSG_SAY_HELLO = 1;

 //클라이언트에서 오는 메시지 Handler
    static class IncomingHandler extends Handler {
        private Context applicationContext;

        IncomingHandler(Context context) {
            applicationContext = context.getApplicationContext();
        }

        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case MSG_SAY_HELLO:
                    Toast.makeText(applicationContext, "hello!", Toast.LENGTH_SHORT).show();
                    break;
                default:
                    super.handleMessage(msg);
            }
        }
    }

   //  클라이언트가 IncomingHandler에 메시지를 보낼 수 있게 하는 대상
    Messenger mMessenger;

    /**
     * service에 바인딩할 때 service에 메시지를 보내기 위해 
     *  메신저에 인터페이스를 반환
     */
    @Override
    public IBinder onBind(Intent intent) {
        Toast.makeText(getApplicationContext(), "binding", Toast.LENGTH_SHORT).show();
        mMessenger = new Messenger(new IncomingHandler(this));
        return mMessenger.getBinder();
    }
}

참고로 Handler의 handleMessage() 메서드에서 service가 수신되는 Message를 받고 what 멤버에 기초하여 무엇을 할지 결정합니다.

 클라이언트는 service가 반환한 IBinder에 기초하여 Messenger를 생성하고 send()로 메시지를 전송하기만 하면 됩니다. 예를 들어, 다음은 service에 바인딩되어 MSG_SAY_HELLO 메시지를 service에 전달하는 간단한 활동입니다.

public class ActivityMessenger extends Activity {
    /**service와 통신하기 위한 메신저 */
    Messenger mService = null;

    /** service에서 바인드를 호출했는지 여부를 나타내는 flag */
    boolean bound;


     // service의 주요 인터페이스와 상호작용을 위한 클래스
    private ServiceConnection mConnection = new ServiceConnection() {
        public void onServiceConnected(ComponentName className, IBinder service) {
            // service와의 연결이 설정된 경우 이를 호출하여 service와
            // 상호 작용하는데 사용할 수 있는 개체를 제공.
            // 메신저를 사용하여 service와 통신하기 때문에
            // 여기서는 원시 IBinder 객체에서 클라이언트 측 표현을 얻음
            mService = new Messenger(service);
            bound = true;
        }

        public void onServiceDisconnected(ComponentName className) {
            // 서비스와의 연결이 예기치 않게 끊어졌을 때, 
	   // 즉 프로세스가 중단되었을 때 이를 호출
            mService = null;
            bound = false;
        }
    };

    public void sayHello(View v) {
        if (!bound) return;
        // 기본적으로 지원되는 'what' 값을 사용하여 service에 메시지 생성 및 전송
        Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0);
        try {
            mService.send(msg);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
    }

    @Override
    protected void onStart() {
        super.onStart();
        //service에 바인드
        bindService(new Intent(this, MessengerService.class), mConnection,
            Context.BIND_AUTO_CREATE);
    }

    @Override
    protected void onStop() {
        super.onStop();
        // service 해제
        if (bound) {
            unbindService(mConnection);
            bound = false;
        }
    }
}

이 예시는 service가 클라이언트에 응답하는 방식을 보여주지는 않습니다. service가 응답하게 하려면 클라이언트에서 Messenger도 생성해야 합니다. 클라이언트가 onServiceConnected() 콜백을 받으면 send() 메서드의 replyTo 매개변수에 클라이언트의 Messenger를 포함하는 service에 Message를 전송합니다. 
=====
service에 바인딩
service을 바인딩하려면 bindService()를 호출하면 됩니다. 그러면 Android 시스템이 service의 onBind() 메서드를 호출하고, 이 메서드가 service와의 상호작용을 위한 IBinder를 반환합니다. 바인딩은 비동기식으로 처리되고, IBinder를 클라이언트에 반환하지 않은 상태에서 bindService()가 즉시 반환됩니다. IBinder를 수신하려면 클라이언트는 ServiceConnection의 인스턴스를 생성하고 이를 bindService()에 전달해야 합니다. ServiceConnection은 시스템이 IBinder를 전달하기 위해 호출하는 콜백 메서드를 포함합니다. Activity, service, content provider만 service에 바인딩할 수 있으며, broadcast receiver에서는 service에 바인딩할 수 없습니다. 클라이언트에서 service에 바인딩하려면 다음 단계를 따르세요.

1. ServiceConnection을 구현합니다.
 이 구현으로 두 가지 콜백 메서드를 재정의해야 합니다.
-onServiceConnected()
 시스템이 이를 호출하여 service의 onBind() 메서드가 반환한 IBinder를 전달합니다.
-onServiceDisconnected()
 Android 시스템은 service로의 연결이 예기치 못하게 끊어졌을 경우, 예를 들어 service가 비정상 종료되었거나 중단되었을 때 호출합니다. 클라이언트가 바인딩을 해제할 때는 호출되지 않습니다.

2. bindService()를 호출하여 ServiceConnection 구현을 전달합니다.
 메서드가 false를 반환하면 클라이언트가 service에 제대로 연결되지 않았다는 것을 의미합니다. false이라도 클라이언트는 unbindService()를 호출해야 합니다. 그렇지 않으면 클라이언트가 유휴 상태인 service를 종료하지 못하게 합니다.

3. 시스템이 onServiceConnected() 콜백 메서드를 호출하면, 인터페이스가 정의한 메서드를 사용하여 service에 호출을 시작할 수 있습니다.

4. service로부터 연결을 해제하려면 unbindService()를 호출합니다.
 클라이언트가 service에 여전히 바인딩 되었지만 앱이 클라이언트를 소멸시킬 때 이 소멸로 인해 클라이언트가 바인딩 해제됩니다. 클라이언트가 service와의 상호작용을 완료하는 즉시 바인딩을 해제하는 편이 좋습니다. 이렇게 하면 유휴 상태인 service를 종료할 수 있습니다. 

 다음 예시에서는 위와 같이 바인더 클래스를 확장해서 생성한 service에 클라이언트를 연결합니다. 여기에서는 반환된 IBinder를 LocalBinder 클래스로 전송하고 LocalService 인스턴스를 요청하기만 하면 됩니다.

LocalService mService;
private ServiceConnection mConnection = new ServiceConnection() {
    // service와의 연결이 설정되면 호출
    public void onServiceConnected(ComponentName className, IBinder service) {
        //자체 프로세스에서 실행되는 명시적 service에 바인딩 되기 때문에
        // IIBinder를 특정 클래스에 캐스팅하고 직접 액세스할 수 있음
        LocalBinder binder = (LocalBinder) service;
        mService = binder.getService();
        mBound = true;
    }

    //service와의 연결이 예기치 않게 끊어지면 호출
    public void onServiceDisconnected(ComponentName className) {
        Log.e(TAG, "onServiceDisconnected");
        mBound = false;
    }
};

 다음 예시에서와 같이, ServiceConnection이 있으면 클라이언트는 이를 bindService()에 전달하여 service에 바인딩할 수 있습니다.

Intent intent = new Intent(this, LocalService.class);
bindService(intent, connection, Context.BIND_AUTO_CREATE);

-bindService()의 첫 번째 매개변수는 바인딩할 service의 이름을 명시적으로 지정하는 Intent입니다. 인텐트를 사용하여 Service에 바인딩하는 경우 명시적 인텐트를 사용하여 앱의 보안을 유지시켜야 합니다. 암시적 인텐트를 사용하여 service를 시작하면 어떤 service가 인텐트에 응답할지 확신할 수 없고 어떤 service가 시작하는지 사용자가 알 수 없으므로 보안 위험이 있습니다. Android 5.0(API 수준 21)부터는 암시적 인텐트로 bindService()를 호출하면 시스템에서 예외가 발생합니다.

-두 번째 매개변수는 ServiceConnection 객체입니다.

-세 번째 매개변수는 바인딩 옵션을 나타내는 플래그입니다. 일반적으로는 BIND_AUTO_CREATE가 되는데, 이는 service가 아직 활성화되지 않았을 경우 service를 생성하기 위함입니다. 그 외에는 BIND_DEBUG_UNBIND와 BIND_NOT_FOREGROUND를 사용할 수 있고 값이 없으면 0으로 설정합니다.
=====
추가 참고사항
다음은 service로의 바인딩에 관한 몇 가지 중요한 참고사항입니다.

-항상 DeadObjectException 예외 사항을 작성해야하며 연결이 끊어지면 발생합니다. 이 예외만 유일하게 원격 메서드에 의해 발생합니다.
-객체는 여러 프로세스에 걸쳐 카운트되는 참조입니다.
-일반적으로 클라이언트의 수명 주기가 발생하고 해제되는 타이밍에 맞추어 바인딩과 바인딩 해제를 짝지어야 합니다. 이 내용은 다음 예시에서 설명합니다.
=activity가 표시되는 동안에만 service와 상호작용해야 할 경우, onStart() 중에는 바인딩하고 onStop() 중에는 바인딩을 해제해야 합니다.
=백그라운드에서 activity가 중단되었을 때도 응답을 받게 하고 싶을 경우, onCreate() 중에는 바인딩하고 onDestroy() 중에는 바인딩을 해제하면 됩니다. 백그라운드에서 실행되는 시간을 포함하여 service가 실행되는 내내 activity가 service를 사용한다는 것을 유념해야 합니다. service가 다른 프로세스에 있을 경우, 사용자가 그 프로세스의 가중치를 높이면 시스템이 이를 중단할 가능성이 커집니다.
 일반적으로 activity의 onResume()과 onPause() 중에는 바인딩하거나 바인딩을 해제하지 말아야 합니다. 이러한 콜백은 모든 수명 주기 전환에서 발생하고 이런 전환에서 발생하는 처리는 최소한으로 유지해야 하기 때문입니다. 또한, 애플리케이션의 여러 activity가 동일한 service에 바인딩 되었고 두 activity 사이에 전환이 있을 경우, 현재 activity의 바인딩이 해제된 후(일시중지 중) 다음 activity가 바인딩되기 전(다시 시작 중)에 service가 제거되었다가 다시 생성될 수 있습니다. 
=====
bound service 수명 주기 관리
 모든 클라이언트에서 service가 바인딩 해제되면 Android 시스템이 이를 소멸시킵니다. 물론 startService() 호출과 함께 시작된 경우는 예외입니다. 따라서 service가 순수하게 bound service일 경우에는 service의 수명 주기를 관리하지 않아도 됩니다. 클라이언트에 바인딩되었는지 여부에 따라 Android 시스템이 대신 관리해주기 때문입니다. 그러나 onStartCommand() 콜백 메서드 구현을 선택하는 경우라면 service를 확실히 중지해야 합니다. service가 지금 시작된 것으로 간주되기 때문입니다. 이 경우 service가 클라이언트에 바인딩되어 있는지 여부와 관계없이, stopSelf()를 통해 service가 스스로 중지되거나 다른 component가 stopService()를 호출할 때까지 service가 실행됩니다.
 또한 service가 시작되고 바인딩을 허용하는 경우 시스템에서 onUnbind() 메서드를 호출한 다음 클라이언트가 service에 바인딩 될 때 onRebind() 호출을 수신하고 싶다면, true를 선택적으로 반환할 수 있습니다. onRebind()는 void를 반환하지만 클라이언트는 여전히 onServiceConnected() 콜백에서 IBinder를 수신합니다. 아래의 그림은 이런 종류의 수명 주기에 관한 로직을 보여줍니다.

=====
사용자가 애플리케이션과 상호작용할 때 기본 스레드 밖에서 작업을 수행해야 하는 경우, 새 스레드를 생성해야 합니다. 예를 들어 activity가 실행되는 중에만 음악을 재생하고자 하는 경우, onCreate() 안에 스레드를 생성하여 onStart()에서 실행한 다음 onStop()에서 중단하면 됩니다. 또한 기존의 Thread 클래스 대신 AsyncTask 또는 HandlerThread를 사용할 수도 있습니다.
service는 기본적으로 자신의 호스팅 프로세스의 기본 스레드에서 실행됩니다. service는 자신의 스레드를 직접 생성하지 않으며, 특별히 지정하지 않는 한 별도의 프로세스에서 실행되지도 않습니다. service가  MP3 재생 또는 네트워킹 같이 CPU 집약적인 작업을 수행할 예정이거나 차단 작업을 수행할 예정인 경우 성능을 위해 service 내에 새 스레드를 생성해야 합니다. 별도의 스레드를 사용하면 '애플리케이션이 응답하지 않습니다(ANR)' 오류가 일어날 위험을 줄일 수 있으며, 애플리케이션의 기본 스레드는 액티비티와 사용자 상호작용 전용으로 유지될 수 있습니다.
=====
사용자에게 알림 전송
 service가 실행되고 있을 때 사용자에게 토스트 알림 또는 상태 표시줄 알림 등을 사용해 이벤트를 알릴 수 있습니다. 토스트 알림은 현재 창의 표면에 잠깐 나타났다가 사라지는 메시지입니다. 상태 표시줄 알림은 상태 표시줄에 메시지가 담긴 아이콘을 제공하여 사용자가 이를 선택하면 activity 시작 같은 활동을 할 수 있게 합니다. 보통 파일 다운로드 완료 같은 일종의 백그라운드 작업이 완료되었고 이제 사용자가 그에 대해 조치를 취할 수 있는 경우에는 상태 표시줄 알림을 사용하는 것이 가장 좋습니다. 사용자가 확장된 뷰의 알림을 선택하면 해당 알림은 다운로드한 파일 보기 같은 activity를 시작할 수 있습니다.
=====
서비스 수명 주기 관리
service의 수명 주기는 activity의 수명 주기보다 훨씬 간단합니다. 하지만 service를 생성하고 소멸하는 방법에 특히 주의를 기울여야 한다는 면에서 중요도는 더 높습니다. servcie는 사용자가 모르는 채로 백그라운드에서 실행될 수 있기 때문입니다.
생성부터 소멸되는 시점까지의 service 수명 주기는 두 가지의 다른 경로를 가집니다.
started service 
다른 component가 startService()를 호출하면 servcie가 생성됩니다. 그러면 service가 무기한으로 실행될 수 있으며, stopSelf()를 호출해서 자체적으로 중단해야 합니다. 다른 component가 stopService()를 호출하면 service를 중단시킬 수 있습니다. service가 중단되면 시스템이 소멸시킵니다.
bound service
다른 component, 클라이언트가 bindService()를 호출하면 service가 생성됩니다. 그러면 클라이언트가 IBinder 인터페이스를 통해 service와 통신을 주고받을 수 있습니다. 클라이언트가 연결을 종료하려면 unbindService()를 호출하면 됩니다. 여러 클라이언트가 같은 servcie에 바인딩될 수 있으며, 모든 클라이언트가 바인딩을 해제하면 시스템이 해당 servcie를 소멸시킵니다. servcie가 스스로 중단하지 않아도 됩니다.
 두 가지 경로로 나뉘지만 완전히 별개는 아닙니다. 이미 startService()로 시작된 service에 바인딩할 수도 있습니다. 예를 들어 재생할 음악을 식별하는 Intent를 포함해 startService()를 호출하면 백그라운드 음악 서비스를 시작할 수 있습니다. 나중에 사용자가 플레이어에 좀 더 많은 통제력을 발휘하려고 하거나 현재 노래에 대한 정보를 얻고자 할 때, activity가 bindService()를 호출하여 service에 바인딩할 수 있습니다. 이와 같은 경우에는 모든 클라이언트가 바인딩을 해제할 때까지 stopService() 또는 stopSelf()가 service를 중단하지 않습니다.
=====
수명 주기 콜백 구현
activity와 마찬가지로 service에도 수명 주기 콜백 메서드가 있어, 이를 구현하면 service의 상태 변경 내용을 모니터할 수 있고 적절한 시기에 작업을 수행할 수 있습니다. 다음의  service는 각 수명 주기 메서드를 보여줍니다.

public class ExampleService extends Service {
    int startMode;       // service가 종료되면 어떻게 행동할지 나타냄
    IBinder binder;      // 클라이언트와 바인드할 인터페이스
    boolean allowRebind; // onRebind를 사용 여부 나타냄

    @Override
    public void onCreate() {
        // service생성하는 곳
    }
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        //service()에서 mStartMode가 리턴되어 service가 시작하는곳
    }
    @Override
    public IBinder onBind(Intent intent) {
        // bindService()에서 mBinder가 리턴되어 클라이언트가 service와 바인딩되는 곳
    }
    @Override
    public boolean onUnbind(Intent intent) {
        unbindService()에서 mAllowRebind가 리턴되어 모든 클라이언트가 해제됨
    }
    @Override
    public void onRebind(Intent intent) {
        //onUnbind()가 이미 호출된 후 클라이언트가 
	//bindService()로 service와 바인딩되는 곳
    }
    @Override
    public void onDestroy() {
        // service가 더 이상 사용되지 않아 소멸되는 곳
    }
}

activity 수명 주기 콜백 메서드와는 service는 슈퍼클래스 구현을 호출하지 않아도 됩니다.

 그림 2는 service에 대한 일반적인 콜백 메서드를 나타낸 것입니다. 이 그림에서는 startService()로 생성된 service와 bindService()로 생성된 service를 구분하고 있지만, 어떤 식으로 시작되었든 모든 service는 클라이언트와 바인딩될 수 있습니다. 클라이언트가 startService()호출하여 onStartCommand()로 처음 시작된 service라고 해도 클라이언트가 bindService()를 호출하면 여전히 onBind()에 대한 호출을 받을 수 있습니다. 
 
메서드를 구현함으로써, service 수명 주기의 두 가지 중첩된 루프를 모니터링할 수 있습니다.
-service의 전체 수명은 onCreate()가 호출된 시점부터 onDestroy() 반환 시점까지입니다. activity와 마찬가지로 service는 자신의 초기 설정을 onCreate()에서 수행하며, 남은 리소스를 모두 onDestroy()에서 릴리스합니다. 예를 들어 음악 재생 service는 스레드를 생성하고, 이 스레드의 onCreate()에서 음악이 재생됩니다. 그런 다음, onDestroy()에서 스레드를 중단할 수 있습니다. onCreate() 및 onDestroy() 메서드는 모든 service에 호출됩니다. 이는 service가 startService()로 생성되었든 bindService()로 생성되었든 상관없이 적용됩니다.
-service의 활성 수명은 onStartCommand() 또는 onBind()에 대한 호출에서부터 시작됩니다. 각 메서드는 Intent를 받아서 startService() 또는 bindService()에 전달합니다. service가 시작되면 수명 주기 전체가 종료되는 것과 동시에 활성 수명 주기도 종료됩니다. service는 onStartCommand()가 반환된 뒤에도 여전히 활성 상태입니다. service가 바인딩된 경우, onUnbind()가 반환되면 활성 수명 주기가 종료됩니다. 시작된 service를 중단하려면 stopSelf() 또는 stopService()를 호출하면 되지만, service에 대한 개별 콜백은 없습니다. 즉 onStop() 콜백이 없습니다. 그러므로 service가 클라이언트에 바인딩되어 있지 않은 한, 시스템은 service가 중단되면 이를 소멸시킵니다. 수신되는 콜백은 onDestroy()가 유일합니다.
