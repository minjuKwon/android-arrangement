 service는 백그라운드에서 앱을 계속 실행하기 위한 다목적 진입점입니다. 이는 UI없이 백그라운드에서 실행되는 구성 요소로, 오랫동안 실행되는 작업을 수행하거나 원격 프로세스를 위한 작업을 수행합니다. 예를 들어 service는 사용자가 다른 앱에 있는 동안에 백그라운드에서 음악 재생과 파일 I/O 수행 그리고 사용자와 activity간의 상호작용을 차단하지 않고 네트워크를 통해 데이터를 가져올 수도 있습니다. activity같은 다른 component가 service를 시작시켜 다른 앱으로 전환되어도 백그라운드에 계속 실행하게 둘 수도 있고 자신에게 바인딩하여 상호작용하게 할 수도 있습니다. service는 사용자와 애플리케이션 상호작용 여부 상관없이 백그라운드에서 실행될 수 있는 구성 요소이기에 필요한 경우에만 사용해야 합니다.
=====
 service는 앱 관리 방법을 시스템에게 지시하는 두 가지 유형이 있는데 started service 와 bound service입니다. started service는 작업이 완료될 때까지 해당 service를 계속 실행하라고 시스템에 지시합니다. 사용자가 앱에서 나간 후에도 음악을 재생하거나 백그라운드에서 일부 데이터를 동기화하기 등의 경우입니다. 음악을 재생하는 것과 백그라운드에서 데이터를 동기화하는 것은 각각 두 가지 유형의 started service를 나타내는데, 이는 시스템이 service를 처리하는 방식이 다릅니다. 
  우선 음악 재생의 경우 foreground service입니다. 사용자가 바로 인식할 수 있는 작업이기에 앱은 사용자에게 이와 관련된 알림을 보내고 음악 재생을 포그라운드로 옮기라고 시스템에 지시합니다. service가 실행 중임을 사용자가 알 수 있도록 알림을 표시해야 하는데, 이 알림을 제거하거나  service가 중지되지 않는 한 해제할 수 없습니다. 시스템은 이 service의 프로세스가 계속 실행되도록 많은 노력을 기울여야 합니다. 이 service가 사라지면 사용자가 불만을 느낄 것이기 때문입니다. foreground service는 사용자가 앱과 상호작용하지 않을 때도 계속 실행됩니다. 대부분 경우 foreground service를 직접 사용하는 것보다 WorkManager API를 사용하기도 합니다.
 데이터 동기화 같이 정기적인 백그라운드에서 활동은 background service입니다. 사용자가 실행되고 있다고 직접 인식할 수 없는 작업이므로 시스템은 좀 더 자유롭게 프로세스를 관리할 수 있습니다. 어느 앱이 저장소를 압축하는 데 service를 사용했다면 이것은 대개 background service입니다. 이 service는 도중에 종료될 수도 있는데 사용자와 좀 더 직접적인 관련이 있는 작업에 RAM이 필요할 경우가 있기 때문입니다. 물론 나중에 service를 다시 시작할 수도 있습니다. 앱이 API 레벨 26 이상을 대상으로 한다면 앱이 포그라운드에 있지 않을 때 시스템에서 background service 실행에 대한 제한합니다. 백그라운드의 위치 정보를 접근하지 못하기 때문입니다. 이와 같은 경우에서는 WorkManager 사용해야 합니다.
 bound service는 다른 앱, component 심지어 service에서 bindService()를 호출하여 해당 service를 바인딩하고 싶을 때 실행됩니다.  bound service는 클라이언트-서버 인터페이스를 제공하여 component가 service와 상호작용하게 하고 응답을 보내고 결과를 받을 수 있으며 심지어 이와 같은 작업을 여러 프로세스에 걸쳐 프로세스 간 통신(IPC)으로 수행할 수도 있습니다. 이는 기본적으로 service가 다른 프로세스에 API를 제공하는 것입니다. 따라서 시스템은 프로세스 사이의 종속성을 알게 됩니다. 프로세스 A가 프로세스 B의 service에 바인딩되어 있을 경우, 시스템은 프로세스 A를 위해 프로세스 B 및 그 service를 실행해야 한다고 인식하게 됩니다. 또한 사용자가 프로세스 A에 관심을 기울이고 있다면 시스템에서 프로세스 B도 사용자가 관심을 기울이는 것처럼 취급해야 합니다. service는 좋은 의미로든 나쁜 의미로든 유연하기 때문에 각종 고차원적 시스템 개념에서 매우 유용한 기본 구성 요소로 사용되었습니다. 라이브 배경화면, 알림 리스너, 화면 보호기, 입력 메서드, 접근성 서비스 및 여러 가지 기타 핵심 시스템 기능들은 애플리케이션에서 실행하고 시스템에서 바인딩되는 service로 빌드됩니다. bound service는 또 다른 애플리케이션 component가 이에 바인딩되어 있는 경우에만 실행됩니다. 여러 개의 componet가 service에 한꺼번에 바인딩될 수 있지만 바인딩이 해제되면 해당 service는 소멸됩니다.
 그러므로 serivce는 총 foregound, background, bound 세 가지 유형으로 나뉘게 됩니다. 다른 유형으로 나뉘게 된다고 별도의 service인 것은 아닙니다. started service 와 bound service 양쪽 방식 함께 작동할 수 있습니다. 즉 무한히 실행되도록 시작해서  바인드 할 수 있습니다. 이는 단순히 콜백 메서드를 구현했는지 여부에 좌우되는 문제입니다. onStartCommand()는 component가 service를 시작하게 하고 onBind()는 바인드를 허용합니다. service가 시작되었든, 바인딩 되었든 아니면 양쪽 모두이든 모든 애플리케이션 component 또는 별도의 애플리케이션이에서 해당 service를 사용할 수 있으며 이는 어느 componet든  Intent로 activity를 사용할 수 있는 것과 같습니다. 그러나 매니페스트에서 serivce를 비공개로 선언하고 다른 애플리케이션으로부터의 액세스를 차단할 수도 있습니다. 
=====
activity 및 다른 component와 마찬가지로, service는 모두 애플리케이션의 매니페스트 파일에서 선언해야 합니다. <service> 요소를 <application> 요소의 하위로 추가하면 됩니다.
<manifest ... >
  ...
  <application ... >
      <service android:name=".ExampleService" />
      ...
  </application>
</manifest>
 
 <service> 요소에는 service를 시작하는 데 필요한 권한과 service를 실행해야 하는 프로세스 등의 특성을 정의할 수 있습니다. android:name이 유일한 필수 특성인데 service의 클래스 이름을 나타냅니다. 이 이름을 바꾸게 되면 service를 시작하거나 바인딩할 명시적 인텐트에 대한 종속성 때문에 코드가 깨질 위험이 있어 애플리케이션 출시 후에는 이 이름을 그대로 두어야 합니다.
 앱의 보안을 지키기 위해서는 service를 시작할 때에는 항상 명시적 인텐트만 사용하고 service에 대한 인텐트 필터는 선언하지 마세요. 암시적 인텐트를 사용하여 service를 시작하면 보안 위험을 초래합니다. 인텐트에 어느 service가 응답할 것인지 확신할 수 없고, 사용자는 어느 service가 시작되는지 볼 수 없기 때문입니다. Android 5.0, API 레벨 21부터 시스템은 개발자가 암시적 인텐트로 bindService()를 호출하면 예외를 발생시킵니다.
 android:exported 특성을 포함하고 이를 false로 설정하면 service를 본인의 앱에만 사용 가능하게 할 수 있습니다. 이렇게 하면 다른 앱이 여러분의 service를 시작하지 못하도록 효과적으로 방지하며, 이는 명시적 인텐트를 사용하는 경우에도 적용됩니다.
사용자는 기기에서 어떤 service가 실행되는지 볼 수 있습니다. 정체를 모르거나 신뢰할 수 없는 service를 보면 사용자가 service를 중단할 수 있습니다. 사용자에 의해 우발적으로 service가 중단되는 불상사를 막으려면 앱 매니페스트의 <service> 요소 android:description 특성을 추가해야 합니다. 여기에 service가 하는 일과 service의 장점을 설명하는 간략한 문장을 기재하면 됩니다.
=====
 Android 5.0(API 레벨 21) 이상을 대상으로 하는 앱의 경우 JobScheduler 클래스를 사용하여 작업을 예약하세요. JobScheduler에는 작업 일정을 최적으로 조정하여 전력 소모량을 줄이고 Doze API와 함께 작동하여 배터리를 절약해준다는 장점이 있습니다.
=====
serivce를 생성하려면 Service의 하위 클래스를 생성해야 합니다. 구현에서는 수명 주기의  콜백 메서드를 재정의해야 하며 필요시 service에 바인딩할 구성 요소에 대한 메커니즘을 제공해야 합니다. 다음은 재정의가 필요한 중요한 콜백 메서드입니다.

onStartCommand()
시스템이 startService()으로 이 메서드를 호출하는 건 activity같은 다른 component가 service를 시작하도록 요청하는 경우입니다. 이 메서드가 실행되면 service가 시작되고 백그라운드에서 무한히 실행될 수 있습니다. service 작업이 완료되었을 때 해당 service를 중단하는 건 개발자 역량이며, 이때 stopSelf() 또는 stopService()를 호출하면 됩니다. 바인딩만 제공하고자 하는 경우 해당 메서드를 구현하지 않아도 됩니다.
onBind()
시스템은 bindService()으로 이 메서드를 호출하는 건 다른 component가 해당 serivce에 바인딩되고자 하는 경우입니다. 이 메서드에는 클라이언트가 service와 통신을 송수신할 때 사용할 인터페이스를 제공해야 하며 IBinder를 반환합니다. 이 메서드는 항상 구현해야 하지만 바인딩을 허용하지 않으려면 null을 반환해야 합니다.
onCreate()
시스템은 service 가 처음 생성되었을 때, 즉 service가 onStartCommand() 또는 onBind()를 호출하기 전에 이 메서드를 호출하여 초기 설정 과정을 거칩니다. service가 이미 실행 중인 경우에는 호출되지 않습니다.
onDestroy()
 service를 더 이상 사용하지 않고 소멸시킬 때 호출됩니다. service는 스레드, 등록된 리스너 또는 수신기 등의 각종 리소스를 정리하기 위해 구현해야 합니다. 이는 service가 수신하는 마지막 호출입니다.

어느 component가 startService()를 호출하여 service를 시작하면 onStartCommand()에 대한 호출 발생하고 해당 service는 알아서 stopSelf()로 스스로 중단할 때까지 또는 다른 component가 stopService()를 호출하여 service를 중단시킬 때까지 실행 중인 상태로 유지됩니다. service를 생성하고 onStartCommand()를 호출하지 않고 bindService()를 호출한다면 service는 해당 component가 바인딩된 경우에만 실행됩니다. service가 모든 클라이언트로부터 바인딩이 해제되면 시스템이 이를 소멸시킵니다.
=====
service 시작
 activity 또는 다른 component에서 service를 시작하려면 Intent로 시작할 service를 지정하여 startService() 또는 startForegroundService()에 전달하면 됩니다. Android 시스템이 service의 onStartCommand() 메서드를 호출하고 여기에 시작할 service를 지정하는 Intent를 전달합니다. HelloService란 service를 activity가 시작하려면 startService()로 명시적 인텐트를 사용하면 됩니다.

Intent intent = new Intent(this, HelloService.class);
startService(intent);

 startService() 메서드가 즉시 반환되며 Android 시스템이 service의 onStartCommand() 메서드를 호출합니다. service가 아직 실행되지 않고 있다면 먼저 onCreate()를 호출한 다음, onStartCommand()를 호출해야 합니다.
 service가 바인딩을 제공하지 않는 경우, startService()와 함께 전달된 인텐트가 애플리케이션 component와 service 사이의 유일한 통신 수단입니다. 그러나 service가 결과를 돌려받기를 원하는 경우 service를 시작한 클라이언트가 PendingIngetBroadcast() 메소드를 사용하여 브로드캐스트으로 Intent를 만들고 이를 service를 시작한 Intent의 service에 전달할 수 있습니다. 그러면 service가 이 브로드캐스트으로 전달된 결과를 사용할 수 있게 됩니다.
 service를 시작하기 위한 요청을 여러 개 보내면 그에 대응하여 service의 onStartCommand()에 대해 여러 번 호출이 발생합니다. 반면 중단할 때는 stopSelf() 또는 stopService()으로 한 번만 중단을 요청하면 됩니다.
 만약 앱이 API 레벨 26 이상을 대상으로 한다면 앱이 포그라운드에 있지 않을 때 시스템에서 백그라운드 service 사용하거나 생성하는 것에 제한을 적용합니다. 앱이 포그라운드 service를 생성해야 하는 경우, 해당 앱은 startForegroundService()를 호출해야 합니다. 이 메서드는 백그라운드 service를 생성하지만, 메서드가 시스템에 신호를 보내 service가 자체적으로 포그라운드로 승격될 것이라고 알립니다. service가 생성되면 5초 이내에 startForeground() 메서드를 호출해야 합니다.
=====
service 중단
started service는 자신의 수명 주기를 직접 관리해야 합니다. 즉 시스템이 service를 중단하거나 소멸시키지 않는다는 뜻입니다. 다만 시스템 메모리를 회복해야 하고 service가 onStartCommand() 반환 후에도 계속 실행되는 경우는 예외입니다. service는 stopSelf()를 호출하여 스스로 중지하고 하고, 아니면 다른 component가 stopService()를 호출하여 이를 중지시킬 수 있습니다. 일단 stopSelf() 또는 stopService()로 중단 요청을 보내면 시스템은 가능한 한 빨리 service를 소멸시킵니다. service가 onStartCommand()에 대한 여러 요청을 동시에 처리하는 경우에는, 시작 요청의 처리를 끝낸 뒤에도 service를 중단하면 안 됩니다. 그 이후 새 시작 요청을 받았을 수 있기 때문입니다. 첫 요청이 끝날 때 중단하면 두 번째 요청이 종료될 수 있습니다. 이 문제를 피하려면, stopSelf(int)를 사용하여 service 중단 요청이 항상 가장 최근 시작 요청을 기준으로 하도록 해야 합니다. 다시 말해, stopSelf(int)를 호출할 경우 onStartCommand()에 전달된 startId를 전달하며, 여기에 중단 요청이 대응됩니다. 그런 다음 stopSelf(int)를 호출할 수 있게 되기 전에 service가 새 시작 요청을 수신하면 ID가 일치하지 않으므로 servcie는 중단되지 않습니다.
 단, 시스템 리소스 낭비를 피하고 배터리 전력 소모를 줄이기 위해서는 service의 작업이 완료되면 애플리케이션에서 service를 중단해야 합니다. 필요한 경우 stopService()를 호출하여 다른 component가 service를 중단할 수 있습니다. service에 대해 바인딩을 활성화하더라도, service가 onStartCommand()에 대한 호출을 한 번이라도 받았으면 항상 직접 service를 중단해야 합니다.
=====
Android 시스템이 service를 강제 중단하는 것은 메모리가 부족하여 사용자 포커스를 가진 activity를 위해 시스템 리소스를 회복해야만 하는 경우로만 국한됩니다. service가 사용자 포커스를 가진 activity에 바인딩 되었으면 종료될 가능성이 적고 service가 포그라운드에서 실행되도록 선언된 경우에는 종료될 가능성이 희박합니다. service가 시작되어 장시간 실행 중이라면 시스템은 시간이 지나면서 백그라운드 작업 목록에서 이 service가 차지하는 중요도를 낮추어 service가 종료될 가능성이 높아집니다. service가 시작되었다면 시스템에 의한 재시작을 정상적으로 처리하도록 설계해야 합니다. 시스템이 service를 중단하는 경우, 리소스를 다시 사용할 수 있게 되면 가능한 한 빨리 service가 다시 시작됩니다. 다만 개발자가 onStartCommand()에서 반환하는 값에 따라 달라집니다. 
=====
사용자가 애플리케이션과 상호작용할 때 기본 스레드 밖에서 작업을 수행해야 하는 경우, 새 스레드를 생성해야 합니다. 예를 들어 activity가 실행되는 중에만 음악을 재생하고자 하는 경우, onCreate() 안에 스레드를 생성하여 onStart()에서 실행한 다음 onStop()에서 중단하면 됩니다. 또한 기존의 Thread 클래스 대신 AsyncTask 또는 HandlerThread를 사용할 수도 있습니다.
service는 기본적으로 자신의 호스팅 프로세스의 기본 스레드에서 실행됩니다. service는 자신의 스레드를 직접 생성하지 않으며, 특별히 지정하지 않는 한 별도의 프로세스에서 실행되지도 않습니다. service가  MP3 재생 또는 네트워킹 같이 CPU 집약적인 작업을 수행할 예정이거나 차단 작업을 수행할 예정인 경우 성능을 위해 service 내에 새 스레드를 생성해야 합니다. 별도의 스레드를 사용하면 '애플리케이션이 응답하지 않습니다(ANR)' 오류가 일어날 위험을 줄일 수 있으며, 애플리케이션의 기본 스레드는 액티비티와 사용자 상호작용 전용으로 유지될 수 있습니다.
=====
사용자에게 알림 전송
 service가 실행되고 있을 때 사용자에게 토스트 알림 또는 상태 표시줄 알림 등을 사용해 이벤트를 알릴 수 있습니다. 토스트 알림은 현재 창의 표면에 잠깐 나타났다가 사라지는 메시지입니다. 상태 표시줄 알림은 상태 표시줄에 메시지가 담긴 아이콘을 제공하여 사용자가 이를 선택하면 activity 시작 같은 활동을 할 수 있게 합니다. 보통 파일 다운로드 완료 같은 일종의 백그라운드 작업이 완료되었고 이제 사용자가 그에 대해 조치를 취할 수 있는 경우에는 상태 표시줄 알림을 사용하는 것이 가장 좋습니다. 사용자가 확장된 뷰의 알림을 선택하면 해당 알림은 다운로드한 파일 보기 같은 activity를 시작할 수 있습니다.
=====
서비스 수명 주기 관리
service의 수명 주기는 activity의 수명 주기보다 훨씬 간단합니다. 하지만 service를 생성하고 소멸하는 방법에 특히 주의를 기울여야 한다는 면에서 중요도는 더 높습니다. servcie는 사용자가 모르는 채로 백그라운드에서 실행될 수 있기 때문입니다.
생성부터 소멸되는 시점까지의 service 수명 주기는 두 가지의 다른 경로를 가집니다.
started service 
다른 component가 startService()를 호출하면 servcie가 생성됩니다. 그러면 service가 무기한으로 실행될 수 있으며, stopSelf()를 호출해서 자체적으로 중단해야 합니다. 다른 component가 stopService()를 호출하면 service를 중단시킬 수 있습니다. service가 중단되면 시스템이 소멸시킵니다.
bound service
다른 component, 클라이언트가 bindService()를 호출하면 service가 생성됩니다. 그러면 클라이언트가 IBinder 인터페이스를 통해 service와 통신을 주고받을 수 있습니다. 클라이언트가 연결을 종료하려면 unbindService()를 호출하면 됩니다. 여러 클라이언트가 같은 servcie에 바인딩될 수 있으며, 모든 클라이언트가 바인딩을 해제하면 시스템이 해당 servcie를 소멸시킵니다. servcie가 스스로 중단하지 않아도 됩니다.
 두 가지 경로로 나뉘지만 완전히 별개는 아닙니다. 이미 startService()로 시작된 service에 바인딩할 수도 있습니다. 예를 들어 재생할 음악을 식별하는 Intent를 포함해 startService()를 호출하면 백그라운드 음악 서비스를 시작할 수 있습니다. 나중에 사용자가 플레이어에 좀 더 많은 통제력을 발휘하려고 하거나 현재 노래에 대한 정보를 얻고자 할 때, activity가 bindService()를 호출하여 service에 바인딩할 수 있습니다. 이와 같은 경우에는 모든 클라이언트가 바인딩을 해제할 때까지 stopService() 또는 stopSelf()가 service를 중단하지 않습니다.
=====
수명 주기 콜백 구현
activity와 마찬가지로 service에도 수명 주기 콜백 메서드가 있어, 이를 구현하면 service의 상태 변경 내용을 모니터할 수 있고 적절한 시기에 작업을 수행할 수 있습니다. 다음의  service는 각 수명 주기 메서드를 보여줍니다.

public class ExampleService extends Service {
    int startMode;       // service가 종료되면 어떻게 행동할지 나타냄
    IBinder binder;      // 클라이언트와 바인드할 인터페이스
    boolean allowRebind; // onRebind를 사용 여부 나타냄

    @Override
    public void onCreate() {
        // service생성하는 곳
    }
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        //service()에서 mStartMode가 리턴되어 service가 시작하는곳
    }
    @Override
    public IBinder onBind(Intent intent) {
        // bindService()에서 mBinder가 리턴되어 클라이언트가 service와 바인딩되는 곳
    }
    @Override
    public boolean onUnbind(Intent intent) {
        unbindService()에서 mAllowRebind가 리턴되어 모든 클라이언트가 해제됨
    }
    @Override
    public void onRebind(Intent intent) {
        //onUnbind()가 이미 호출된 후 클라이언트가 
	//bindService()로 service와 바인딩되는 곳
    }
    @Override
    public void onDestroy() {
        // service가 더 이상 사용되지 않아 소멸되는 곳
    }
}

activity 수명 주기 콜백 메서드와는 service는 슈퍼클래스 구현을 호출하지 않아도 됩니다.

 그림 2는 service에 대한 일반적인 콜백 메서드를 나타낸 것입니다. 이 그림에서는 startService()로 생성된 service와 bindService()로 생성된 service를 구분하고 있지만, 어떤 식으로 시작되었든 모든 service는 클라이언트와 바인딩될 수 있습니다. 클라이언트가 startService()호출하여 onStartCommand()로 처음 시작된 service라고 해도 클라이언트가 bindService()를 호출하면 여전히 onBind()에 대한 호출을 받을 수 있습니다. 
 
메서드를 구현함으로써, service 수명 주기의 두 가지 중첩된 루프를 모니터링할 수 있습니다.
-service의 전체 수명은 onCreate()가 호출된 시점부터 onDestroy() 반환 시점까지입니다. activity와 마찬가지로 service는 자신의 초기 설정을 onCreate()에서 수행하며, 남은 리소스를 모두 onDestroy()에서 릴리스합니다. 예를 들어 음악 재생 service는 스레드를 생성하고, 이 스레드의 onCreate()에서 음악이 재생됩니다. 그런 다음, onDestroy()에서 스레드를 중단할 수 있습니다. onCreate() 및 onDestroy() 메서드는 모든 service에 호출됩니다. 이는 service가 startService()로 생성되었든 bindService()로 생성되었든 상관없이 적용됩니다.
-service의 활성 수명은 onStartCommand() 또는 onBind()에 대한 호출에서부터 시작됩니다. 각 메서드는 Intent를 받아서 startService() 또는 bindService()에 전달합니다. service가 시작되면 수명 주기 전체가 종료되는 것과 동시에 활성 수명 주기도 종료됩니다. service는 onStartCommand()가 반환된 뒤에도 여전히 활성 상태입니다. service가 바인딩된 경우, onUnbind()가 반환되면 활성 수명 주기가 종료됩니다. 시작된 service를 중단하려면 stopSelf() 또는 stopService()를 호출하면 되지만, service에 대한 개별 콜백은 없습니다. 즉 onStop() 콜백이 없습니다. 그러므로 service가 클라이언트에 바인딩되어 있지 않은 한, 시스템은 service가 중단되면 이를 소멸시킵니다. 수신되는 콜백은 onDestroy()가 유일합니다.
=====
started service는 다른 component가 startService()를 호출하여 시작하고, 그 결과로 service의 onStartCommand() 메서드가 호출됩니다. service가 시작되면 이를 시작한 component와 독립적인 수명 주기를 가지게 됩니다. service는 백그라운드에서 무한히 실행될 수 있으며 이는 해당 service를 시작한 component가 소멸되었더라도 영향을 받지 않습니다. 따라서 service는 작업이 완료되면 stopSelf()를 호출하여 스스로 중단하거나 다른 component가 stopService()를 호출하여 중단시킵니다.

애플리케이션 component가 service를 시작하려면 startService()를 호출하고 Intent를 전달합니다. 이때 이 인텐트에서 시작할 service를 지정하고 필요한 모든 데이터를 보냅니다. service는 onStartCommand() 메서드에서 이 Intent를 받습니다. 예를 들어 어느 activity가 온라인 데이터베이스에서 어떤 데이터를 저장해야 한다고 가정해보겠습니다. activity가 필요한 service를 시작하고, 인텐트를 startService()에 전달하여 service에 저장할 데이터를 전달할 수 있습니다. service는 이 인텐트를 onStartCommand()에서 수신하고, 인터넷에 연결한 다음, 데이터베이스 트랜잭션을 수행합니다. 트랜잭션이 완료되면 service가 스스로 중단되어 소멸됩니다.

started service 를 생성하기 위해 확장할 수 있는 클래스가 두 개 있었습니다.
Service
 모든 service의 기본 클래스입니다. 이 클래스를 확장할 때는 service가 모든 작업을 완료할 수 있는 새 스레드를 생성하는 것이 중요합니다. service는 기본적으로 애플리케이션의 기본 스레드를 사용하기 때문에 애플리케이션이 실행 중인 activity의 성능을 저하를 막기 위해서입니다.
IntentService
 Service의 하위 클래스로, 작업자 스레드를 사용하여 모든 시작 요청을 처리하되 한 번에 하나씩 처리합니다. service가 여러 개의 요청을 동시에 처리하지 않아도 되는 경우에 적합합니다. onHandleIntent()를 구현하는데 이는 각 시작 요청에 대해 인텐트를 수신해서 백그라운드 작업을 완료하도록 합니다.

IntentService 클래스 확장
 started service는  여러 개의 요청을 동시에 처리하지 않아도 됩니다. 물론 이는 사실 위험한 다중 스레딩 시나리오일 수 있습니다. 사실 이 클래스는 Android 8 이후로는 사용할 수 없기 때문에 새로운 앱에서는 사용하지 않는 것이 좋습니다. 게다가 안드로이드 11부터는 더 이상 사용하지 않습니다.  IntentService의 대체품으로 최신 Android 버전과 호환되는  JobIntentService를 사용할 수 있습니다. 

IntentService 클래스는 다음과 같이 작동합니다.
-애플리케이션의 기본 스레드와는 별도로, onStartCommand()에 전달된 모든 인텐트를 실    행하는 기본 작업자 스레드를 생성합니다.
-인텐트를 한 번에 하나씩 onHandleIntent() 구현에 전달하는 작업 큐를 생성하므로, 다중    스레딩에 대해 염려할 필요가 전혀 없습니다.
-시작 요청이 모두 처리된 후 service를 중단하므로 개발자가 stopSelf()를 호출할 필요가     전혀 없습니다.
-onBind()의 기본 구현을 제공하여 null을 반환하도록 합니다.
-onStartCommand()의 기본 구현을 제공하여, 인텐트를 작업 큐로 보내고 그다음은          onHandleIntent() 구현으로 보냅니다.

클라이언트가 제공한 작업을 완료하기 위해 onHandleIntent()를 구현합니다. 
다음은 IntentService 구현의 예입니다.

public class HelloIntentService extends IntentService {

  /*생성자를 구현해야하며 super(작업생성자이름)을 꼭 생성해야합니다.*/
  public HelloIntentService() {
      super("HelloIntentService");
  }
  /**
  The IntentServic는 started the service 인텐트로 기본 작업자 스레드에서 이 메소드를 부릅니다. 이 메서드가 리턴하면  IntentService가 service를 적당한 시기에 멈춥니다
   */
  @Override
  protected void onHandleIntent(Intent intent) {
      // 보통 여기서 파일 다운같은 작업을 합니다.
  }
}
단지 생성자 하나와 onHandleIntent()만 구현하면 됩니다. 다른 콜백 메서드도 재정의하려면(예: onCreate(), onStartCommand() 또는 onDestroy()) 슈퍼 구현을 꼭 호출해야 합니다. 그래야만 IntentService가 작업자 스레드의 수명을 적절하게 처리할 수 있습니다. 예를 들어 onStartCommand()는 반드시 기본 구현을 반환해야 합니다. 그래야 인텐트가 onHandleIntent()로 전달됩니다. onHandleIntent() 외에 슈퍼 클래스를 호출하지 않아도 되는 메서드는 onBind() 뿐입니다. service가 바인드를 허용하는 경우에만 구현해야 합니다.

다음 내용에서는 기본 Service 클래스를 확장할 때 같은 종류의 서비스를 구현하는 방법과 자체 사용자 지정 service를 구현하는 방법을 배우게 됩니다. 이때에는 코드가 더 많이 필요하지만, 동시 시작 요청을 처리해야 하는 경우에 적합할 수 있습니다. 다만 대부분의 사용 사례에서 WorkManager를 사용하는 것을 고려해야 합니다. 

작업 큐를 통해 시작 요청을 처리하는 대신 service가 멀티스레딩을 수행해야 하는 경우 Service 클래스를 확장하여 각 인텐트를 처리하게 할 수 있습니다.

각 시작 요청에 대해 작업자 스레드를 사용하여 작업을 수행하고 한 번에 요청을 하나씩만 처리하는 코드 예시입니다.

public class HelloService extends Service {
  private Looper serviceLooper;
  private ServiceHandler serviceHandler;

  //스레드에서 메시지를 받는 핸들러입니다
  private final class ServiceHandler extends Handler {
      public ServiceHandler(Looper looper) {
          super(looper);
      }
      @Override
      public void handleMessage(Message msg) {
       // 보통 여기서 파일 다운같은 작업을 합니다.
       //다른 작업을 처리하는 동안 서비스를 중지하지 않도록 
       //시작 Id를 사용하여 서비스를 중지합니다
          stopSelf(msg.arg1);
      }
  }

  @Override
  public void onCreate() {
  //service를 실행하는 스레드를 시작합니다. 
 //service는 일반적으로 프로세스의 기본 스레드에서 실행되므로 방해되지 않게 별도의 스   //레드를 만듭니다.
 //또한 CPU 집약적 작업이 UI를 중단시키지 않도록 백그라운드 우선순위를 설정합니다.
    HandlerThread thread = new HandlerThread("ServiceStartArguments",
            Process.THREAD_PRIORITY_BACKGROUND);
    thread.start();

    // HandlerThread의 Looper를 얻어 핸들러에 사용합니다
    serviceLooper = thread.getLooper();
    serviceHandler = new ServiceHandler(serviceLooper);
  }

  @Override
  public int onStartCommand(Intent intent, int flags, int startId) {
  // 각 시작 요청에 대해 작업을 시작하라는 메시지와 시작 ID를 전달하면 
  //작업 완료 시 어느 요청이 중지하고 있는지 알 수 있습니다
      Message msg = serviceHandler.obtainMessage();
      msg.arg1 = startId;
      serviceHandler.sendMessage(msg);

      //중단되면	이곳으로 리턴되어 재시작합니다
      return START_STICKY;
  }

  @Override
  public IBinder onBind(Intent intent) {
     //바인딩을 하지 않았기에 null을 반환시킵니다.
      return null;
  }

  @Override
  public void onDestroy() {
  }
}

 IntentService 보다 코드량이 많지만 각 호출을 onStartCommand()로 직접 처리할 수 있기 때문에 여러 개의 요청을 동시에 수행할 수 있습니다. 위의 코드는 그런 작업을 하지 않지만 원하는 경우 각 요청에 대해 새 스레드를 하나씩 생성한 다음 이전 요청이 끝날 때까지 기다리는 대신 곧바로 실행하면 됩니다.
 onStartCommand() 메서드는 반드시 정수를 반환해야 합니다. 이 정수는 시스템이 service를 종료할 경우 service를 유지하는 방법을 설명하는 값입니다. onStartCommand()로부터의 반환 값은 반드시 다음 상수 중 하나여야 합니다.
START_NOT_STICKY
 시스템이 service를 onStartCommand() 반환 후에 중단시키면 서비스를 재생성하지 않습니다. 다만 전달할 보류 인텐트가 있는 경우는 예외입니다. 이는 service가 불필요하게 실행되는 일을 피할 수 있는 가장 유용한 상수이며, 애플리케이션이 완료되지 않은 모든 작업을 단순히 다시 시작할 수 있을 때 유용합니다.

START_STICKY
시스템이 onStartCommand() 반환 후에 service를 중단하면 service를 다시 생성하고 onStartCommand()를 호출하되, 마지막 인텐트는 전달하지 않습니다. 그 대신 시스템이 null 인텐트로 onStartCommand()를 호출합니다. 단 service를 시작하기 위한 보류 인텐트가 있는 경우는 예외라서 보류 인텐트가 전달됩니다. 명령을 실행하지는 않지만 무한히 실행 중이며 작업을 기다리고 있는 미디어 플레이어 같은 service에 적합합니다.

START_REDELIVER_INTENT
시스템이 onStartCommand() 반환 후에 service를 중단하는 경우, service를 다시 생성하고 이 service에 전달된 마지막 인텐트로 onStartCommand()를 호출합니다. 모든 보류 인텐트가 차례로 전달됩니다. 파일 다운로드같이 즉시 재개되어야 하는 작업을 능동적으로 수행 중인 service 등에 적합합니다.
=====
포그라운드에서 service 실행
 foreground service는 사용자가 인식하고 있기에 메모리가 부족하더라도 시스템이 중단시킬 후보가 될 수 없습니다. foreground service는 상태 표시줄에 알림을 제공하기 때문에 service를 중단하거나 포그라운드에서 제거하지 않은 이상 알림을 해제할 수 없습니다. 그렇기에 foreground service를 너무 많이 사용하지 않도록 해야 합니다. 사용자의 눈에 잘 띄는 작업을 수행해야 하는 경우에만 사용해야 합니다. 사용자가 앱이 직접 상호작용을 주고받지 않을 때도 해당됩니다. 때문에 우선순위가 PRIORITY_LOW 이상이어야 하며, 이렇게 해야 사용자가 앱이 하는 일을 확실히 인식할 수 있습니다. 작업의 중요도가 낮아서 최소한의 우선순위 알림을 사용하고자 하는 경우에는 service를 사용하는 것보다 그 대신 예약된 작업을 사용하는 것이 낫습니다.
 service를 실행하는 앱은 모두 시스템에 추가적인 부하를 가하여 시스템 리소스를 소모합니다. 앱이 낮은 우선순위 알림을 사용해 service를 숨기려 하면 사용자가 활발히 상호작용을 주고받는 앱의 성능을 저해할 수 있습니다. 때문에 앱이 최소한의 우선순위 알림으로 service를 실행하려 하면 시스템이 앱의 동작에 대해 알림 드로어의 아래쪽 섹션에 호출하여 알립니다. 예를 들어 service에서 음악을 재생하는 음악 플레이어는 포그라운드에서 실행되도록 설정해야 합니다. 사용자가 작동을 분명히 인식하고 있기 때문입니다. 상태 표시줄에 있는 알림은 현재 노래를 나타내고, 사용자는 이 알림을 통해 음악 플레이어와 상호작용할 activity를 시작할 수 있습니다. 마찬가지로 사용자의 달리기 기록을 추적하는 앱은 사용자의 위치를 추적하는 데 foreground service가 필요할 수 있습니다. 
 Android 9(API 레벨 28) 이상을 대상으로 하고 foreground service를 사용하는 앱은 FOREGROUND_SERVICE 권한을 요청해야 합니다. 이 권한은 일반 권한이므로 시스템은 요청 앱에 자동으로 권한을 부여합니다. API 레벨 28을 대상으로 하는 앱이 FOREGROUND_SERVICE 권한 허가 없이 foreground service를 생성하려고 시도하면, 시스템이 SecurityException을 발생시킵니다.
<manifest xmlns:android="http://schemas.android.com/apk/res/android" ...>

    <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>

    <application ...>
        ...
    </application>
</manifest>

Context context = getApplicationContext();
Intent intent = new Intent(...); // service의 인텐트를 빌드합니다
context.startForegroundService(intent);
보통 onStartCommand()의 service 내부에서 service를 포그라운드에서 실행되도록 요청할 수 있습니다. 그러려면 startForeground()를 호출하면 됩니다. 이 메서드는 두 개의 매개변수를 취합니다. 그중 하나는 해당 알림을 고유하게 식별하는 정수이고 다른 하나는 상태 표시줄에 해당되는 Notification 객체입니다. 알림의 우선순위는 PRIORITY_LOW 이상이어야 합니다. 앱이 낮은 우선 순위의 알림을 사용하려고 하면 시스템이 알림 드로어에 메시지를 추가하여 사용자에게 앱의 foreground service 사용을 알립니다. 다음은 이에 대한 예입니다.
// 알람에 바로 답장하기 작업을 추가하고 싶으면 
//PendingIntent.FLAG_MUTABLE를 사용하면 됩니다.
Intent notificationIntent = new Intent(this, ExampleActivity.class);
PendingIntent pendingIntent =
        PendingIntent.getActivity(this, 0, notificationIntent,
                PendingIntent.FLAG_IMMUTABLE);

Notification notification =
          new Notification.Builder(this, CHANNEL_DEFAULT_IMPORTANCE)
    .setContentTitle(getText(R.string.notification_title))
    .setContentText(getText(R.string.notification_message))
    .setSmallIcon(R.drawable.icon)
    .setContentIntent(pendingIntent)
    .setTicker(getText(R.string.ticker_text))
    .build();

// 알람 ID는 0이 될 수 없습니다.
startForeground(ONGOING_NOTIFICATION_ID, notification);

service를 포그라운드에서 제거하려면 stopForeground()를 호출하면 됩니다. 이 메서드는 부울 값을 취하며, 상태 표시줄 알림도 제거할지 여부를 나타냅니다. 이 메서드는 service를 중단하지 않지만 service가 포그라운드에서 실행 중일 때 중단되면 알림도 마찬가지로 제거됩니다.
=====
bound service생성
 bound service는 bindService()를 호출하여 연결을 오래 유지하기위해 애플리케이션 component를 service에 바인딩하는 겁니다. 일반적으로는 startService()를 호출하더라도 component가 service를 시작하도록 허용하지 않습니다.
 activity와 애플리케이션의 component에서 service와 상호작용하기를 원하는 경우bound service를 생성해야 합니다. 아니면 애플리케이션의 기능 몇 가지를 프로세스 간 통신(IPC)을 통해 다른 애플리케이션에 노출하고자 하는 경우에도 사용됩니다.
 bound service를 생성하려면 onBind() 콜백 메서드를 구현하여 service의 통신을 위한 인터페이스를 정의하는 IBinder를 반환하도록 해야 합니다. 그러면 다른 애플리케이션 component가 bindService()를 호출하여 해당 인터페이스를 탐색하고, service에 있는 메서드를 호출할 수 있습니다. service는 자신에게 바인딩된 애플리케이션 component에 도움이 되기 위해서만 존재하기 때문에, service에 바인딩된 component가 없으면 시스템이 이를 소멸시킵니다. bound service는 service를 onStartCommand()를 통해 시작했을 때와 같은 방식으로 중단하지 않아도 됩니다.
 여러 클라이언트가 service에 한꺼번에 바인딩될 수 있습니다. 클라이언트가 service와의 상호작용이 끝나면 unbindService()를 호출하여 바인딩을 해제합니다. service에 바인딩된 클라이언트가 하나도 없으면 시스템이 해당 servcie를 소멸시킵니다.
 bound service를 구현하는 데에는 여러 가지 방법이 있지만 started service다 훨씬 복잡합니다.
