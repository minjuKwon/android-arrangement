1. Service란
1)service? 
service는 여러 가지 이유로 백그라운드에서 앱을 계속 실행시키는 다목적 진입점입니다. 이는 UI없이 백그라운드에서 실행되는 구성 요소로, 오랫동안 실행되는 작업을 수행하거나 원격 프로세스를 위한 작업을 수행합니다. 예를 들어 service는 사용자가 다른 앱에 있는 동안에도 백그라운드에서 음악 재생과 파일 I/O 수행, 그리고 사용자와 activity간의 상호작용을 방해하지 않고 네트워크를 통해 데이터를 가져올 수도 있습니다. activity 같은 다른 component가 service를 시작시켜 다른 앱으로 전환되어도 사라지지 않은 채 백그라운드에서 계속 실행할 수 있고, 자신에게 바인딩하여 상호작용하게 할 수도 있습니다. service는 사용자와 애플리케이션 상호작용 여부 상관없이 백그라운드에서 실행될 수 있는 구성 요소이기에 필요한 경우에만 사용해야 합니다.

+Service vs Thread
_|Service|Thread|
의미|백그라운드에서 앱을 실행시키는 구성요소|백그라운드에서 프로세스 내 실행되는 흐름의 단위
역할|오랫동안 실행되는 작업 수행|동시에 여러 작업 실행
실행 |메인 스레드|자체 스레드
생명주기|액티비티 생명주기에 실행. 액티비티 파괴되면 종료 및 중지| 액티비티 생명주기와 독립적인 자체 생명주기를 가짐. 액티비티 파괴되도 계속 실행
메모리 부족 시 | 재시작 가능| 재시작 불가능

-출처 : https://onlyfor-me-blog.tistory.com/393      


2)service와 스레드
(service 스레드 설명 그림)
사용자가 애플리케이션과 상호작용할 때 기본 스레드 밖에서 작업을 수행해야 하는 경우, 새 스레드를 생성해야 합니다. 예를 들어 activity가 실행되는 중에만 음악을 재생하고자 하는 경우, onCreate() 안에 스레드를 생성하여 onStart()에서 실행한 다음 onStop()에서 중단합니다. service는 기본적으로 자신의 호스팅 프로세스의 기본 스레드에서 실행됩니다. service는 자신의 스레드를 직접 생성하지 않으며, 특별히 지정하지 않는 한 별도의 프로세스에서 실행되지도 않습니다. service가  MP3 재생 또는 네트워킹 같이 CPU 집약적인 작업을 수행할 예정이거나 차단 작업을 수행할 예정인 경우 성능을 위해 service 내에 새 스레드를 생성해야 합니다. 별도의 스레드를 사용하면 '애플리케이션이 응답하지 않습니다(ANR)' 오류가 일어날 위험을 줄일 수 있으며, 애플리케이션의 기본 스레드는 activity와 사용자의 상호작용 전용으로 유지되어야 합니다.


3)사용자에게 알림 전송
(알림 사진)
service가 실행되고 있을 때 사용자에게 토스트 알림 또는 상태 표시줄 알림 등을 사용해 이벤트를 알릴 수 있습니다. 토스트 알림은 현재 창의 표면에 잠깐 나타났다가 사라지는 메시지입니다. 상태 표시줄 알림은 상태 표시줄에 메시지가 포함된 아이콘을 제공하여 사용자가 이를 선택하면 activity 시작 같은 활동을 할 수 있게 합니다. 보통 파일 다운로드 완료 같은 일종의 백그라운드 작업이 완료되었고 이제 사용자가 그에 대한 조치를 취할 수 있는 경우에는 상태 표시줄 알림을 사용하는 것이 가장 좋습니다. 사용자가 확장된 뷰의 알림을 선택하면 해당 알림은 다운로드한 파일 보기 같은 activity를 시작할 수 있습니다.


4)service 유형
 service에는 시스템에게 앱 관리 방법을 지시하는 두 가지 유형이 있는데 started service 와 bound service입니다. started service는 작업이 완료될 때까지 해당 service를 계속 실행하라고 시스템에 지시합니다. 사용자가 앱에서 나간 후에도 음악을 재생하기와 백그라운드에서 일부 데이터를 동기화하기가 있습니다. 음악 재생과 백그라운드에서 데이터 동기화하기는 started service에서 다시 두가지 유형으로 나뉘는데, 이는 시스템이 service를 처리하는 방식이 다릅니다. 

Started service-foreground service
 우선 음악 재생의 경우 foreground service입니다. 사용자가 바로 인식할 수 있는 작업이기 때문에, 앱은 사용자에게 실행 중이라는 알림을 보내면서 시스템에는 포그라운드로 옮기라는 지시를 합니다. 이때 알림 표시는 필수적입니다. service를 포그라운드에서 제거하거나 중지하지 않는 한 알림을 계속 표시해야합니다. 시스템은 이러한 종류의 service 프로세스가 계속 실행되는 것을 우선시 해야합니다. 이 service가 사라지면 사용자는 불만을 가지게 되기 때문입니다. 그렇기에 foreground service는 사용자가 앱과 상호작용하지 않을 때도 계속 실행됩니다. 필요시 foreground service를 직접 사용하는 것보다 WorkManager API를 사용하기도 합니다.

Started service-background service
 데이터 동기화 같이 정기적인 백그라운드에서의 활동은 background service입니다. 사용자가 이 작업이 실행되고 있다고 직접 인식할 수 없기 때문에 시스템은 좀 더 자유롭게 프로세스를 관리할 수 있습니다. 어느 앱이 압축 저장하는데 service를 사용했다면 이것은 대개 background service입니다. 이 service는 도중에 종료될 수도 있는데 사용자와 좀 더 직접적인 관련이 있는 작업에 RAM이 필요할 경우가 있기 때문입니다. 물론 나중에 service를 다시 시작할 수도 있습니다. 앱이 API 레벨 26 이상을 대상으로 한다면, 앱이 포그라운드에 있지 않을 때 시스템에서  background service 실행를 제한합니다. 백그라운드에서는 위치 정보에 엑세스하지 못하기 때문입니다. 이와 같은 경우에서는 WorkManager 사용해야 합니다.

Bound service
 bound service는 다른 앱이나 component 심지어 다른 service에서 bindService()를 호출하여 해당 service를 바인딩하고 싶을 때 실행됩니다. bound service는 클라이언트-서버 인터페이스를 제공하여, component가 service와 상호작용하게 하고 응답을 보내 결과를 받을 수 있으며 여러 프로세스에 걸쳐 프로세스 간 통신(IPC)으로 수행할 수도 있습니다. 이는 service가 다른 프로세스에 API를 제공하고 시스템은 이러한 프로세스 사이의 종속성이 있음을 알게 됩니다. 

(프로세스 바인딩 예 그림)
예를 들어 프로세스 A가 프로세스 B의 service에 바인딩되어 있을 경우, 시스템은 프로세스 A를 위해 프로세스 B 및 그 service를 실행해야 한다고 인식하게 됩니다. 또한 사용자가 프로세스 A에 관심을 기울이고 있다면 시스템에서 프로세스 B도 사용자가 관심을 기울이는 것처럼 취급해야 합니다. bound service는 다른 애플리케이션 component에 바인딩되어 있는 경우에만 실행됩니다. 여러 componet가 service에 한꺼번에 바인딩될 수 있지만 바인딩이 해제되면 해당 service는 소멸됩니다. service는 유연하기 때문에 각종 고차원적 시스템 개념에서 매우 유용한 기본 구성 요소로 사용되었습니다. 라이브 배경화면, 알림 리스너, 화면 보호기, 입력 메서드, 접근성 서비스 및 여러 가지 기타 핵심 시스템 기능들은 애플리케이션에서 구현되고 애플리케이션이 실행될 때 시스템에서 바인딩되는 service로 빌드됩니다. 

 그러므로 serivce는 총 foregound, background, bound 세 가지 유형으로 나뉘게 됩니다. 다른 유형으로 나뉘게 된다고 별도의 service인 것은 아닙니다. started service 와 bound service를 동시에 동작할 수 있습니다. 즉 무한히 실행되도록 시작하면서 바인딩 할 수 있습니다. 이는 단순히 콜백 메서드 구현 여부에 좌우되는 문제입니다. onStartCommand()는 component가 service를 시작하게 하고 onBind()는 바인드를 허용합니다. service가 시작되었든 바인딩 되었든 아니면 모두이든, component 혹은 별도의 애플리케이션에서도 해당 service를 사용할 수 있으며 이는 어느 component든 Intent로 activity를 시작시킬 수 있는 것과 같습니다. 그러나 매니페스트에서 serivce를 비공개로 선언하여 다른 애플리케이션으로부터의 액세스를 차단할 수도 있습니다. 


5)manifest 선언
activity 및 다른 component와 마찬가지로, service는 모두 애플리케이션의 매니페스트 파일에서 선언해야 합니다. <service> 요소를 <application> 요소의 하위로 추가하면 됩니다.

<manifest ... >
  ...
  <application ... >
      <service android:name=".ExampleService" />
      ...
  </application>
</manifest>
 
 <service> 요소에는 service를 시작하는 데 필요한 권한과 service를 실행해야 하는 프로세스 등의 특성을 정의할 수 있습니다. android:name이 유일 필수 특성인데 service의 클래스 이름을 나타냅니다. 이 이름을 바꾸게 되면, service를 시작하거나 바인딩할 명시적 인텐트에 대한 종속성 때문에 코드가 깨질 위험이 있어 애플리케이션 출시 후에는 이 이름을 그대로 두어야 합니다. android:exported 특성을 포함하고 이를 false로 설정하면 해당 service를 본인의 앱에만 사용 가능하게 할 수 있습니다. 이렇게 하면 다른 앱이 여러분의 service를 시작하지 못하도록 효과적으로 방지하며, 이는 명시적 인텐트를 사용하는 경우에도 적용됩니다.

 앱의 보안을 지키기 위해서는 service를 시작할 때에는 항상 명시적 인텐트만 사용하고 service에 대한 인텐트 필터는 선언하지 말아야 합니다. 암시적 인텐트를 사용하여 service를 시작하면 보안이 위험해집니다. 인텐트에 어느 service가 응답할 것인지 확신할 수 없고, 사용자는 어느 service가 시작되는지 볼 수 없기 때문입니다. Android 5.0, API 레벨 21부터 시스템은 개발자가 암시적 인텐트로 bindService()를 호출하면 예외를 발생시킵니다.

사용자는 기기에서 어떤 service가 실행되는지 볼 수 있습니다. 정체를 모르거나 신뢰할 수 없는 service를 보면 사용자가 service를 중단할 수 있습니다. 사용자에 의해 우발적으로 service가 중단되는 불상사를 막으려면 앱 매니페스트의 <service> 요소에 android:description 특성을 추가해야 합니다. 여기에 service가 하는 일과 service의 장점을 설명하는 간략한 문장을 기재하면 됩니다.


6)주요 메서드
serivce를 생성하려면, Service의 하위 클래스를 생성하거나 기존 하위 클래스 중 하나를 사용해야 합니다. 구현에서는, 수명 주기의 주요 부분을 처리하는 일부 콜백 메서드를 재정의해야 하며 필요시 service에 바인딩할 component에 대한 메커니즘을 제공해야 합니다. 다음은 재정의가 필요한 중요한 콜백 메서드입니다.

onStartCommand()
activity 같은 다른 component가 service를 시작하고자 할 때, startService()을 부르면 시스템은 이 메서드를 호출합니다. 이 메서드가 실행되면, service가 시작되고 백그라운드에서 무한히 실행될 수 있습니다. service 작업이 완료되었을 때 해당 service를 중단하는 건 개발자 역량이며, 이때 stopSelf() 또는 stopService()를 호출하면 됩니다. 바인딩만 제공하고자 하는 경우 해당 메서드를 구현하지 않아도 됩니다.

onBind()
RPC 같이 다른 component가 해당 serivce에 바인딩되고자 할 때, bindService()을 부르면 시스템은 이 메서드를 호출합니다. 이 메서드에는 클라이언트가 service와 통신을 송수신할 때 사용할 인터페이스를 제공해야 하며 이 인터페이스는 IBinder를 반환해야 합니다. 이 메서드는 항상 구현해야 하지만 바인딩을 원치 않을 때는 null을 반환하면 됩니다.

onCreate()
시스템은 service가 처음 생성되었을 때, 즉 service가 onStartCommand() 또는 onBind()를 호출하기 전에 이 메서드를 호출하여 초기 설정 과정을 거칩니다. service가 이미 실행 중인 경우에는 호출되지 않습니다.

onDestroy()
service를 더 이상 사용하지 않고 소멸시킬 때 호출됩니다. service는 스레드, 등록된 리스너 또는 수신기 등의 각종 리소스를 정리하기 위해 구현해야 합니다. 이는 service가 수신하는 마지막 호출입니다.

어느 component가 startService()를 호출하여 service를 시작하면 onStartCommand()에 대한 호출 발생하고, 해당 service는 알아서 stopSelf()로 스스로 중단할 때까지 또는 다른 component가 stopService()를 호출하여 service를 중단시킬 때까지 실행 중인 상태로 유지됩니다. onStartCommand()를 호출하지 않은 채 bindService()만을 호출하여 service를 생성한다면, service는 해당 component에 바인딩되는 동안만 실행됩니다. service가 모든 클라이언트로부터 바인딩이 해제되면 시스템이 이를 소멸시킵니다.


7)service 수명 주기
service의 수명 주기는 activity의 수명 주기보다 훨씬 간단합니다. 그렇지만 service가 사용자가 모르게 백그라운드에서 실행될 수 있기 때문에 신경 써야합니다. service가 생성될 때부터 소멸될 때까지 수명 주기는 다음 두 경로 중 하나를 따를 수 있습니다.

started service
다른 구성요소가 startService()를 호출하면 service가 생성됩니다. 그러면 service가 무기한 실행되고 자체적으로 stopSelf()를 호출하여 중지합니다. 다른 구성요소가 stopService()를 호출하여 service를 중지할 수도 있습니다. service가 중단되면 시스템이 이를 소멸시킵니다.

bound service
다른 구성요소가 bindService()를 호출하면 service가 생성됩니다. 그러면 클라이언트가 IBinder 인터페이스를 통해 service와 통신합니다. 클라이언트는 unbindService()를 호출하여 연결을 종료할 수 있습니다. 여러 클라이언트가 동일한 service에 바인딩될 수 있으며, 모든 클라이언트가 바인딩을 해제하면 시스템이 service를 소멸시킵니다. service가 자체적으로 중지할 필요는 없습니다.

이 두 경로는 완전히 분리되지 않습니다. 이미 startService()로 시작된 service에 바인딩할 수 있습니다. 예를 들어 재생할 음악을 식별하는 Intent를 포함하여 startService()를 호출하면 백그라운드 음악 service를 시작할 수 있습니다. 나중에 사용자가 플레이어를 제어하거나 현재 노래에 관한 정보를 가져오려고 할 때 bindService()를 호출하여 activiy가 service에 바인딩할 수 있습니다. 이 경우 모든 클라이언트가 바인딩을 해제할 때까지 stopService() 또는 stopSelf()는 실제로 service를 중지하지 않습니다.

activity와 마찬가지로 service에도 수명 주기 콜백 메서드가 있습니다. 이를 구현하면 service의 상태 변경 내용을 모니터할 수 있고 적절한 시기에 작업을 수행할 수 있습니다. 다음의 service는 각 수명 주기 메서드를 보여줍니다.

public class ExampleService extends Service {
    int startMode;       // service가 종료되면 어떻게 행동할지 나타냄
    IBinder binder;      // 클라이언트와 바인드할 인터페이스
    boolean allowRebind; // onRebind를 사용 여부 나타냄

    @Override
    public void onCreate() {
        // service생성하는 곳
    }
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        //startService()가 호출되어 service가 시작하는 곳
	return startMode;
    }
    @Override
    public IBinder onBind(Intent intent) {
        // bindService()가 호출되어 클라이언트가 service와 바인딩되는 곳
	return binder;
    }
    @Override
    public boolean onUnbind(Intent intent) {
        unbindService()가 호출되여 모든 클라이언트가 해제됨
	return allowRebind;
    }
    @Override
    public void onRebind(Intent intent) {
        //onUnbind()가 이미 호출된 후 클라이언트가 
	//bindService()로 다시 service와 바인딩되는 곳
    }
    @Override
    public void onDestroy() {
        // service가 더 이상 사용되지 않아 소멸되는 곳
    }
}

activity 수명 주기 콜백 메서드와는 달리 service는 슈퍼클래스 구현을 호출하지 않아도 됩니다.

(수명주기 그림)
위의 그림은 service에 대한 일반적인 콜백 메서드를 나타낸 것입니다. 이 그림에서는 startService()로 생성된 service와 bindService()로 생성된 service를 구분하고 있지만, 어떤 식으로 시작되었든 모든 service는 클라이언트와 바인딩될 수 있습니다. 클라이언트가 startService()호출하여 onStartCommand()로 처음 시작된 service라고 해도 클라이언트가 bindService()를 호출하면 여전히 onBind()에 대한 호출을 받을 수 있습니다. 시작된 service를 중단하려면 stopSelf() 또는 stopService()를 호출하면 되지만, service에 대한 개별 콜백은 없습니다. 즉 onStop() 콜백이 없습니다. 그러므로 service가 클라이언트에 바인딩되어 있지 않은 한, 시스템은 service가 중단되면 이를 소멸시킵니다. 수신되는 콜백은 onDestroy()가 유일합니다.
 
메서드를 구현함으로써, service 수명 주기의 두 가지 중첩된 루프를 모니터링할 수 있습니다.
-service의 전체 수명은 onCreate()가 호출된 시점부터 onDestroy() 반환 시점까지입니다. activity와 마찬가지로 service는 자신의 초기 설정을 onCreate()에서 수행하며, 남은 리소스를 모두 onDestroy()에서 해제합니다. 예를 들어 음악 재생 service는 스레드를 생성하고, 이 스레드의 onCreate()에서 음악이 재생됩니다. 그런 다음, onDestroy()에서 스레드를 중단할 수 있습니다. onCreate() 및 onDestroy() 메서드는 모든 service에 호출됩니다. 이는 service가 startService()로 생성되었든 bindService()로 생성되었든 상관없이 적용됩니다.
-service의 활성 수명은 onStartCommand() 또는 onBind()에 대한 호출에서부터 시작됩니다. 각 메서드는 Intent를 받아서 startService() 또는 bindService()에 전달합니다. service가 시작되면 수명 주기 전체가 종료되는 것과 동시에 활성 수명 주기도 종료됩니다. service는 onStartCommand()가 반환된 뒤에도 여전히 활성 상태입니다. service가 바인딩된 경우, onUnbind()가 반환되면 활성 수명 주기가 종료됩니다. 



2. Service 변화
 service를 구현하기 위해서는 단지 Service를 extends하고 몇가지 메소드를 재정의하면 됩니다. 위에 언급된 주요 메소드들이 그것들이지요. service가 멀티스레딩을 수행해야 하는 경우 Service 클래스를 확장하여 각각의 수신 인텐트를 처리하게 할 수 있습니다. 다음은 각 시작 요청에 대해 work 스레드로 작업을 수행하여 한 번에 하나씩만 순차적으로 처리하는 코드 예시입니다.

public class HelloService extends Service {
  private Looper serviceLooper;
  private ServiceHandler serviceHandler;

  //스레드에서 메시지를 받는 핸들러입니다
  private final class ServiceHandler extends Handler {
      public ServiceHandler(Looper looper) {
          super(looper);
      }
      @Override
      public void handleMessage(Message msg) {
       // 보통 여기서 파일 다운같은 작업을 합니다.
       // 본 예시에서는 단순히 5초 sleep 합니다
       try{
           Thread.sleep(5000);
       }catch(InterruptedException e){
          //인터럽트 상태 복원
          Thread.currentThread().interrupt();
       }
       //다른 작업을 처리하는 동안 service를 중지하지 않도록 
       //startId를 사용하여 service를 중지합니다
          stopSelf(msg.arg1);
      }
  }

  @Override
  public void onCreate() {
  //service를 실행하는 스레드를 시작합니다. 
 //service는 일반적으로 프로세스의 main 스레드에서 실행되므로 
 //방해되지 않게 별도의 스레드를 만듭니다.
 //또한 CPU 집약적 작업이 UI를 중단시키지 않도록 백그라운드 우선순위를 설정합니다.
    HandlerThread thread = new HandlerThread("ServiceStartArguments",
            Process.THREAD_PRIORITY_BACKGROUND);
    thread.start();

    // HandlerThread의 Looper를 얻어 핸들러에 사용합니다
    serviceLooper = thread.getLooper();
    serviceHandler = new ServiceHandler(serviceLooper);
  }

  @Override
  public int onStartCommand(Intent intent, int flags, int startId) {
  // 각 시작 요청에 대해 작업을 시작하라는 메시지와 start ID를 전달하면 
  //작업 완료 시 어떤 요청을 중지해야하는 알 수 있습니다
      Message msg = serviceHandler.obtainMessage();
      msg.arg1 = startId;
      serviceHandler.sendMessage(msg);

      //중단되면 이곳으로 리턴되어 재시작합니다
      return START_STICKY;
  }

  @Override
  public IBinder onBind(Intent intent) {
     //바인딩을 하지 않았기에 null을 반환시킵니다.
      return null;
  }

  @Override
  public void onDestroy() {
    Toast.makeText(this, "service done", Tost.LENGTH_SHORT).show()
  }
}

 위 예제코드는 onStartCommand()에 들어오는 모든 호출 처리와 백그라운드 스레드에서 실행되는 Handler 작업을 보여줍니다. 하나씩 처리하는 작업을 예시로 보여드렸지만 여러 개의 요청을 동시에 수행할 수도 있습니다. 각 호출을 onStartCommand()로 직접 처리하기 때문입니다. 스레드풀에서 각 요청에 대해 새 스레드를 하나씩 생성한 다음 이전 요청이 끝날 때까지 기다리지 않고 곧바로 실행하면 됩니다.


1)IntentService 클래스 
Service의 하위 클래스로, worker 스레드를 사용하여 모든 시작 요청을 처리하되 한 번에 하나씩 처리합니다. 그렇기에 service가 여러 개의 요청을 동시에 처리하지 않아도 되는 경우에 적합합니다. 위의 예제를 보면 알 수 있 듯이 service 클래스를 사용하면 많은 코드량이 필요하기 때문에 간단히 구현할 수 있는 IntentService를 제공하였습니다. onHandleIntent()를 구현하는데 이는 각 시작 요청에 대해 인텐트를 수신해서 백그라운드 작업을 완료하도록 합니다.작업 큐를 통해 시작 요청을 처리합니다. 

IntentService 클래스는 다음과 같이 작동합니다.
-애플리케이션의 main 스레드와는 별도로, onStartCommand()에 전달된 모든 인텐트를 실행하는 기본 worker 스레드를 생성
-인텐트를 한 번에 하나씩 onHandleIntent() 구현에 전달하는 작업 큐를 생성하므로, 다중스레딩에 대해 염려할 필요 없음
-시작 요청이 모두 처리된 후 service를 중단하므로, 개발자가 stopSelf()를 호출할 필요가 전혀 없음
-onBind()의 기본 구현을 제공하여 null을 반환
-onStartCommand()의 기본 구현을 제공하여, 인텐트를 작업 큐로 보내고 그다음은 onHandleIntent() 구현으로 보냄

클라이언트가 제공한 작업을 완료하기 위해 onHandleIntent()를 구현합니다. 
다음은 IntentService 구현의 예입니다.

public class HelloIntentService extends IntentService {

  /*생성자를 구현해야하며 super(workder 스레드이름)을 꼭 생성해야합니다.*/
  public HelloIntentService() {
      super("HelloIntentService");
  }
  /**
   IntentServic는 기본 worker 스레드에서 인텐트로 service를 시작할 때 이 메소드를 부릅니다. 
   이 메서드가 리턴되면  IntentService가 service를 적당한 시기에 멈춥니다
   */
  @Override
  protected void onHandleIntent(Intent intent) {
       // 보통 여기서 파일 다운같은 작업을 합니다.
       // 본 예시에서는 단순히 5초 sleep 합니다
       try{
           Thread.sleep(5000);
       }catch(InterruptedException e){
          //인터럽트 상태 복원
          Thread.currentThread().interrupt();
       }
  }
}

단지 생성자 하나와 onHandleIntent()만 구현하면 됩니다. 다른 콜백 메서드도 재정의하려면(onCreate(), onStartCommand() 또는 onDestroy()) 슈퍼 구현을 꼭 호출해야 합니다. 그래야만 IntentService가 작업자 스레드의 수명을 적절하게 처리할 수 있습니다. 예를 들어 onStartCommand()는 반드시 기본 구현을 반환해야 합니다. 그래야 인텐트가 onHandleIntent()로 전달됩니다. onHandleIntent() 외에 슈퍼 클래스를 호출하지 않아도 되는 메서드는 onBind() 뿐입니다.물론 onBind()는 service가 바인드를 허용하는 경우에만 구현해야 합니다.

IntentService는 백그라운드에서 비동기 작업 때 자동으로 스레드를 생성하여 작업을 처리하고 스스로 중단하여 개발자에게 편할 뿐 아니라 코드량도 적어졌습니다. 하지만 백그라운드 실행 제한으로 deprecated되었죠.

백그라운드 실행 제한?
백그라운드에서 실행 중인 service는 기기의 리소스를 소비하기 때문에 잠재적으로 나쁜 사용자 경험을 초래할 수 있습니다. 이러한 문제를 완화하기 위해, 시스템은 service에 여러 가지 제한을 적용합니다.


2)JobScheduler(extends JobService)
IntentService 대체로 JobScheduler이 나온 것은 아니지만 백그라운드 최적화를 위해 만들어졌습니다. JobService라는 service를 사용하고 백그라운드 제한이 생김에 따라 이를 해결하는 방법은 중요하기 때문에 이에 대한 내용을 다루어 보겠습니다.

우선 JobScheduler는 이름에서 알 수 있듯이 작업을 스케쥴링을 해주는 API입니다. 이 프레임워크는 언제 job을 실행하는지 파악하고 최대한 배치 또는 지연하려고 합니다. JobInfo으로 선언된 조건이 충족되면 시스템은 응용 프로그램의 JobService에서 해당 job을 실행합니다. JobInfo는 네트워크의 연결 상태나 충전 여부 등 JobService가 실행되어야 하는 조건을 관리합니다. 이 조건은 하나일 수도 여러 개일 수도 있습니다. JobService는 시작 및 종료 시의 동작을 처리할 수 있으며 onStartJob()과 onStopJob() 콜백 메소드를 제공합니다. Job 실행을 위한 권한을 등록한 후, 구현된 JobService에 scheduleJob메소드로 선언된 JobInfo을 전달하면 됩니다.

service 권한을 등록하기 위해 매니페스트 파일에서 <application> 요소의 하위로 service 요소의 permission 속성을 추가하면 됩니다.

AndroidManifest.xml
<manifest ... >
  ...
  <application ... >
      <service
            android:name=".SampleService"//선언한 service 이름
            android:permission="android.permission.BIND_JOB_SERVICE"
            android:exported="true"/>
      ...
  </application>
</manifest>

SampleService.java
public class SampleService extends JobService {

    @Override
    public boolean onStartJob(JobParameters params) {
        //조건에 만족하여 실행하였을 때 호출됨
        //종료 후 동작할 job이 없으면 false,
        //종료 후에도 동작할 job이 있으면 true을 리턴
        //true일 경우 jobFinished()을 호출하여 job 완료를 알리거나
        //조건이 충족되지 않을 때까지 활성 상태 유지
        return false;
    }

    @Override
    public boolean onStopJob(JobParameters params) {
        //jobFinished()호출 전, job 완료 전에 중지해야 할 경우 호출
        //중지 후 다시 스케쥴러에 등록하려면 true, 아니면 false 리턴
        return false;
    }

}

onStartJob()
 onStartJob()은 Job이 시작할 때 시스템에 의해 호출되는 콜백입니다. JobService는 메인스레드에서 실행되므로, 필요에 따라 Thread를 호출해야합니다. onStartJob()의 종료 시 Thread 같이 지속할 동작이 있다면 true, 지속할 동작 없이 완료된다면 false를 리턴합니다. false를 반환하면 job이 이미 완료되었음을 의미하기에 job에 대한 시스템의 wake lock이 해제되고 onStopJob()이 호출되지 않습니다.

+wakelock?
wakelock은 기기가 절전 모드로 전환되기 전 일부 작업을 완료하기 위해, CPU를 실행 중인 상태로 유지시켜주는 PowerManager 시스템 서비스 기능입니다. wake lock을 사용하면 애플리케이션에서 호스트 기기의 전원 상태를 제어할 수 있습니다.
 
 true를 반환할 경우 jobFinished()를 호출하여 job이 완료되었음을 명시적으로 시스템에 알리거나 job에 필요한 제약 조건이 더 이상 충족되지 않을 때까지 job이 활성 상태로 유지됩니다. 예를 들어 setRequiresCharging(true)을 사용하여 job이 예약된 경우 사용자가 장치의 전원을 분리하면 job이 OnStopJob() 콜백을 실행되고 해당 job과 연결된 진행 중인 모든 작업이 종료, wake lock이 해제됩니다.
 onStopJob이 호출되었다면 jobFinished()를 호출할 필요 없습니다. jobFinished()은 두개의 param을 받습니다. wake lock을 풀어야하는 job(현재 자신)과, retry 여부 입니다. 따라서 true를 넣으면 job이 재실행 되고 false를 넣으면 재실행 없이 job이 완료됩니다.
 시스템은 job이 실행되는 동안 앱을 대신하여 wake lock을 유지합니다. 이 wakelock은 onStartJob()가 호출되기 전에 획득되며 jobFinish()를 호출하거나 StopJob()을 호출하여 job이 조기에 종료됨을 알리기 전까지는 해제되지 않습니다.

onStopJob()
onStopJob()는 JobFinished() 호출 전, 시스템에서 job 실행을 중지해야 한다고 결정한 경우에 호출됩니다. 그렇기에 이 메서드가 호출되면 JobFinished()를 호출할 필요가 없습니다. 시스템이 중지해야하는 경우는 지정된 조건이 더 이상 충족되지 않을 때입니다. 예를 들어 setRequiredNetworkType()으로 WiFi를 요청했지만 job이 실행되는 동안 WiFi 연결 상태가 바뀔 수 있습니다. 
중지 후 다시 스케쥴러에 등록하려면 true, 아니면 false 리턴을 합니다.
이 메서드가 리턴 또는 시간 초과되면 시스템은 job을 대신하여 유지하고 있는 wake lock을 해제합니다.

service를 구현하였으면 service를 실행시킬 곳에 아래와 같이 등록시키면 됩니다.
JobInfo job = new JobInfo.Builder(
//job id 등록
123,
//조건 충족 시 실행시킬 service class
new ComponentName(getApplicationContext(), SampleService.class)
)
//조건 설정                    
.setRequiresStorageNotLow(true)                    
.build();
        
JobScheduler jobScheduler= (JobScheduler)getSystemService(Context.JOB_SCHEDULER_SERVICE);
jobScheduler.schedule(job);

job를 취소시키려면 스케쥴러에 cancel()를 호출하여 job id를 넘겨주면 됩니다.
jobScheduler.cancel(123);

이렇듯 백그라운드 실행 제한을 해결하기 위해 제시된 방법이지만 가장 큰 문제가 있었으니 바로 하위 호환성이었습니다. API level 21부터만 지원이 되었죠. 안드로이드에는 다양한 버전을 사용한 사용자들이 많았기에 실수 또는 문제를 유발할 수 있는 점이었습니다. 그렇게 JobIntentService가 나왔습니다.


3)JobIntentService
JobIntentService는 job/service를 위해 큐에 적재되어 있는 작업을 처리하기 위한 도우미입니다. Android O 이상에서 실행되는 경우, JobScheduler를 사용하여 schedule()대신 enqueue()으로 job을 전송합니다. 이전 버전의 플랫폼에서 실행되는 경우, 기본 인텐트를 실행하는 경우와 똑같이 startService()를 사용합니다. 또한 wakelock을 알아서 관리해주기 때문에 이전처럼 WakefulBroadcastReceiver를 사용할 필요가 없습니다. Android O에서 실행되는 경우, 큐에 적재될 때부터 job이 디스패치될 때까지 그리고 job이 실행되는 동안 wake lock을 유지합니다. 이전 버전의 플랫폼에서 실행되는 경우, wake lock 처리는 PowerManager을 직접 부르면서 이 클래스에 에뮬레이션됩니다. 이는 응용 프로그램이 WAKE_LOCK 권한을 요청해야 함을 의미합니다.

Android O 이상에서 Job으로 실행할 경우와 O 이전으로 실행할 경우 몇 가지 중요한 차이점이 있습니다
-실행 조건
O 이전
장치가 doze 또는 다른 조건에 관계없이 즉시 service를 시작하여 적재된 작업을 순차적으로 실행
O 이후
JobScheduler를 통해 적재된 작업을 순차적으로 실행. 내부적으로는 고정된 Job의 실행 조건(jobInfo.setOverrideDeadline(0).build())에 의해 실행되므로, 이외의 조건은 직접 설정할 수 없음. 이때 job은 장치가 doze일 때 실행하지 않으며, 실행해야 할 많은 job을 요구당하여 강력한 메모리 압박을 받는 경우 service보다 더 지연될 수 있음.
-실행 제한
O 이전
일반적인 service 실행 의미론이 적용. service는 무한정 실행될 수 있지만 실행 시간이 길수록 시스템이 프로세스를 완전히 종료할 가능성이 높아지며 메모리 압력 하에서는 최근에 시작된 service어도 프로세스가 종료됨을 예상될 수 있음
O 이후
JobService 실행 시간 제한이 적용되며, 이후 job이 중지되고(프로세스를 종료는 아님) 나중에 실행을 계속하도록 일정이 조정. 장치의 메모리 상태에 따라 동시 job 수가 조정되기 때문에 시스템이 메모리 압력 하에 있을 때는 일반적으로 job이 종료되지 않음.

doze이란?
사용자가 충전기를 연결하지 않고 화면이 꺼진 채로 기기를 일정 기간  방치해두면 , 기기는 doze 즉 잠자기 모드를 시작합니다. 이 모드에서는 시스템이 네트워크 및 CPU를 많이 사용하는 service에 대한 앱의 액세스를 제한하여 배터리를 절약하려고 합니다. 또한, 앱이 네트워크에 액세스하지 못하도록 하고 작업, 동기화 및 표준 알람을 지연시킵니다.

O이상에서는 JobScheduler를 사용하기 때문에, 시스템이 상호 작용하기 매니페스트에 등록해야합니다.

enqueueWork()를 호출하여 service으로 전송하고, 처리할 새 작업을 enqueueWork를 사용하여 HandleWork에서 실행합니다. 아래는 JobIntentService 예시 입니다.
public class SimpleJobIntentService extends JobIntentService {
    
     //이 service의 고유한 job ID.
    static final int JOB_ID = 1000;

    //service에서 큐를 적재하기 위한 편의 메소드
    static void enqueueWork(Context context, Intent work) {
        enqueueWork(context, SimpleJobIntentService.class, JOB_ID, work);
    }

    @Override
    protected void onHandleWork(@NonNull Intent intent) {
        // 할 일을 받았기에 이 시점에서 이미 시스템 또는 프레임워크는 wake lock을 가지고 있음
        Log.i("SimpleJobIntentService", "Executing work: " + intent);
        String label = intent.getStringExtra("label");
        if (label == null) {
            label = intent.toString();
        }
        toast("Executing: " + label);
        for (int i = 0; i < 5; i++) {
            Log.i("SimpleJobIntentService", "Running service " + (i + 1)
                    + "/5 @ " + SystemClock.elapsedRealtime());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
        }
        Log.i("SimpleJobIntentService", "Completed service @ " + SystemClock.elapsedRealtime());
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        toast("All work complete");
    }

    @SuppressWarnings("deprecation")
    final Handler mHandler = new Handler();

    // 테스트 표시 
    void toast(final CharSequence text) {
        mHandler.post(new Runnable() {
            @Override public void run() {
                Toast.makeText(SimpleJobIntentService.this, text, Toast.LENGTH_SHORT).show();
            }
        });
    }
}

이렇게 JobIntentService를 사용하였지만 10분의 제한시간이 있어 이후 강제종료가 되었습니다. 권한이 필수적으로도 필요했습니다. 

-참고 :  
https://medium.com/til-kotlin-ko/android-o%EC%97%90%EC%84%9C%EC%9D%98-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%B2%98%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-jobintentservice-250af2f7783c,
https://tourspace.tistory.com/38


4)workManager
WorkManager는 백그라운드 처리에 권장하는 기본 API입니다. 대부분의 백그라운드 처리는 지속적인 작업으로 처리되는데 WorkManager는 지속적인 작업에 권장되는 솔루션이기 때문입니다. 앱이 다시 시작되거나 시스템이 재부팅될 때 작업이 예약된 채로 남아 있으면 그 작업은 지속됩니다. WorkManager가 처리하는 지속적인 작업의 유형은 세 가지입니다.
-즉시
즉시 시작하고 곧 완료해야 하는 작업. 신속하게 처리 가능
-장기 실행
10분 이상, 오래 실행될 수 있는 작업.
-지연 가능
시작을 지연하고 주기적으로 실행될 수 있는 예약된 작업

WorkManager는 사용자가 화면을 벗어나 이동하거나, 앱이 종료되거나, 기기가 다시 시작되더라도 안정적으로 실행되어야 하는 작업을 대상으로 설계되었습니다. 예를 들어 백엔드 service에 로그 또는 분석 전송, 주기적으로 서버와 애플리케이션 데이터 동기화가 있습니다.

또한 workManager는 다음과 같은 특징들을 가집니다.
-작업 제약 조건
작업 제약 조건을 사용하여 작업을 실행하는 데 최적인 조건을 선언적으로 정의합니다. 예를 들어, 기기가 무제한 네트워크에 있을 때 또는 기기가 유휴 상태이거나 배터리가 충분할 때만 실행합니다.

-강력한 예약 관리
WorkManager를 사용하면 가변 스케쥴링을 통해 한 번 또는 반복적으로 실행할 작업을 예약할 수 있습니다. 작업에 태그 및 이름을 지정하여 고유 작업 및 대체 가능한 작업을 예약하고 작업 그룹으로 함께 모니터링하거나 취소할 수 있습니다. 예약된 작업은 내부적으로 관리되는 SQLite 데이터베이스에 저장되며 기기를 재부팅해도 WorkManager는 작업이 유지되고 다시 예약되도록 보장합니다. 또한 절전 기능을 사용하고 doze 같은 권장사항을 준수하므로 배터리 소모를 걱정하지 않아도 됩니다.

-신속 처리 작업
WorkManager를 사용하여 백그라운드에서 즉시 실행할 작업을 예약할 수 있습니다. 사용자에게 중요하고 몇 분 내에 완료되는 작업에는 신속 처리 작업을 사용해야 합니다.

-유연한 재시도 정책
경우에 따라 작업이 실패하기도 합니다. WorkManager는 구성 가능한 exponential back-off 정책을 비롯한 유연한 재시도 정책을 제공합니다.

-작업 체이닝
복잡하게 연결된 작업의 경우, 순차적이거나 병렬적으로 실행되는 작업을 제어할 수 있는 직관적인 인터페이스를 사용하여 개별 작업을 함께 연결합니다.

-내장 스레딩 상호 운용성
WorkManager는 코루틴 및 RxJava와 원활하게 통합되며 고유한 비동기 API를 연결할 수 있는 유연성을 제공합니다. 코루틴과 WorkManager가 여러 사용 사례에 권장되지만, 상호 배타적이지는 않습니다. WorkManager를 통해 예약된 작업 내에서 코루틴을 사용할 수도 있습니다.

WorkManager를 사용하기 위해서는 우선 필요한 종속 항목을 추가하고  Worker 클래스를 사용하여 작업을 정의해야 합니다. doWork() 메서드로 WorkManager에서 제공하는 백그라운드 스레드에서 비동기적으로 실행할 수 있습니다. WorkManager에서 실행할 작업을 만들려면 Worker 클래스를 확장하고 doWork() 메서드를 재정의합니다. 예를 들어 이미지를 업로드하는 Worker를 만들려면 다음과 같이 할 수 있습니다.

public class UploadWorker extends Worker {
   public UploadWorker(
       @NonNull Context context,
       @NonNull WorkerParameters params) {
       super(context, params);
   }

   @Override
   public Result doWork() {

     // 여기서 작업할 내용을 작성합니다. 예로 이미지 업로드
     uploadImages();

     //Result으로 작업이 성공적으로 완료하였는지 나타냄
     return Result.success();
   }
}

doWork()에서 반환된 Result는 작업의 성공 여부를 알려주며 실패한 경우 WorkManager service에 작업을 재시도해야 하는지 알려줍니다.

Result.success(): 작업이 성공적으로 완료되었습니다.
Result.failure(): 작업에 실패했습니다.
Result.retry(): 작업에 실패했으며 재시도 정책에 따라 다른 시점에 시도되어야 합니다.

작업을 정의하고 나면 실행을 위해 WorkManager service로 예약해야 합니다. WorkManager에서는 작업을 예약하는 다양한 방법을 제공합니다. 일정한 간격의 주기로 실행되도록 예약하거나 한 번만 실행되도록 예약할 수 있습니다. 어떤 작업 예약 방식을 선택하든 항상 WorkRequest를 사용합니다. Worker는 작업 단위를 정의하는 반면 WorkRequest 및 서브클래스는 언제, 어떻게 작업이 실행되어야 하는지 정의합니다. 가장 간단한 경우 다음 예와 같이 OneTimeWorkRequest를 사용하면 됩니다.

WorkRequest uploadWorkRequest =
   new OneTimeWorkRequest.Builder(UploadWorker.class)
       .build();

필요한 경우 setConstraints()를 통해 제약 조건을 설정합니다.

마지막으로 enqueue() 메서드를 사용하여 WorkRequest를 WorkManager에 제출해야 합니다.
WorkManager
    .getInstance(myContext)
    .enqueue(uploadWorkRequest);

작업자가 실행되는 정확한 시간은 WorkRequest에 사용된 제약조건과 시스템 최적화에 따라 달라집니다. WorkManager는 이러한 제한사항에 따라 최상의 상태로 작동하도록 설계되었습니다.



3. Started Service란

1)started Service?
started service는 다른 component가 startService()를 호출하면, 그 결과로 service의 onStartCommand() 메서드가 호출됩니다. service가 시작되면 이를 시작한 component와는 다른 독립적인 수명 주기를 가지게 됩니다. 해당 service를 시작한 component가 소멸되었더라도 service는 백그라운드에서 계속 실행될 수 있습니다. 따라서 service는 작업이 완료되면 stopSelf()를 호출하여 스스로 중단하거나 다른 component가 stopService()를 호출하여 중단시킵니다.

애플리케이션 component가 service를 시작할 때, startService()를 호출하고 Intent를 전달합니다. 이때 Intent에는 시작할 service를 지정하고 필요한 모든 데이터를 보냅니다. 그럼 이 Intent는 onStartCommand() 메서드에서 받습니다. 예를 들어 어느 activity가 온라인 데이터베이스에서 어떤 데이터를 저장해야 한다고 가정해보겠습니다. activity가 필요한 service를 시작하고, 인텐트를 startService()로 전달하여 service에 저장할 데이터를 보냅니다. service는 이 인텐트를 onStartCommand()에서 수신하고, 인터넷에 연결한 다음, 데이터베이스 트랜잭션을 수행합니다. 트랜잭션이 완료되면 service가 스스로 중단되어 소멸됩니다.

Service 클래스는 모든 service의 기본 클래스입니다. 이 클래스를 extend할 때는 새 스레드를 만드는 것이 중요합니다. service는 기본적으로 애플리케이션의 main 스레드를 사용하는데, 애플리케이션에서 실행 중인 작업에 영향을 주어 수행 속도가 느려질 수 있기 때문입니다. 그렇기에 안드로이드 프레임워크에서는 service의 하위 클래스인 IntentService를 제공했습니다. 이 클래스는 모든 시작 요청에 대해 한 번에 하나씩 처리하는 worker 스레드를 제공합니다. 하지만 백그라운드 실행 제한을 도입한 후, android 8부터 사용을 추천하지 않았으며 android 11부터는 deprecated 되었습니다. 현재는 workManager 사용을 권장하고 있습니다.

백그라운드 실행 제한?
백그라운드에서 실행 중인 service는 기기의 리소스를 소비하기 때문에 잠재적으로 나쁜 사용자 경험을 초래할 수 있습니다. 이러한 문제를 완화하기 위해, 시스템은 service에 여러 가지 제한을 적용합니다.


2)service 시작
 다른 component에서 service를 시작하려면, Intent로 시작할 service를 지정하여 startService() 또는 startForegroundService()에 전달하면 됩니다. 그러면 android 시스템은 service의 onStartCommand() 메서드를 호출하고 여기에 Intent를 전달합니다. activity가 HelloService이라는 service를 시작하려면, startService()로 HelloService라고 명시하는 인텐트를 사용하면 됩니다.

Intent intent = new Intent(this, HelloService.class);
startService(intent);

아직 실행되지 않았던 service라면 먼저 onCreate()를 호출한 다음, onStartCommand()를 호출합니다. 

service가 바인딩을 제공하지 않는 경우, startService()와 함께 전달된 인텐트가 component와 service 사이의 유일한 통신 수단입니다. 그러나 service가 결과를 돌려받기를 원하는 경우 service를 시작한 클라이언트가 PendingIngetBroadcast() 메소드를 사용하여 브로드캐스트으로 Intent를 만들고 이를 service에 전달할 수 있습니다. 그러면 service가 이 브로드캐스트으로 전달된 결과를 사용할 수 있게 됩니다. 

service를 시작하기 위한 요청을 여러 개 보내면 그에 대응하여 service의 onStartCommand()에 대해 여러 번 호출이 발생합니다. 반면 중단할 때는 stopSelf() 또는 stopService()으로 한 번만 중단을 요청하면 됩니다.

 만약 앱이 API 레벨 26 이상을 대상으로 한다면 앱이 포그라운드에 있지 않을 때 시스템에서 백그라운드 service 사용하거나 생성하는 것에 제한을 적용합니다. 즉, 백그라운드 service는 앱이 포그라운드에 있을 때 사용 또는 생성해야 합니다. 사용자가 동시에 실행하는 앱이 많을 경우 시스템에 부하가 걸리는데 이런 경우에 백그라운드에 실행 중인 service가 있으면 더욱 시스템에 부하를 주기 때문입니다.
앱이 포그라운드 service를 생성해야 하는 경우, 해당 앱은 startForegroundService()를 호출해야 합니다. 이 메서드는 백그라운드 service를 생성하지만, 메서드가 시스템에 신호를 보내 service가 자체적으로 포그라운드로 승격될 것이라고 알립니다. service가 생성되면, 앱은 5초 이내에 해당 service의 startForeground() 메서드를 호출해야 합니다. 그럼 새롭게 생성된 service에 대한 알림이 사용자에게 표시됩니다. 앱이 이 시간 한도 내에 startForeground()를 호출하지 않으면 시스템은 service를 중단하고 이 앱을 ANR로 선언합니다.


3)service 중단
started service는 자신의 수명 주기를 직접 관리해야 합니다. 즉 시스템이 service를 중단하거나 소멸시키지 않는다는 뜻입니다. 다만 시스템이 부족한 메모리를 확보하기 위해 service를 강제 종료하거나 service가 onStartCommand() 반환 후 계속 실행되는 경우는 예외입니다. service는 stopSelf()를 호출하여 스스로 중지 할 수도 있고 다른 component가 stopService()를 호출하여 이를 중지시킬 수 있습니다. stopSelf() 또는 stopService()로 중단 요청을 보내면 시스템은 가능한 한 빨리 service를 소멸시킵니다.

 service에 동시에 여러 onStartCommand() 요청이 있을 경우에는, 처리가 끝났다고 service를 중단하면 안 됩니다. 그 이후 또다른 시작 요청을 새로 받았을 수 있기 때문입니다. 가령 첫 요청이 끝날 때 중단하면 두 번째 요청이 종료될 수 있습니다. 이 문제를 피하려면, stopSelf(int)를 사용하여 service 중단 요청이 항상 가장 최근의 시작 요청을 기준으로 해야 합니다. 다시 말해, stopSelf(int)를 호출할 경우 onStartCommand()에 전달된 마지막 startId을 중단 요청이 대응됩니다. 그런 다음 stopSelf(int)를 호출되기 전에 service가 시작 요청을 새로 수신하면, service의 ID와 최근 startId가 일치하지 않으므로 새로운 servcie는 중단되지 않습니다.

시스템 리소스 낭비를 피하고 배터리 전력 소모를 줄이기 위해서는 service의 작업이 완료되면 애플리케이션에서 service를 중단해야 합니다. 필요한 경우 stopService()를 호출하여 다른 component가 service를 중단하게 합니다. service을 바인딩하더라도, service가 onStartCommand()에 대한 호출을 한 번이라도 받았으면 항상 직접 service를 중단해야 합니다.


4)Service 클래스 확장(extends)
 모든 service의 기본 클래스입니다. 이 클래스를 확장할 때는 service가 모든 작업을 무사히 완료할 수 있게 새 스레드를 생성하는 것이 중요합니다. service는 기본적으로 애플리케이션의 main 스레드를 사용하기 때문에, 애플리케이션에 실행 중인 activity의 성능을 저하를 막기 위해서입니다. 이 클래스는 시작 요청을 동시에 처리해야 하는 경우에 적합합니다. 다만 대부분의 사용 사례에서 WorkManager 사용을 추천합니다.

 service가 멀티스레딩을 수행해야 하는 경우 Service 클래스를 확장하여 각각의 수신 인텐트를 처리하게 할 수 있습니다. 다음은 각 시작 요청에 대해 work 스레드로 작업을 수행하여 한 번에 하나씩만 순차적으로 처리하는 코드 예시입니다.

public class HelloService extends Service {
  private Looper serviceLooper;
  private ServiceHandler serviceHandler;

  //스레드에서 메시지를 받는 핸들러입니다
  private final class ServiceHandler extends Handler {
      public ServiceHandler(Looper looper) {
          super(looper);
      }
      @Override
      public void handleMessage(Message msg) {
       // 보통 여기서 파일 다운같은 작업을 합니다.
       // 본 예시에서는 단순히 5초 sleep 합니다
       try{
           Thread.sleep(5000);
       }catch(InterruptedException e){
          //인터럽트 상태 복원
          Thread.currentThread().interrupt();
       }
       //다른 작업을 처리하는 동안 service를 중지하지 않도록 
       //startId를 사용하여 service를 중지합니다
          stopSelf(msg.arg1);
      }
  }

  @Override
  public void onCreate() {
  //service를 실행하는 스레드를 시작합니다. 
 //service는 일반적으로 프로세스의 main 스레드에서 실행되므로 
 //방해되지 않게 별도의 스레드를 만듭니다.
 //또한 CPU 집약적 작업이 UI를 중단시키지 않도록 백그라운드 우선순위를 설정합니다.
    HandlerThread thread = new HandlerThread("ServiceStartArguments",
            Process.THREAD_PRIORITY_BACKGROUND);
    thread.start();

    // HandlerThread의 Looper를 얻어 핸들러에 사용합니다
    serviceLooper = thread.getLooper();
    serviceHandler = new ServiceHandler(serviceLooper);
  }

  @Override
  public int onStartCommand(Intent intent, int flags, int startId) {
  // 각 시작 요청에 대해 작업을 시작하라는 메시지와 start ID를 전달하면 
  //작업 완료 시 어떤 요청을 중지해야하는 알 수 있습니다
      Message msg = serviceHandler.obtainMessage();
      msg.arg1 = startId;
      serviceHandler.sendMessage(msg);

      //중단되면 이곳으로 리턴되어 재시작합니다
      return START_STICKY;
  }

  @Override
  public IBinder onBind(Intent intent) {
     //바인딩을 하지 않았기에 null을 반환시킵니다.
      return null;
  }

  @Override
  public void onDestroy() {
    Toast.makeText(this, "service done", Tost.LENGTH_SHORT).show()
  }
}

 위 예제코드는 onStartCommand()에 들어오는 모든 호출 처리와 백그라운드 스레드에서 실행되는 Handler 작업을 보여줍니다. 각 호출을 onStartCommand()로 직접 처리하기에 여러 개의 요청을 동시에 수행할 수 있습니다. 물론 위의 코드는 그런 작업을 하지 않지만 원하는 경우, 스레드풀에서 각 요청에 대해 새 스레드를 하나씩 생성한 다음 이전 요청이 끝날 때까지 기다리지 않고 곧바로 실행하면 됩니다.

 onStartCommand() 메서드는 반드시 정수를 반환해야 합니다. 이 정수는 시스템이 service를 종료할 경우 service를 어떻게 지속할 지 설명하는 값입니다. onStartCommand()로부터의 반환 값은 반드시 다음 상수 중 하나여야 합니다.

START_STICKY(1, 0x00000001)
시스템이 service를 강제 종료 시킨 후, service를 재생성하여 onStartCommand()를 호출하되, 기존에 onStartCommand()으로 전달된 인텐트는 처리하지 않습니다. 그 대신 시스템이 인텐트 값을 null로 onStartCommand()를 호출합니다. 즉 기존의 인텐트가 null로 초기화 되어 service를 재시작합니다. 단 service를 시작할 때 pending intent를 전달한 경우는 예외로, pending intent가 전달됩니다. 실행할 명령은 없지만, 작업을 기다리고 무한히 실행하면서 명시적으로 시작되고 중지되는 미디어 플레이어 같은 service에 적합합니다.

START_NOT_STICKY(2, 0x00000002)
시스템이 service를 강제 종료 시키면 service를 재생성하지 않습니다. 다만 pending intent가 전달된 경우는 예외입니다. 이는 service가 불필요하게 실행되는 일을 피할 수 있는 가장 유용한 상수이며, 애플리케이션이 완료되지 않은 모든 작업을 단순히 다시 시작할 수 있을 때 유용합니다.

START_REDELIVER_INTENT(3, 0x00000003)
시스템이 service를 강제 종료 시킨 후, service를 다시 생성하고 이 service에 전달된 마지막 인텐트로 onStartCommand()를 호출합니다. 모든 pending intent는 차례로 전달됩니다. 파일 다운로드같이 즉시 재개되어야 하는 작업을 능동적으로 수행 중하는 service 에 적합합니다.



4. Foreground Service란
1)foreground service?
 foreground service는 사용자가 인식할 수 있는 작업을 실행합니다. 상태 표시줄 알림을 통해 포그라운드에서 작업을 실행하고 시스템 리소스를 소비하고 있음을 사용자에게 알립니다. foreground service를 사용하는 앱의 예는 다음과 같습니다

-음악을 재생하는 뮤직 플레이어 앱입니다. 사용자가 작동됨을 인식하고 있기 때문에 알림에 현재 재생 중인 노래가 표시됩니다. 또한 이 알림을 통해 음악 플레이어와 상호작용할 activity를 시작할 수 있습니다.
-사용자의 달리기를 기록하는 앱입니다. 사용자의 위치를 추적하는 데 사용됩니다. 알림을 통해 사용자가 이동한 거리를 표시할 수 있습니다.

앱이 사용자와 직접 상호작용하지 않을 때도 사용자가 인지할 수 있는 작업이면 foreground service를 사용해야 합니다. 작업의 중요도가 낮아 최소 우선순위 알림을 사용하려는 경우에는 대신 background task을 만들어야 합니다. 우선순위 상관 없이 service를 실행하면 활발히 상호작용을 주고받는 앱의 성능을 저해시키기 때문입니다. 대부분의 경우 foreground service 대신 작업을 실행하는 데 사용할 수 있는 전용 플랫폼 또는 Jetpack API가 있습니다. 이러한 API가 있다면 대부분 foreground service 대신 API를 사용하는 것이 좋습니다. 


2)사용자가 알림 닫기
Android 13(API 수준 33)부터 사용자는 기본적으로 foreground service와 연결된 알림을 닫을 수 있습니다. 단순히 사용자가 알림에서 스와이프 동작을 하면 됩니다. 이전에는 foreground service가 중지되거나 포그라운드에서 삭제되지 않는 한 알림이 닫히지 않았습니다. 만약 사용자가 알림을 닫을 수 없도록 하려면 Notification.Builder를 사용하여 알림을 만들 때 setOngoing() 메서드에 true를 전달합니다.


3)즉시 알림을 표시하는 service
Android 12 (API 수준 31) 이상을 실행하는 기기는 단기 실행 foreground service를 위한 간소화된 환경을 제공합니다. 이러한 기기에서 시스템은 foreground service와 관련된 알림을 표시하기 전에 10초 동안 대기합니다. 예외 사항이 있는데 몇몇 유형의 service는 알림을 항상 즉시 표시하기 때문입니다. 다음 특성 중 하나 이상이 있다면  service가 시작된 직후 연결된 알림을 표시합니다.

-service가 action button이 포함된 알림과 연결되어 있습니다. action button은 알림 일시중지나 sms에 답장하기 등 알림에 사용자가 신속하게 응답할 수 있는 작업 버튼입니다.
-service가 mediaPlayback, mediaProjection, phoneCall 같은 foregroundServiceType를 가집니다.
-알림의 카테고리 속성에 정의된 전화 통화, 내비게이션 또는 미디어 재생과 관련된 내용을 service가 제공합니다.
-service 알림을 설정 때  setForegroundServiceBehavior()에 FOREGROUND_SERVICE_IMMEDIATE를 전달합니다. 이 메소드를 통해 알림 표시 연기 정도를 설정할 수 있습니다.

Android 13 (API 수준 33) 이상에서 사용자가 알림 권한을 거부하면 작업 관리자 상에는 foreground service와 관련된 알림이 계속 표시되지만 알림 창에는 표시되지 않습니다.


4)manifest에서 foreground service 선언
앱의 매니페스트에서 <service> 요소를 사용하여 앱의 각 foreground service를 선언합니다. 각 service에 대해 android:foregroundServiceType 속성을 사용하여 service가 하는 일의 종류를 선언합니다. 예를 들어 앱에서 음악을 재생하는 foreground service를 만드는 경우 다음과 같이 선언할 수 있습니다.
<manifest xmlns:android="http://schemas.android.com/apk/res/android" ...>
    <service
        android:name=".MyMediaPlaybackService"
        android:foregroundServiceType="mediaPlayback"
        android:exported="false">
    </service>
</manifest>

service에 여러 유형이 적용되는 경우 | 연산자를 사용합니다. 예를 들어 카메라와 마이크를 사용하는 service는 다음과 같이 선언합니다.
android:foregroundServiceType="camera|microphone"

앱에서 타겟팅하는 API 수준에 따라 앱 매니페스트에서  반드시 선언해야 할 foreground service가 있습니다. 하지만 꼭 필요하지 않더라도 모든 foreground service를 선언하고 service 유형을 제공하는 것이 좋습니다.
-API 수준 29 이상: location 유형을 사용하여 위치 정보를 사용하는 모든 foreground service를 선언해야 합니다.
-API 수준 30 이상: camera 또는 microphone 유형을 각각 사용하여 카메라 또는 마이크를 사용하는 모든 foreground service를 선언해야 합니다.
-API 수준 34 이상: 모든 유형의 foreground service를 선언해야 합니다.

foreground service를 만드는데 매니페스트에 유형이 선언되지 않은 경우, startForeground() 호출 시 시스템에서 MissingForegroundServiceTypeException이 발생합니다. 하지만  API 29부터 매니페스트에 선언된 유형의 하위 집합에만 액세스하는 경우 다음 코드 스니펫처럼 service 접근을 제한할 수 있습니다.

Notification notification = ...;
Service.startForeground(notification, FOREGROUND_SERVICE_TYPE_LOCATION);

FOREGROUND_SERVICE_TYPE_MANIFEST 유형일 경우 매니페스트 속성에 지정된 모든 플래그를 사용합니다.
 

5)권한요청
 Android 9(API 레벨 28) 이상을 대상으로 하고 foreground service를 사용하는 앱은 매니페스트에서 FOREGROUND_SERVICE 권한을 요청해야 합니다. 이 권한은 normal 권한이므로 시스템은 별도의 권한 부여 없이 앱에 자동으로 권한을 부여합니다. 하지만 만약 FOREGROUND_SERVICE 권한 허가 없이 foreground service를 생성하려고 시도하면, 시스템은 SecurityException을 발생시킵니다.

또한 앱이 API 수준 34 이상을 타겟팅하는 경우 foreground service가 실행할 내용에 따른 적절한 권한 유형을 요청해야 합니다. 각 foreground service 유형에는 상응하는 권한 유형이 있습니다. 예를 들어 앱이 카메라를 사용하는 foreground service를 실행한다면 FOREGROUND_SERVICE 및 FOREGROUND_SERVICE_CAMERA 권한을 모두 요청해야 합니다. 이는 모두 normal 권한이므로 시스템은 매니페스트에 나열되면 자동으로 권한을 부여합니다. 하지만 만약 필요한 특정 권한을 요청하지 않으면 시스템은 SecurityException을 발생시킵니다.

<manifest xmlns:android="http://schemas.android.com/apk/res/android" ...>

    <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_CAMERA"/>

    <application ...>
        ...
    </application>
</manifest>

+각 service 유형에 따른 특정 기본 요건을 확인하려면 아래의 문서에서 알 수 있습니다.
https://developer.android.com/guide/components/fg-service-types?hl=ko


6)foreground service 시작
시스템에 service를 포그라운드로 실행 요청하기 전에, service를 실행하려는 곳에서 service 자체를 시작해야 합니다.
Context context = getApplicationContext();
Intent intent = new Intent(...); // service의 인텐트를 빌드합니다
context.startForegroundService(intent);

일반적으로 service에 있는 onStartCommand()에서 포그라운드로 실행될 수 있게 합니다. 이때 startForeground()를 사용합니다. 이 메서드는 2개 또는 3개의 매개변수를 가집니다.

startForeground (int id, Notification notification)
startForeground (int id, Notification notification, int foregroundServiceType)

id는 알림의 식별자를 의미합니다. 이때 0을 사용하면 안됩니다. 상태 표시줄 알림은 PRIORITY_LOW 이상의 우선순위를 사용해야 합니다. 앱에서 우선순위가 더 낮은 알림을 사용하려고 하면 시스템에서 알림 창에 메시지를 추가하여 앱의 foreground service 사용을 사용자에게 알립니다. foregroundServiceType는 위의 4)에서 언급되었듯이 매니페스트에 선언된 유형의 하위 집합일 때만 사용가능합니다. 

service 유형을 더 추가해야 하는 경우 startForeground()를 다시 호출하면 됩니다. 예를 들어 피트니스 앱이 항상 location 정보는 필요하지만 미디어를 재생할 수도 없을 수도 있는 달리기 추적 service를 실행한다고 가정해 보겠습니다. 이런 경우 매니페스트에서 location와 mediaPlayback를 모두 선언해야 합니다. 그럼 위치 정보가 필요할 때 앱은 startForeground()를 호출하여 ACCESS_FINE_LOCATION 권한만 전달 하면 됩니다. 그러다가 사용자가 오디오 재생을 시작하려면 startForeground()를 다시 호출하고 ACCESS_FINE_LOCATION|FOREGROUND_SERVICE_MEDIA_PLAYBACK을 전달합니다. 매니페스트에서 선언하지 않은 foreground service 유형을 전달하면 시스템에서IllegalArgumentException이 발생합니다. 

다음은 카메라 foreground service를 실행하는 예입니다.
public class MyCameraService extends Service {

    private void startForeground() {
        // 포그라운드로 service 시작 전에, 앱에 알맞은 런타인 권한을 가진지 확인
        // 여기서는 CAMERA 권한 허가 여부 확인
        int cameraPermission =
            ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA);
        if (cameraPermission == PackageManager.PERMISSION_DENIED) {
            //카메라 권한이 없으면 포그라운드에서 실행 안됨
	    //사용자에게 알릴지 앱 UI를 업데이트 할지 고려해야됨
            stopSelf();
            return;
        }

        try {
            Notification notification =
                new NotificationCompat.Builder(this, "CHANNEL_ID")
                    // service가 실행될 동안 보여질 알림 생성
                    .build();
            int type = 0;
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                type = ServiceInfo.FOREGROUND_SERVICE_TYPE_CAMERA;
            }
            startForeground( 100, notification,  type);
        } catch (Exception e) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S &&
                    e instanceof ForegroundServiceStartNotAllowedException
            ) {
                // 백그라운드에서 시작하는 것처럼 
                         // foreground service를 시작할 수 있는 유효 상태가 아님
            }
            // ...
        }
    }

    //...
}


7)foreground에서 service 삭제
service를 포그라운드에서 제거하려면 stopForeground()를 호출하면 됩니다. 이 메서드는 상태 표시줄 알림 제거 여부를 나타내는 boolean 값을 취합니다. service가 중단되지는 않습니다. service가 포그라운드에서 실행 중일 때 중단되면 알림도 마찬가지로 제거됩니다.


8)앱에 실행 중인 foreground service를 사용자에 의해 멈추는 방법
(작업 관리자 사진)
 Android 13(API 레벨 33)부터 SDK 버전에 상관없이 foreground service를 실행하고 있는 앱을 멈추기 위해, 사용자는 알림 드로어에서 작업 흐름을 끝낼 수 있습니다. 이러한 동작을 작업 관리자라 하며 현재 foreground service를 실행 중인 앱 목록을 표시합니다. 이 목록은 활동 중인 앱이라고 부릅니다. 각 앱 옆에는 동작을 멈추는 버튼이 있습니다. 위 사진의 작업 관리자 작업은 Android13에서 실행중입니다. 작업 관리자에 있는 각 앱의 멈춤 버튼을 사용자가 누르게 되면 다음과 같은 일이 벌어집니다.

-시스템이 메모리에서 앱을 제거합니다. 그렇기에 foreground service뿐만 아니라 전체 앱이 중지됩니다.
-시스템이 앱의 activity 백스택을 제거합니다.
-모든 미디어 재생이 중지됩니다.
-foreground service 연관된 알람이 제거됩니다.
-앱은 기록에 남습니다.
-예약된 작업은 예약된 시간에 실행됩니다.
-알람은 예약된 시간 또는 알람 창에 울립니다.

 사용자가 중지 버튼을 누를 때 시스템은 앱에 콜백을 보내지 않습니다. 앱이 다시 시작할 때 ApplicationExitInfo API의 일부인 REASON_USER_REQUESTED를 통해 원인을 확인할 수 있습니다.

사용자가 앱을 중지하는 동안과 이후에도 앱이 예상대로 작동하는지 테스트하려면 터미널 창에서 다음 ADB 명령을 실행합니다
$adb shell cmd activity stop-app PACKAGE_NAME


9)예외사항
 시스템은 다음 내용에서 설명하는 특정 유형의 앱에 대해 몇 가지 수준의 예외를 제공합니다. 예외는 프로세스별이 아니라 앱별로 이루어집니다. 시스템이 앱의 한 프로세스를 예외하면 해당 앱의 다른 모든 프로세스도 예외가 됩니다.  제조업체에서 제공한 일부 기본으로 설치된 앱도 예외될 수 있습니다.
 
작업 관리자에 나타나는 예외
다음 앱은 foreground service를 실행할 수 있지만 작업 관리자에 전혀 표시되지 않습니다. 
-시스템 수준의 앱
-ROLE_EMERGENCY역할을 가진 보안 앱
-데모모드에 있는 기기

사용자가 중지하는 것에서의 예외
다음 유형의 앱은 foreground service를 실행하면 작업 관리자에 나타나지만 앱 이름 옆에 사용자가 탭할 수 있는 중지 버튼이 없습니다.
-Device owner apps
-Profile owner apps
-Persistent apps
-ROLE_DIALER 역할을 가진 앱


10)foreground service 대체 API 사용
많은 사용 사례에서 foreground service를 통해 할 수 있는 작업을 실행해주는 플랫폼 또는 Jetpack API가 있습니다. 자신의 목적에 맞게 빌드된 API가 있다면 대부분foreground service 대신 이 API를 사용해야 합니다. 전용 API에는 보통 개발자가 직접 빌드해야 하는 각 사용 사례별 기능을 제공합니다. 
(Bubbles api 사진,https://developer.android.com/guide/topics/ui/bubbles?hl=ko)
예를 들어 Bubbles API는 채팅 풍선 기능을 구현해야 하는 메시지 앱을 위한 복잡한 UI 로직을 처리합니다.

포그라운드 서비스 유형 문서에는 foreground service 대신 사용할 수 있는 좋은 대안이 나열되어 있습니다.
https://developer.android.com/guide/components/fg-service-types?hl=ko


11)백그라운드에서 foreground service 시작 시 제한사항
 Android 12(API 레벨 31) 이상을 대상으로 하는 앱은 몇 가지 특별한 경우를 제외하고 백그라운드에서 실행되는 동안 foreground service를 시작할 수 없습니다. 만약 예외처리 사항을 처리하지 않았다면 시스템은 ForegroundServiceStartNotAllowedException를 발생시킵니다. 한 앱이 Context.startForgroundService()를 호출하여 다른 앱이 소유한 foreground service를 시작하는 경우, 이러한 제한은 두 앱 모두 Android 12 이상을 대상으로 하는 경우에만 적용됩니다.

백그라운드 시작 제한 예외
다음과 같은 경우에는 앱이 백그라운드에서 실행되는 동안에도 foreground service를 시작할 수 있습니다.
-앱이 activity같이 사용자가 볼 수 있는 상태로 전환할 때.
-앱이 백그라운드에서 activity 시작할 때(백스택에 기존 작업이 있는 activity를 가진 경우는 제외).
-알람, 위젯이나 activty같이 사용작용할 수 있는 앱과 관련된 UI요소를 사용자가 작업을 할 때.
-사용자의 요청을 완료하기 위해 정확한 알림이 호출할 때.
-앱이 기기의 현재 입력 방식일 때.
-사용자가 앱의 배터리 최적화를 사용 중지 할 때.
더 자세한 사항은 공식문서 참고해주세요.
https://developer.android.com/develop/background-work/services/foreground-services?hl=ko#background-start-restriction-exemptions

사용하는 동안 권한이 필요한 foreground service 시작 시 제한사항
 Android 14(API 수준 34) 이상에서는 사용 중에 권한이 필요한 foreground service를 시작하는 경우 주의해야 하는 특수한 상황이 있습니다. 앱 사용 중에 권한이 필요한 foreground service를 실행하려는 경우, 앱이 백그라운드 시작 제한의 예외 중 하나라도 속해도 백그라운드에 있는 동안에는 serivce를 만들 수 없습니다. 앱이 Android 14 이상을 타겟팅할 때, 운영체제는 개발자가 foreground service를 만들 때 앱에 이 service 유형에 적합한 모든 권한이 있는지 확인합니다. 예를 들어 microphone 유형의 foreground service를 생성하면 운영체제는 현재 앱에 RECORD_AUDIO 권한이 있는지 확인합니다. 이 권한이 없으면 시스템에서 SecurityException이 발생합니다.
 잠재적인 문제가 발생할 수 있습니다. 앱 사용 중에 권한이 필요하는 경우 포그라운드에 있는 동안에만 해당 권한을 갖습니다. 즉, 앱이 백그라운드에 있고 카메라, 위치 또는 마이크 유형의 foreground service를 만들려고 하면 시스템은 앱에 현재 필요한 권한이 없다고 판단하여 SecurityException을 발생시킵니다. 마찬가지로 앱이 백그라운드에 있고 BODY_SENSORS_BACKGROUND 권한이 필요한 건강 service를 만드는 경우, 앱에는 현재 해당 권한이 없으며 시스템에서 예외가 발생합니다. ACTIVITY_RECOGNITION 권한은 해당되지 않습니다. ContextCompat.checkSelfPermission()를 호출해도 이 문제를 예방할 수 없습니다. 앱에 사용 해야 할 권한이 있는지 확인하기 위해 checkSelfPermission()를 호출하면, 앱이 백그라운드에 있더라도 PERMISSION_GRANTED를 반환합니다. PERMISSION_GRANTED는 '앱이 사용되는 동안 앱에 이 권한이 있습니다.'라는 의미입니다. 즉, checkSelfPermission()를 호출하여도 권한이 있다고 반환하기 때문에 잘못된 판단을 야기합니다.
 Android 14 미만 버전에서 앱이 백그라운드에 있을 때 사용 중 권한이 필요한 foreground service를 만들려고 하면, 시스템에서는 service를 만들 수 있지만 service는 필요한 리소스에 액세스할 수 없으며 이를 사용하려고 하면 예외가 발생합니다. Android 14 이상에서는 즉시 예외가 발생합니다. 이러한 이유로 제한 사항 예외에 한 개라도 속하지 않는 다면, 앱에 표시되는 activity가 있는 동안 Context.startForegroundService() 또는 Context.bindService()를 호출해야 합니다.

사용 중 권한이 필요한 foreground service 시작 시 제한사항 예외
경우에 따라 앱이 백그라운드에서 실행되는 동안 foreground service가 시작되더라도 앱이 포그라운드으로 전환되어 실행되는 동안(사용 중)에는 위치, 카메라 및 마이크 정보에 액세스할 수 있습니다. 이런 상황에서 service가 location 유형을 선언하고 ACCESS_BACKGROUT_LOCATION 권한을 가진 앱에서 시작하는 경우, 이 service는 앱이 백그라운드에서 실행되는 경우에도 항상 위치 정보에 액세스할 수 있습니다. 다음 내용은 위 상황의 예시를 말합니다.
-시스템 component가 service를 시작합니다.
-앱 위젯과 상호작용하면서 service를 시작합니다.
-알람과 상호작용하면서 service를 시작합니다.
-가시성 있는 다른 앱에서 보낸 PendingIntent으로 service가 시작합니다.
-device owner모드로 실행하는 device policy controller인 앱을 통해 service가 시작합니다.
-VoiceInteractionService를 제공하는 앱에서 service를 시작합니다.
-START_ACTIVITIES_FROM_BACKGROUND 특별 허가를 받은 앱에서 service를 시작합니다.

앱에서 영향을 받는 service 검토
앱을 테스트할 때 자신의 foreground service를 시작합니다. started service가 위치, 마이크 및 카메라에 대한 액세스를 제한한 경우 다음 메시지가 Logcat에 나타납니다.
Foreground service started from background can not have \
location/camera/microphone access: service SERVICE_NAME



5. Bound service란
1)bound service?
Bound service란 클라이언트-서버 인터페이스 안의 서버를 말하며 일종의 Service 클래스 구현으로, 이를 통해 다른 애플리케이션이 service에 바인딩하여 상호작용할 수 있도록 합니다. 이를 사용하면 component를 service에 바인딩하고, 요청을 보내고, 응답을 수신하며, 프로세스 간 통신(IPC)을 실행할 수 있습니다.
연결을 오래 유지하기위해 bindService()를 호출하여 애플리케이션 component를 service에 바인딩하는 겁니다. 일반적으로는 startService()를 호출하더라도 component가 service를 시작하도록 허용하지 않습니다. activity나 다른 component에서 service와 상호작용하기를 원하는 경우 bound service를 생성해야 합니다. 아니면 애플리케이션의 기능 몇 가지를 프로세스 간 통신(IPC)을 통해 다른 애플리케이션에 노출하고자 하는 경우에도 사용됩니다.
 
bound service를 생성하려면 클라이언트가 service와 통신할 수 있는 인터페이스를 정의해야 합니다. 바인딩을 제공하는 onBind() 콜백 메서드를 구현하여 인터페이스를 정의하는 IBinder를 반환하도록 해야 합니다. 그럼 클라이언트는 이 IBinder를 받아 해당 인터페이스를 통해 service와 상호작용 할 수 있습니다. 즉 다른 component가 bindService()를 호출하여 해당 인터페이스를 탐색하고, service에 있는 메서드를 호출할 수 있습니다. 일반적으로 bound service는 다른 애플리케이션 component에 사용될 때까지만 유지되고 백그라운드에서 무한히 실행되지는 않습니다. 그렇기 때문에 service에 바인딩된 component가 없으면 시스템이 이를 소멸시킵니다. 따로 중단하지 않아도 됩니다.

여러 클라이언트가 service에 한꺼번에 바인딩될 수 있습니다. 클라이언트가 service와의 상호작용이 끝나면 unbindService()를 호출하여 바인딩을 해제합니다. service에 바인딩된 클라이언트가 하나도 없으면 시스템이 해당 servcie를 소멸시킵니다.

Android 시스템이 service를 강제 중단하는 것은 메모리가 부족하여 사용자 포커스를 가진 activity를 위해 시스템 리소스를 회복해야만 하는 경우로만 국한됩니다. service가 사용자 포커스를 가진 activity에 바인딩 되었으면 종료될 가능성이 적고 service가 포그라운드에서 실행되도록 선언된 경우에는 종료될 가능성이 희박합니다. 

bound service를 구현하는 데에는 여러 가지 방법이 있지만 started service보다 훨씬 복잡합니다. 다음 내용에 이를 확인 할 수 있습니다. 


2)bound service 생성
바인딩을 제공하는 service를 생성하기 위해,  클라이언트가 service와 상호작용하는데 사용할 수 있는 프로그래밍 인터페이스를 제공하는 IBinder를 제공해야 합니다. 인터페이스를 정의하는 방법은 세 가지가 있습니다.

바인더 클래스 확장
Service가 애플리케이션 전용이고 클라이언트와 같은 프로세스에서 실행되는 경우(이런 경우가 일반적), 인터페이스를 생성할 때 Binder 클래스를 확장하고 그 인스턴스를 onBind()에서 반환하는 방식을 사용합니다. 클라이언트는 Binder를 받고, 이를 사용하여 Binder 구현이나 Service에서 제공되는 public 메서드에 직접 액세스할 수 있습니다. service가 애플리케이션을 위해 단순히 백그라운드에서 작동하는 요소에 그치는 경우 선호되는 기법입니다. 인터페이스를 생성할 때 이 방식을 사용하지 않는 경우는 service를 다른 애플리케이션이나 별도의 프로세스에서 사용할 때뿐입니다.

메신저 사용
인터페이스가 여러 프로세스에서 작동해야 하는 경우, Messenger로 service 인터페이스를 생성할 수 있습니다. 이 방식을 사용하면 service가 여러 가지 유형의 Message 객체에 응답하는 Handler를 정의합니다. 이 Handler가 Messenger의 기초가 되어 클라이언트와 IBinder를 공유하고, 클라이언트는 Message 객체를 사용해 service에 명령어를 보낼 수 있게 됩니다. 그 외에도 클라이언트가 자체적으로 Messenger를 정의하여 service가 메시지를 돌려보내도록 할 수 있습니다. 이 방법이 프로세스 간 통신(IPC)을 실행하는 가장 간단한 방법입니다. Messenger가 모든 요청을 단일 스레드로 큐에 저장하므로 service를 스레드로부터 안전하게 설계할 필요가 없기 때문입니다.

AIDL 사용
 Android 인터페이스 정의 언어(AIDL)는 객체를 운영체제가 이해할 수 있는 원시 유형으로 해체한 다음, 여러 프로세스에서 마샬링하여 IPC를 실행합니다. Messenger를 사용하는 이전 기법은 실제로 AIDL을 기본 구조로 하고 있습니다. 위에서 언급한 바와 같이 Messenger는 단일 스레드에 모든 클라이언트 요청 큐를 생성하므로 service는 한 번에 하나씩 요청을 수신합니다. 그러나 service가 동시에 여러 요청을 처리하게 하려면 AIDL을 직접 사용해야 됩니다. 이 경우에 service는 스레드로부터 안전해야 하고 다중 스레딩 처리가 가능해야 합니다.
 AIDL을 직접 사용하려면 프로그래밍 인터페이스를 정의하는 .aidl 파일을 생성해야 합니다. Android SDK 도구는 이 파일을 사용하여 인터페이스를 구현하고 IPC를 처리하는 추상 클래스를 생성합니다. 그 후에는 개발자가 service 내에서 이 추상 클래스를 확장하면 됩니다. 대부분의 애플리케이션은 bound service를 생성할 때 AIDL을 사용하지 않습니다. 사용하려면 다중 스레딩 기능이 필요할 수 있어 구현이 더욱 복잡해지기 때문입니다. 이런 이유로 AIDL은 대부분의 애플리케이션에 적합하지 않습니다.

▶바인더 클래스 확장
service가 로컬 애플리케이션에서만 사용되고 여러 프로세스에서 작동할 필요가 없을 때 사용하며 가장 보편적인 경우입니다. 예를 들어 음악 앱의 경우 백그라운드에서 음악을 재생하는 자체 service에 activity를 바인딩합니다. 자체적인 Binder 클래스를 구현하여 클라이언트가 service 내의 public 메서드에 직접 액세스하도록 할 수도 있습니다. 설정하는 방법은 다음과 같습니다.

1. service에서 다음 중 한 가지 기능을 하는 Binder의 인스턴스를 생성합니다.
-클라이언트가 호출할 수 있는 public 메서드를 포함합니다.
-클라이언트가 호출할 수 있는 public 메서드가 있는 현재 Service 인스턴스를 반환합니다.
-클라이언트가 호출할 수 있는 public 메서드가 포함된 service가 호스팅하는 다른 클래스의 인스턴스를 반환합니다.
2.Binder의 인스턴스를 onBind() 콜백 메서드에서 반환합니다.
3.클라이언트에서 Binder를 onServiceConnected() 콜백 메서드에서 받아서 제공된 메서드로 bound service를 호출합니다.

service와 클라이언트가 같은 애플리케이션에 있어야 클라이언트가 반환된 객체를 전송하여 그 API를 적절하게 호출할 수 있습니다. 또한 service와 클라이언트는 같은 프로세스에 있어야 하기도 합니다. 이 방법에서는 여러 프로세스에서의 마샬링을 전혀 실행하지 않기 때문입니다.

다음 예시는 service가 Binder 구현을 통해 service 내의 메서드에 액세스할 수 있는 권한을 클라이언트에 제공하는 것을 보여줍니다.

public class LocalService extends Service {
    // 클라이언트에 제공된 바인더
    private final IBinder binder = new LocalBinder();
    // 랜덤 숫자 생성기
    private final Random mGenerator = new Random();

    /**
     *클라이언트 바인더에 사용되는 클래스입니다. 이 service는 항상  클라이언트와 
     * 동일한 프로세스에서 실행되므로 IPC를 처리할 필요가 없습니다.
      */
    public class LocalBinder extends Binder {
        LocalService getService() {
            // LocalService의 this 인스턴스를 리턴하기에 클라이언트는 public 메소드들을 호출할 수 있습니다.
            return LocalService.this;
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        return binder;
    }

    /** 클라이언트를 위한 메소드 */
    public int getRandomNumber() {
      return mGenerator.nextInt(100);
    }
}

 LocalBinder는 LocalService의 현재 인스턴스를 검색하기 위한 getService() 메서드를 클라이언트에 제공합니다. 이렇게 하면 클라이언트가 service 내의 public 메서드를 호출할 수 있습니다. 예를 들어 클라이언트는 service에서 getRandomNumber()를 호출할 수 있습니다.

다음은 버튼을 클릭했을 때 LocalService에 바인딩되어 getRandomNumber()를 호출하는 활동을 나타냅니다.
public class BindingActivity extends Activity {
    LocalService mService;
    boolean mBound = false;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
    }

    @Override
    protected void onStart() {
        super.onStart();
        // LocalService로 바인드
        Intent intent = new Intent(this, LocalService.class);
        bindService(intent, connection, Context.BIND_AUTO_CREATE);
    }

    @Override
    protected void onStop() {
        super.onStop();
        unbindService(connection);
        mBound = false;
    }

    /** 버튼이 클릭되었을 때 호출(레이아웃 파일의 버튼에서 android:onClick 
       속성으로 이 메소드를 결합 **/
    public void onButtonClick(View v) {
        if (mBound) {
            // LocalService에서의 메소드를 호출. 그러나 이 호출이 중단될 경우,
            // 활동 성능 저하를 방지하기 위해 별도의 스레드에서 이 요청을
	    // 발생해야 합니다.
            int num = mService.getRandomNumber();
            Toast.makeText(this, "number: " + num, Toast.LENGTH_SHORT).show();
        }
    }

    /** bindService()에 전달된 service 바인딩에 대한 콜백을 정의합니다. */
    private ServiceConnection connection = new ServiceConnection() {
	
	//onBind()가 반환한 IBinder를 전달
        @Override
        public void onServiceConnected(ComponentName className,
                IBinder service) {
            // LocalService로 바인드하여 IBinder를 캐스트하고 
	    //LocalService 인스턴스를 가져옵니다.
            LocalBinder binder = (LocalBinder) service;
            mService = binder.getService();
            mBound = true;
        }

        @Override
        public void onServiceDisconnected(ComponentName arg0) {
            mBound = false;
        }
    };
}

위 예시는 클라이언트가 ServiceConnection 구현과 onServiceConnected() 콜백을 사용하여 service에 바인딩되는 방법을 보여줍니다. onStop() 메서드는 service에서 클라이언트의 바인딩을 해제합니다. 적절한 시기에 service에서 클라이언트의 바인딩을 해제해야 합니다


▶메신저 사용
 service가 원격 프로세스와 통신해야 한다면 Messenger를 사용하여 service에 인터페이스를 제공할 수 있습니다. 이 방법을 사용하면 AIDL을 쓰지 않고도 프로세스 간 통신(IPC)을 실행할 수 있습니다. 인터페이스에 Messenger를 사용하는 것은 AIDL을 사용하는 것보다 더욱 간단합니다. Messenger는 모든 service 호출을 큐에 올리기 때문입니다. 순수한 AIDL 인터페이스는 service에 동시 요청을 보내고, 이를 받은 service는 다중 스레딩을 처리해야 합니다. 대부분의 애플리케이션에서는 service가 다중 스레딩을 처리할 필요가 없으므로 Messenger를 사용하여 한 번에 하나씩 호출을 처리할 수 있습니다. service의 다중 스레딩 처리가 중요한 경우, AIDL을 사용하여 인터페이스를 정의해야 합니다. 사용 방법은 다음과 같습니다.

1. service가 각 클라이언트 호출의 콜백을 받는 Handler를 구현합니다.
2. service가 Handler를 사용하여 Messenger 객체(Handler의 참조)를 생성합니다.
3. Messenger가 IBinder를 생성하고, service가 이를 onBind()에서 클라이언트로 반환하도록 합니다.
4. 클라이언트는 IBinder를 사용하여 Messenger(service의 Handler를 참조)를 인스턴스화하고, 이를 이용하여 Message 객체를 service에 전송합니다.
5. service가 각 Message를 Handler로 수신합니다.handleMessage() 메서드를 사용합니다.

이렇게 하면 클라이언트가 service에서 호출할 메서드가 없습니다. 대신 클라이언트는 메시지(Message 객체)를 전달하여 service가 Handler로 받을 수 있도록 합니다.

다음은 Messenger 인터페이스를 사용하는 service의 간단한 예시입니다.

public class MessengerService extends Service {
    // service에 메시지를 표시하는  명령
    static final int MSG_SAY_HELLO = 1;

 //클라이언트에서 오는 메시지 Handler
    static class IncomingHandler extends Handler {
        private Context applicationContext;

        IncomingHandler(Context context) {
            applicationContext = context.getApplicationContext();
        }

        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case MSG_SAY_HELLO:
                    Toast.makeText(applicationContext, "hello!", Toast.LENGTH_SHORT).show();
                    break;
                default:
                    super.handleMessage(msg);
            }
        }
    }

   //  클라이언트가 IncomingHandler에 메시지를 보낼 수 있게 하는 대상
    Messenger mMessenger;

    /**
     * service에 바인딩할 때 service에 메시지를 보내기 위해 
     *  메신저에 인터페이스를 반환
     */
    @Override
    public IBinder onBind(Intent intent) {
        Toast.makeText(getApplicationContext(), "binding", Toast.LENGTH_SHORT).show();
        mMessenger = new Messenger(new IncomingHandler(this));
        return mMessenger.getBinder();
    }
}

참고로 Handler의 handleMessage() 메서드에서 service가 수신되는 Message를 받고 what 멤버에 기초하여 무엇을 할지 결정합니다.

클라이언트는 service가 반환한 IBinder에 기초하여 Messenger를 생성하고 send()로 메시지를 전송하기만 하면 됩니다. 예를 들어, 다음은 service에 바인딩되어 MSG_SAY_HELLO 메시지를 service에 전달하는 간단한 활동입니다.

public class ActivityMessenger extends Activity {
    /**service와 통신하기 위한 메신저 */
    Messenger mService = null;

    /** service에서 바인드를 호출했는지 여부를 나타내는 flag */
    boolean bound;


     // service의 주요 인터페이스와 상호작용을 위한 클래스
    private ServiceConnection mConnection = new ServiceConnection() {
        public void onServiceConnected(ComponentName className, IBinder service) {
            // service와의 연결이 설정된 경우 이를 호출하여 service와
            // 상호 작용하는데 사용할 수 있는 개체를 제공.
            // 메신저를 사용하여 service와 통신하기 때문에
            // 여기서는 원시 IBinder 객체에서 클라이언트 측 표현을 얻음
            mService = new Messenger(service);
            bound = true;
        }

        public void onServiceDisconnected(ComponentName className) {
            // 서비스와의 연결이 예기치 않게 끊어졌을 때, 
	   // 즉 프로세스가 중단되었을 때 이를 호출
            mService = null;
            bound = false;
        }
    };

    public void sayHello(View v) {
        if (!bound) return;
        // 기본적으로 지원되는 'what' 값을 사용하여 service에 메시지 생성 및 전송
        Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0);
        try {
            mService.send(msg);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
    }

    @Override
    protected void onStart() {
        super.onStart();
        //service에 바인드
        bindService(new Intent(this, MessengerService.class), mConnection,
            Context.BIND_AUTO_CREATE);
    }

    @Override
    protected void onStop() {
        super.onStop();
        // service 해제
        if (bound) {
            unbindService(mConnection);
            bound = false;
        }
    }
}

이 예시는 service가 클라이언트에 응답하는 방식을 보여주지는 않습니다. service가 응답하게 하려면 클라이언트에서 Messenger도 생성해야 합니다. 클라이언트가 onServiceConnected() 콜백을 받으면 send() 메서드의 replyTo 매개변수에 클라이언트의 Messenger를 포함하는 service에 Message를 전송합니다. 

▶AIDL 정보
AIDL는 자주 사용되는 내용도 아니고 복잡하기 때문에 자세한 내용은 생략합니다. 관심 있으신 분은 공식 문서를 확인해주시길 바랍니다.
https://developer.android.com/guide/components/aidl?hl=ko


3)service에 바인딩
service을 바인딩하려면 bindService()를 호출하면 됩니다. 그러면 Android 시스템이 service의 onBind() 메서드를 호출하고, 이 메서드가 service와의 상호작용을 위한 IBinder를 반환합니다. 바인딩은 비동기식으로 처리되고, IBinder를 클라이언트에 반환하지 않은 상태에서 bindService()가 즉시 반환됩니다. bindService()의 반환 값은 요청된 service가 존재하는지, 클라이언트에 service 액세스 권한이 있는지 나타냅니다. IBinder를 수신하기 위해 클라이언트는 serivce와의 연결을 모니터링하는 ServiceConnection를 구현하여 인스턴스를 생성하고 이를 bindService()에 전달해야 합니다. Android 시스템이 클라이언트와 service 사이에 연결을 생성하면 ServiceConnection에서 onServiceConnected()를 호출합니다. onServiceConnected() 메서드에는 IBinder 인수가 포함되고 클라이언트는 사용하여 bound service와 통신합니다. Activity, service, content provider만 service에 바인딩할 수 있으며, broadcast receiver에서는 service에 바인딩할 수 없습니다. 클라이언트에서 service에 바인딩하는 방법은 다음과 같습니다.

1. ServiceConnection을 구현합니다.이 구현으로 두 가지 콜백 메서드를 재정의해야 합니다.
-onServiceConnected()
 시스템이 이를 호출하여 service의 onBind() 메서드가 반환한 IBinder를 전달합니다.
-onServiceDisconnected()
 Android 시스템은 service로의 연결이 예기치 못하게 끊어졌을 경우, 예를 들어 service가 비정상 종료되었거나 중단되었을 때 호출합니다. 클라이언트가 바인딩을 해제할 때는 호출되지 않습니다.

2. bindService()를 호출하여 ServiceConnection 구현을 전달합니다. 메서드가 false를 반환하면 클라이언트가 service에 제대로 연결되지 않았다는 것을 의미합니다. false이라도 클라이언트는 unbindService()를 호출해야 합니다. 그렇지 않으면 클라이언트가 유휴 상태인 service를 종료하지 못하게 합니다.

3. 시스템이 onServiceConnected() 콜백 메서드를 호출하면, 인터페이스가 정의한 메서드를 사용하여 service에 호출을 시작할 수 있습니다.

4. service로부터 연결을 해제하려면 unbindService()를 호출합니다. 클라이언트가 service에 여전히 바인딩 되었지만 앱이 클라이언트를 소멸시킬 때 이 소멸로 인해 클라이언트가 바인딩 해제됩니다. 클라이언트가 service와의 상호작용을 완료하는 즉시 바인딩을 해제하는 편이 좋습니다. 이렇게 하면 유휴 상태인 service를 종료할 수 있습니다. 

다음 예시에서는 바인더 클래스를 확장해서 생성한 service에 클라이언트를 연결합니다. 여기에서는 반환된 IBinder를 LocalBinder 클래스로 전송하고 LocalService 인스턴스를 요청하기만 하면 됩니다.

LocalService mService;
private ServiceConnection mConnection = new ServiceConnection() {
    // service와의 연결이 설정되면 호출
    public void onServiceConnected(ComponentName className, IBinder service) {
        //자체 프로세스에서 실행되는 명시적 service에 바인딩 되기 때문에
        // IIBinder를 특정 클래스로 캐스팅하여 직접 액세스할 수 있음
        LocalBinder binder = (LocalBinder) service;
        mService = binder.getService();
        mBound = true;
    }

    //service와의 연결이 예기치 않게 끊어지면 호출
    public void onServiceDisconnected(ComponentName className) {
        Log.e(TAG, "onServiceDisconnected");
        mBound = false;
    }
};

다음 예시에서와 같이, ServiceConnection이 있으면 클라이언트는 이를 bindService()에 전달하여 service에 바인딩할 수 있습니다.

Intent intent = new Intent(this, LocalService.class);
bindService(intent, connection, Context.BIND_AUTO_CREATE);

bindService()의 첫 번째 매개변수는 바인딩할 service의 이름을 명시적으로 지정하는 Intent입니다. 인텐트를 사용하여 Service에 바인딩하는 경우 명시적 인텐트를 사용하여 앱의 보안을 유지시켜야 합니다. 암시적 인텐트를 사용하여 service를 시작하면 어떤 service가 인텐트에 응답할지 확신할 수 없고 어떤 service가 시작하는지 사용자가 알 수 없으므로 보안 위험이 있습니다. Android 5.0(API 수준 21)부터는 암시적 인텐트로 bindService()를 호출하면 시스템에서 예외가 발생합니다. 두 번째 매개변수는 ServiceConnection 객체입니다. 세 번째 매개변수는 바인딩 옵션을 나타내는 플래그입니다. 일반적으로는 BIND_AUTO_CREATE가 되는데, 이는 service가 아직 활성화되지 않았을 경우 service를 생성하기 위함입니다. 그 외에는   BIND_DEBUG_UNBIND와 BIND_NOT_FOREGROUND를 사용할 수 있고 값이 없으면 0으로 설정합니다.

다음은 service로의 바인딩에 관한 몇 가지 중요한 참고사항입니다.
-항상 DeadObjectException 예외 사항을 작성해야하며 이 예외는 연결이 끊어지면 발생합니다. 이 예외만 유일하게 원격 메서드에 의해 발생합니다.
-객체는 여러 프로세스에 걸쳐 카운트되는 참조입니다.
-일반적으로 클라이언트의 수명 주기가 발생하고 해제되는 타이밍에 맞추어 바인딩과 바인딩 해제를 짝지어야 합니다.
=activity가 표시되는 동안에만 service와 상호작용해야 할 경우, onStart()(바인딩)-> onStop()(바인딩 해제) 
=백그라운드에서 activity가 중단되었을 때도 응답을 받게 하고 싶을 경우, onCreate()(바인딩)-> onDestroy()(바인딩 해제)
-백그라운드에서 실행되는 시간을 포함하여 service가 실행되는 내내 activity가 service를 사용한다는 것을 유념해야 합니다. service가 다른 프로세스에 있을 경우, 사용자가 그 프로세스의 가중치를 높이면 시스템이 이를 중단할 가능성이 커집니다.
-일반적으로 activity의 onResume()과 onPause() 중에는 바인딩하거나 바인딩을 해제하지 말아야 합니다. 이러한 콜백은 모든 수명 주기 전환에서 발생하고 이런 전환에서 발생하는 처리는 최소한으로 유지해야 하기 때문입니다. 또한, 애플리케이션의 여러 activity가 동일한 service에 바인딩 되었고 두 activity 사이에 전환이 있을 경우, 현재 activity의 바인딩이 해제된 후(일시중지 중) 다음 activity가 바인딩되기 전(다시 시작 중)에 service가 제거되었다가 다시 생성될 수 있습니다. 


4)started service에 바인딩
위에 언급되었듯이 시작되었으면서도 바인드된 service를 만들 수 있습니다. 다시 말해, startService()를 호출하여 service를 시작하고 이를 통해 service가 무한히 실행되면서 bindService()를 호출하여 클라이언트가 service에 바인딩되도록 할 수 있다는 의미입니다. service가 시작되고 바인드되도록 허용한다면, service가 실제로 시작되었을 때 시스템은 클라이언트가 모두 바인딩을 해제해도 서비스를 소멸시키지 않습니다. 그 대신 service를 직접 확실히 중단해야 합니다. 그러려면 stopSelf() 또는 stopService()를 호출하면 됩니다.

 보통은 onBind() 또는 onStartCommand()를 구현하지만, 둘 다 구현해야 할 때도 있습니다. 예를 들어 음악 플레이어의 경우 service를 무한히 실행하면서 바인딩도 제공하는 것이 유용할 수 있습니다. 이 경우 어떤 activity에서 service를 시작해 음악을 재생하면, 사용자가 애플리케이션을 닫아도 음악이 계속 재생됩니다. 그런 다음, 사용자가 애플리케이션으로 다시 돌아오면 이 activity를 service에 바인딩하여 재생 제어권을 다시 획득할 수 있습니다.

 여러 클라이언트를 하나의 service와 동시에 연결할 수 있습니다. 그러나 시스템이 IBinder service 통신 채널을 캐시합니다. 다시 말해, 첫 번째 클라이언트가 바인딩될 때만 시스템이 service의 onBind() 메서드를 호출해 IBinder를 생성합니다. 그러면 시스템이 동일한 service에 바인딩되는 모든 추가 클라이언트에 동일한 IBinder를 전달합니다. onBind()는 다시 호출하지 않습니다. 마지막 클라이언트가 service에서 바인딩을 해제하면 시스템은 service를 소멸시킵니다. 단, service가 startService()로 시작되었을 경우는 예외입니다. bound service 를 구현할 때 가장 중요한 부분은 onBind() 콜백 메서드가 반환하는 인터페이스를 정의하는 것입니다.


5)bound service 수명 주기 관리
(bound service 수명 주기 그림)
 모든 클라이언트에서 service가 바인딩 해제되면 Android 시스템이 이를 소멸시킵니다. 물론 startService() 호출과 함께 시작된 경우는 예외입니다. 따라서 service가 순수하게 bound service일 경우에는 service의 수명 주기를 관리하지 않아도 됩니다. 클라이언트에 바인딩되었는지 여부에 따라 Android 시스템이 대신 관리해주기 때문입니다. 그러나 onStartCommand() 콜백 메서드 구현을 선택하는 경우라면 service를 확실히 중지해야 합니다. service가 지금 시작된 것으로 간주되기 때문입니다. 이 경우 service가 클라이언트에 바인딩되어 있는지 여부와 관계없이, stopSelf()를 통해 service가 스스로 중지되거나 다른 component가 stopService()를 호출할 때까지 service가 실행됩니다.

 또한 service가 시작되고 바인딩을 허용하는 경우 시스템에서 onUnbind() 메서드를 호출한 다음 클라이언트가 service에 바인딩 될 때, onRebind() 호출을 수신하고 싶다면 true를 선택적으로 반환할 수 있습니다. onRebind()는 void를 반환하지만 클라이언트는 여전히 onServiceConnected() 콜백에서 IBinder를 수신합니다. 위의 그림은 이런 종류의 수명 주기에 관한 로직을 보여줍니다.